This is pcl.info, produced by makeinfo version 5.2 from pcl.texi.


File: pcl.info,  Node: Top,  Next: Preface,  Prev: (dir),  Up: (dir)

Practical Common Lisp
=====================

'that book is dead sexy' —Xach on #lisp
(C) 2003-2009, Peter Seibel

Unofficial Texinfo Format

* Menu:

* Preface::     Preface
* Letter::      Letter to the Reader
* Blurbs::      Blurbs
* Chapter 1::   Introduction: Why Lisp?
* Chapter 2::   Lather, Rinse, Repeat: A Tour of the REPL
* Chapter 3::   Practical: A Simple Database
* Chapter 4::   Syntax and Semantics
* Chapter 5::   Functions
* Chapter 6::   Variables
* Chapter 7::   Macros: Standard Control Constructs
* Chapter 8::   Macros: Defining Your Own
* Chapter 9::   Practical: Building a Unit Test Framework
* Chapter 10::  Numbers, Characters, and Strings
* Chapter 11::  Collections
* Chapter 12::  They Called It LISP for a Reason: List Processing
* Chapter 13::  Beyond Lists: Other Uses for Cons Cells
* Chapter 14::  Files and File I/O
* Chapter 15::  Practical: A Portable Pathname Library
* Chapter 16::  Object Reorientation: Generic Functions
* Chapter 17::  Object Reorientation: Classes
* Chapter 18::  A Few FORMAT Recipes
* Chapter 19::  Beyond Exception Handling: Conditions and Restarts
* Chapter 20::  The Special Operators
* Chapter 21::  Programming in the Large: Packages and Symbols
* Chapter 22::  LOOP for Black Belts
* Chapter 23::  Practical: A Spam Filter
* Chapter 24::  Practical: Parsing Binary Files
* Chapter 25::  Practical: An ID3 Parser
* Chapter 26::  Practical: Web Programming with AllegroServe
* Chapter 27::  Practical: An MP3 Database
* Chapter 28::  Practical: A Shoutcast Server
* Chapter 29::  Practical: An MP3 Browser
* Chapter 30::  Practical: An HTML Generation Library, the Interpreter
* Chapter 31::  Practical: An HTML Generation Library, the Compiler
* Chapter 32::  Conclusion: What's Next?

 -- The Detailed Node Listing --

1. Introduction: Why Lisp?

* 1-1::              Why Lisp?
* 1-2::              Where It Began
* 1-3::              Who This Book Is For

2. Lather, Rinse, Repeat: A Tour of the REPL

* 2-1::              Choosing a Lisp Implementation
* 2-2::              Getting Up and Running with Lisp in a Box
* 2-3::              Free Your Mind: Interactive Programming
* 2-4::              Experimenting in the REPL
* 2-5::              "Hello, World," Lisp Style
* 2-6::              Saving Your Work

3. Practical: A Simple Database

* 3-1::              CDs and Records
* 3-2::              Filing CDs
* 3-3::              Looking at the Database Contents
* 3-4::              Improving the User Interaction
* 3-5::              Saving and Loading the Database
* 3-6::              Querying the Database
* 3-7::              Updating Existing Records-Another Use for WHERE
* 3-8::              Removing Duplication and Winning Big
* 3-9::              Wrapping Up

4. Syntax and Semantics

* 4-1::              What's with All the Parentheses?
* 4-2::              Breaking Open the Black Box
* 4-3::              S-expressions
* 4-4::              S-expressions As Lisp Forms
* 4-5::              Function Calls
* 4-6::              Special Operators
* 4-7::              Macros
* 4-8::              Truth, Falsehood, and Equality
* 4-9::              Formatting Lisp Code

5. Functions

* 5-1::              Defining New Functions
* 5-2::              Function Parameter Lists
* 5-3::              Optional Parameters
* 5-4::              Rest Parameters
* 5-5::              Keyword Parameters
* 5-6::              Mixing Different Parameter Types
* 5-7::              Function Return Values
* 5-8::              Functions As Data, a.k.a. Higher-Order Functions
* 5-9::              Anonymous Functions

6. Variables

* 6-1::              Variable Basics
* 6-2::              Lexical Variables and Closures
* 6-3::              Dynamic, a.k.a. Special, Variables
* 6-4::              Constants
* 6-5::              Assignment
* 6-6::              Generalized Assignment

7. Macros: Standard Control Constructs

* 7-1::              WHEN and UNLESS
* 7-2::              COND
* 7-3::              AND, OR, and NOT
* 7-4::              Looping
* 7-5::              DOLIST and DOTIMES
* 7-6::              DO
* 7-7::              The Mighty LOOP

8. Macros: Defining Your Own

* 8-1::                  The Story of Mac: A Just-So Story
* 8-2::                  Macro Expansion Time vs. Runtime
* 8-3::                  DEF MACRO
* 8-4::                  A Sample Macro: do-primes
* 8-5::                  Macro Parameters
* 8-6::                  Generating the Expansion
* 8-7::                  Plugging the Leaks
* 8-8::                  Macro-Writing Macros
* 8-9::                  Beyond Simple Macros

9. Practical: Building a Unit Test Framework

* 9-1::                  Two First Tries
* 9-2::                  Refactoring
* 9-3::                  Fixing the Return Value
* 9-4::                  Better Result Reporting
* 9-5::                  An Abstraction Emerges
* 9-6::                  A Hierarchy of Tests
* 9-7::                  Wrapping Up

10. Numbers, Characters, and Strings

* 10-1::                 Numbers
* 10-2::                 Numeric Literals
* 10-3::                 Basic Math
* 10-4::                 Numeric Comparisons
* 10-5::                 Higher Math
* 10-6::                 Characters
* 10-7::                 Character Comparisons
* 10-8::                 Strings
* 10-9::                 String Comparisons

11. Collections

* 11-1::                            Vectors
* 11-2::                            Subtypes of Vector
* 11-3::                            Vectors As Sequences
* 11-4::                            Sequence Iterating Functions
* 11-5::                            Higher-Order Function Variants
* 11-6::                            Whole Sequence Manipulations
* 11-7::                            Sorting and Merging
* 11-8::                            Subsequence Manipulations
* 11-9::                            Sequence Predicates
* 11-10::                           Sequence Mapping Functions
* 11-11::                           Hash Tables
* 11-12::                           Hash Table Iteration

12. They Called It LISP for a Reason: List Processing

* 12-1::             "There Is No List"
* 12-2::             Functional Programming and Lists
* 12-3::             "Destructive" Operations
* 12-4::             Combining Recycling with Shared Structure
* 12-5::             List-Manipulation Functions
* 12-6::             Mapping
* 12-7::             Other Structures

13. Beyond Lists: Other Uses for Cons Cells

* 13-1::                Trees
* 13-2::                Sets
* 13-3::                Lookup Tables: Alists and Plists
* 13-4::                DESTRUCTURING-BIND

14. Files and File I/O

* 14-1::      Reading File Data
* 14-2::      Reading Binary Data
* 14-3::      Bulk Reads
* 14-4::      File Output
* 14-5::      Closing Files
* 14-6::      Filenames
* 14-7::      How Pathnames Represent Filenames
* 14-8::      Constructing New Pathnames
* 14-9::      Two Representations of Directory Names
* 14-10::     Interacting with the File System
* 14-11::     Other Kinds of I/O

15. Practical: A Portable Pathname Library

* 15-1::       The API
* 15-2::       *FEATURES* and Read-Time Conditionalization
* 15-3::       Listing a Directory
* 15-4::       Testing a File's Existence
* 15-5::       Walking a Directory Tree

16. Object Reorientation: Generic Functions

* 16-1::   Generic Functions and Classes
* 16-2::   Generic Functions and Methods
* 16-3::   DEFGENERIC
* 16-4::   DEFMETHOD
* 16-5::   Method Combination
* 16-6::   The Standard Method Combination
* 16-7::   Other Method Combinations
* 16-8::   Multimethods
* 16-9::   To Be Continued . . .

17. Object Reorientation: Classes

* 17-1::   DEFCLASS
* 17-2::   Slot Specifiers
* 17-3::   Object Initialization
* 17-4::   Accessor Functions
* 17-5::   WITH-SLOTS and WITH-ACCESSORS
* 17-6::   Class-Allocated Slots
* 17-7::   Slots and Inheritance
* 17-8::   Multiple Inheritance
* 17-9::   Good Object-Oriented Design

18. A Few FORMAT Recipes

* 18-1::         The FORMAT Function
* 18-2::         FORMAT Directives
* 18-3::         Basic Formatting
* 18-4::         Character and Integer Directives
* 18-5::         Floating-Point Directives
* 18-6::         English-Language Directives
* 18-7::         Conditional Formatting
* 18-8::         Iteration
* 18-9::         Hop, Skip, Jump
* 18-10::        And More . . .

19. Beyond Exception Handling: Conditions and Restarts

* 19-1::             The Lisp Way
* 19-2::             Conditions
* 19-3::             Condition Handlers
* 19-4::             Restarts
* 19-5::             Providing Multiple Restarts
* 19-6::             Other Uses for Conditions

20. The Special Operators

* 20-1::        Controlling Evaluation
* 20-2::        Manipulating the Lexical Environment
* 20-3::        Local Flow of Control
* 20-4::        Unwinding the Stack
* 20-5::        Multiple Values
* 20-6::        EVAL-WHEN
* 20-7::        Other Special Operators

21. Programming in the Large: Packages and Symbols

* 21-1::        How the Reader Uses Packages
* 21-2::        A Bit of Package and Symbol Vocabulary
* 21-3::        Three Standard Packages
* 21-4::        Defining Your Own Packages
* 21-5::        Packaging Reusable Libraries
* 21-6::        Importing Individual Names
* 21-7::        Packaging Mechanics
* 21-8::        Package Gotchas

22. LOOP for Black Belts

* 22-1::     The Parts of a LOOP
* 22-2::     Iteration Control
* 22-3::     Counting Loops
* 22-4::     Looping Over Collections and Packages
* 22-5::     Equals-Then Iteration
* 22-6::     Local Variables
* 22-7::     Destructuring Variables
* 22-8::     Value Accumulation
* 22-9::     Unconditional Execution
* 22-10::    Conditional Execution
* 22-11::    Setting Up and Tearing Down
* 22-12::    Termination Tests
* 22-13::    Putting It All Together

23. Practical: A Spam Filter

* 23-1::       The Heart of a Spam Filter
* 23-2::       Training the Filter
* 23-3::       Per-Word Statistics
* 23-4::       Combining Probabilities
* 23-5::       Inverse Chi Square
* 23-6::       Training the Filter
* 23-7::       Testing the Filter
* 23-8::       A Couple of Utility Functions
* 23-9::       Analyzing the Results
* 23-10::      What's Next

24. Practical: Parsing Binary Files

* 24-1::       Binary Files
* 24-2::       Binary Format Basics
* 24-3::       Strings in Binary Files
* 24-4::       Composite Structures
* 24-5::       Designing the Macros
* 24-6::       Making the Dream a Reality
* 24-7::       Reading Binary Objects
* 24-8::       Writing Binary Objects
* 24-9::       Adding Inheritance and Tagged Structures
* 24-10::      Keeping Track of Inherited Slots
* 24-11::      Tagged Structures
* 24-12::      Primitive Binary Types
* 24-13::      The Current Object Stack

25. Practical: An ID3 Parser

* 25-1::       Structure of an ID3v2 Tag
* 25-2::       Defining a Package
* 25-3::       Integer Types
* 25-4::       String Types
* 25-5::       ID3 Tag Header
* 25-6::       ID3 Frames
* 25-7::       Detecting Tag Padding
* 25-8::       Supporting Multiple Versions of ID3
* 25-9::       Versioned Frame Base Classes
* 25-10::      Versioned Concrete Frame Classes
* 25-11::      What Frames Do You Actually Need?
* 25-12::      Text Information Frames
* 25-13::      Comment Frames
* 25-14::      Extracting Information from an ID3 Tag

26. Practical: Web Programming with AllegroServe

* 26-1::       A 30-Second Intro to Server-Side Web Programming
* 26-2::       AllegroServe
* 26-3::       Generating Dynamic Content with AllegroServe
* 26-4::       Generating HTML
* 26-5::       HTML Macros
* 26-6::       Query Parameters
* 26-7::       Cookies
* 26-8::       A Small Application Framework
* 26-9::       The Implementation

27. Practical: An MP3 Database

* 27-1::       The Database
* 27-2::       Defining a Schema
* 27-3::       Inserting Values
* 27-4::       Querying the Database
* 27-5::       Matching Functions
* 27-6::       Getting at the Results
* 27-7::       Other Database Operations

28. Practical: A Shoutcast Server

* 28-1::       The Shoutcast Protocol
* 28-2::       Song Sources
* 28-3::       Implementing Shoutcast

29. Practical: An MP3 Browser

* 29-1::       Playlists
* 29-2::       Playlists As Song Sources
* 29-3::       Manipulating the Playlist
* 29-4::       Query Parameter Types
* 29-5::       Boilerplate HTML
* 29-6::       The Browse Page
* 29-7::       The Playlist
* 29-8::       Finding a Playlist
* 29-9::       Running the App

30. Practical: An HTML Generation Library, the Interpreter

* 30-1::       Designing a Domain-Specific Language
* 30-2::       The FOO Language
* 30-3::       Character Escaping
* 30-4::       Indenting Printer
* 30-5::       HTML Processor Interface
* 30-6::       The Pretty Printer Backend
* 30-7::       The Basic Evaluation Rule
* 30-8::       What's Next?

31. Practical: An HTML Generation Library, the Compiler

* 31-1::       The Compiler
* 31-2::       FOO Special Operators
* 31-3::       FOO Macros
* 31-4::       The Public API
* 31-5::       The End of the Line

32. Conclusion: What's Next?

* 32-1::        Finding Lisp Libraries
* 32-2::        Interfacing with Other Languages
* 32-3::        Make It Work, Make It Right, Make It Fast
* 32-4::        Delivering Applications
* 32-5::        Where to Go Next




File: pcl.info,  Node: Preface,  Next: Letter,  Prev: Top,  Up: Top

Preface
*******

This page, and the pages it links to, contain text of the Common Lisp
book Practical Common Lisp published by Apress.  These pages now contain
the final text as it appears in the book.  If you find errors in these
pages, please send email to <book@gigamonkeys.com>.  These pages will
remain online in perpetuity—I hope they will serve as a useful
introduction to Common Lisp for folks who are curious about Lisp but
maybe not yet curious enough to shell out big bucks for a dead-tree book
and a good Common Lisp tutorial for folks who want to get down to real
coding right away.  However, don't let that stop you from buying the
printed version available from Apress at your favorite local or online
bookseller.  For the complete bookstore browsing experience, you can
read the letter to the reader that appears on the back cover of the
treeware edition of the book.


File: pcl.info,  Node: Letter,  Next: Blurbs,  Prev: Preface,  Up: Top

Letter to the Reader
********************

Dear Reader,

   Practical Common Lisp ...  isn't that an oxymoron?  If you're like
most programmers, you probably know something about Lisp—from a comp
sci course in college or from learning enough Elisp to customize Emacs a
bit.  Or maybe you just know someone who won't shut up about Lisp, the
greatest language ever.  But you probably never figured you'd see
practical and Lisp in the same book title.

   Yet, you're reading this; you must want to know more.  Maybe you
believe learning Lisp will make you a better programmer in any language.
Or maybe you just want to know what those Lisp fanatics are yammering
about all the time.  Or maybe you have learned some Lisp but haven't
quite made the leap to using it to write interesting software.

   If any of those is true, this book is for you.  Using Common Lisp, an
ANSI standardized, industrial-strength dialect of Lisp, I show you how
to write software that goes well beyond silly academic exercises or
trivial editor customizations.  And I show you how Lisp—even with many
of its features adopted by other languages—still has a few tricks up
its sleeve.

   But unlike many Lisp books, this one doesn't just touch on a few of
Lisp's greatest features and then leave you on your own to actually use
them.  I cover all the language features you'll need to write real
programs and devote well over a third of the book to developing
nontrivial software—a statistical spam filter, a library for parsing
binary files, and a server for streaming MP3s over a network complete
with an online MP3 database and Web interface.

   So turn the book over, open it up, and see for yourself how eminently
practical using the greatest language ever invented can be.

   Sincerely,

   Peter Seibel


File: pcl.info,  Node: Blurbs,  Next: Chapter 1,  Prev: Letter,  Up: Top

     “I have been complimented many times and they always embarrass
     me; I always feel that they have not said enough.” —Mark Twain

Blurbs
******

     “Peter Seibel offers a fresh view of Lisp and its possibilities
     for elegantly solving problems.  In Practical Common Lisp, he gives
     enough basic information to let you quickly see the power of the
     functional language paradigm.  He then dazzles you with examples
     that seem almost magical in their simplicity and power.  This read
     is pure fun from start to finish.” -—Gary Pollice, from May 17,
     2006 article on the 2006 Jolt Awards

   “Peter Seibel's Practical Common Lisp is just what the title
implies: an excellent introduction to Common Lisp for someone who wants
to dive in and start using the language for real work.  The book is very
well written and is fun to read—at least for those of us whose idea of
fun extends to learning new programming languages.

   Rather than spending a lot of time on abstract discussion of Lisp's
place in the universe of programming lnaguages, Seibel dives right in,
guiding the reader through a series of programming examples of
increasing complexity.  This approach places the most emphasis on those
parts of Common Lisp that skilled programmers use the most, without
getting bogged down in the odd corners of Common Lisp that even the
experts must look up in the manual.  The result of Seibel's
example-driven approach is to give the reader an excellent appreciation
of the power of Common Lisp in building complex, evolving software
systems with a minimum of effort.

   There are already many good books on Common Lisp that offer a more
abstract and comparative approach, but a good ‘Here's how you do
it—and why’ book, aimed at the working programmer, is a valuable
contribution, both to current Common Lisp users and those who should
be.” —Scott E. Fahlman, Research Professor of Computer Science,
Carnegie Mellon University

   “This book shows the power of Lisp not only in the areas that it
has traditionally been noted for—such as developing a complete unit
test framework in only 26 lines of code—but also in new areas such as
parsing binary MP3 files, building a web application for browsing a
collection of songs, and streaming audio over the web.  Many readers
will be surprised that Lisp allows you to do all this with conciseness
similar to scripting languages such as Python, efficiency similar to
C++, and unparalleled flexibility in designing your own language
extensions.” —Peter Norvig, Director of Search Quality, Google Inc;
author of Paradigms of Artificial Intelligence Programming: Case Studies
in Common Lisp

   “I wish this book had already existed when I started learning Lisp.
It's not that there aren't other good books about (Common) Lisp out
there, but none of them has such a pragmatic, up-to-date approach.  And
let's not forget that Peter covers topics like pathnames or conditions
and restarts which are completely ignored in the rest of the Lisp
literature.

   If you're new to Lisp and want to dive right in don't hesitate to buy
this book.  Once you've read it and worked with it you can continue with
the ‘classics’ like Graham, Norvig, Keene, or Steele.” —Edi
Weitz, maintainer of the Common Lisp Cookbook and author of CL-PPCRE
regular expression library.

   “Two prehensile toes up!” —Kenny Tilton, comp.lang.lisp demon,
reporting on behalf of his development team.

   “Experienced programmers learn best from examples and it is
delightful to see that Lisp is finally being served with Seibel's
example-rich tutorial text.  Especially delightful is the fact that this
book includes so many examples that fall within the realm of problems
today's programmers might be called upon to tackle, such as Web
development and streaming media.—Philip Greenspun, author of Software
Engineering for Internet Applications, MIT Department of Electrical
Engineering and Computer Science

   “Practical Common Lisp is an excellent book that covers the breadth
of the Common Lisp language and also demonstrates the unique features of
Common Lisp with real-world applications that the reader can run and
extend.  This book not only shows what Common Lisp is but also why every
programmer should be familiar with Lisp.” —John Foderaro, Senior
Scientist, Franz Inc.

   “The Maxima Project frequently gets queries from potential new
contributors who would like to learn Common Lisp.  I am pleased to
finally have a book that I can recommend to them without reservation.
Peter Seibel's clear, direct style allows the reader to quickly
appreciate the power of Common Lisp.  His many included examples, which
focus on contemporary programming problems, demonstrate that Lisp is
much more than an academic programming language.  Practical Common Lisp
is a welcome addition to the literature.” —James Amundson, Maxima
Project Leader

   “I like the interspersed Practical chapters on 'real' and useful
programs.  We need books of this kind telling the world that crunching
strings and numbers into trees or graphs is easily done in
Lisp.—Professor Christian Queinnec, Universite Paris 6 (Pierre et
Marie Curie)

   “One of the most important parts of learning a programming language
is learning its proper programming style.  This is hard to teach, but it
can be painlessly absorbed from Practical Common Lisp.  Just reading the
practical examples made me a better programmer in any language.”
—Peter Scott, Lisp programmer

   “Finally, a Lisp book for the rest of us.  If you want to learn how
to write a factorial function, this is not your book.  Seibel writes for
the practical programmer, emphasizing the engineer/artist over the
scientist, subtly and gracefully implying the power of the language
while solving understandable real-world problems.

   In most chapters, the reading of the chapter feels just like the
experience of writing a program, starting with a little understanding,
then having that understanding grow, like building the shoulders upon
which you can then stand.  When Seibel introduced macros as an aside
while building a test framework, I was shocked at how such a simple
example made me really 'get' them.  Narrative context is extremely
powerful and the technical books that use it are a cut above.
Congrats!” —Keith Irwin, Lisp Programmer

   “While learning Lisp, one is often refered to the CL HyperSpec if
they do not know what a particular function does, however, I found that
I often did not 'get it' just reading the HyperSpec.  When I had a
problem of this manner, I turned to Practical Common Lisp every single
time—it is by far the most readable source on the subject that shows
you how to program, not just tell you.” —Philip Haddad, Lisp
Programmer

   “With the IT world evolving at an ever increasing pace,
professionals need the most powerful tools available.  This is why
Common Lisp—the most powerful, flexible, and stable programming
language ever—is seeing such a rise in popularity.  Practical Common
Lisp is the long-awaited book that will help you harness the power of
Common Lisp to tackle today's complex real world problems.” —Marc
Battyani, author of CL-PDF, CL-TYPESETTING, and mod_lisp.

   “Please don't assume Common Lisp is only useful for Databases, Unit
Test Frameworks, Spam Filters, ID3 Parsers, Web Programming, Shoutcast
Servers, HTML Generation Interpreters, and HTML Generation Compilers
just because these are the only things happened to be implemented in the
book Practical Common Lisp.—Tobias C. Rittweiler, Lisp Programmer

   “When I met Peter, who just started writing this book, I asked to
myself (not to him, of course) ‘why yet another book on Common Lisp,
when there are many nice introductory books?’ One year later, I found
a draft of the new book and recognized I was wrong.  This book is not
‘yet another’ one.  The author focuses on practical aspects rather
than on technical details of the language.  When I first studied Lisp by
reading an introductory book, I felt I understood the language, but I
also had an impression ‘so what?’, meaning I had no idea about how
to use it.  In contrast, this book leaps into a ‘PRACTICAL’ chapter
after the first few chapters that explain the very basic notions of the
language.  Then the readers are expected to learn more about the
language while they are following the PRACTICAL projects, which are
combined together to form a product of a significant size.  After
reading this book, the readers will feel themselves expert programmers
on Common Lisp since they have ‘finished’ a big project already.  I
think Lisp is the only language that allows this type of practical
introduction.  Peter makes use of this feature of the language in
building up a fancy introduction on Common Lisp.” —Taiichi Yuasa,
Professor, Department of Communications and Computer Engineering, Kyoto
University

   Have something to say about this book?  Something nice?  Want to see
it here?  Send it along to <book@gigamonkeys.com>.


File: pcl.info,  Node: Chapter 1,  Next: Chapter 2,  Prev: Blurbs,  Up: Top

1. Introduction: Why Lisp?
==========================

If you think the greatest pleasure in programming comes from getting a
lot done with code that simply and clearly expresses your intention,
then programming in Common Lisp is likely to be about the most fun you
can have with a computer.  You'll get more done, faster, using it than
you would using pretty much any other language.

   That's a bold claim.  Can I justify it?  Not in a just a few pages in
this chapter-you're going to have to learn some Lisp and see for
yourself-thus the rest of this book.  For now, let me start with some
anecdotal evidence, the story of my own road to Lisp.  Then, in the next
section, I'll explain the payoff I think you'll get from learning Common
Lisp.

   I'm one of what must be a fairly small number of second-generation
Lisp hackers.  My father got his start in computers writing an operating
system in assembly for the machine he used to gather data for his
doctoral dissertation in physics.  After running computer systems at
various physics labs, by the 1980s he had left physics altogether and
was working at a large pharmaceutical company.  That company had a
project under way to develop software to model production processes in
its chemical plants-if you increase the size of this vessel, how does it
affect annual production?  The original team, writing in FORTRAN, had
burned through half the money and almost all the time allotted to the
project with nothing to show for their efforts.  This being the 1980s
and the middle of the artificial intelligence (AI) boom, Lisp was in the
air.  So my dad-at that point not a Lisper-went to Carnegie Mellon
University (CMU) to talk to some of the folks working on what was to
become Common Lisp about whether Lisp might be a good language for this
project.

   The CMU folks showed him some demos of stuff they were working on,
and he was convinced.  He in turn convinced his bosses to let his team
take over the failing project and do it in Lisp.  A year later, and
using only what was left of the original budget, his team delivered a
working application with features that the original team had given up
any hope of delivering.  My dad credits his team's success to their
decision to use Lisp.

   Now, that's just one anecdote.  And maybe my dad is wrong about why
they succeeded.  Or maybe Lisp was better only in comparison to other
languages of the day.  These days we have lots of fancy new languages,
many of which have incorporated features from Lisp.  Am I really saying
Lisp can offer you the same benefits today as it offered my dad in the
1980s?  Read on.

   Despite my father's best efforts, I didn't learn any Lisp in high
school.  After a college career that didn't involve much programming in
any language, I was seduced by the Web and back into computers.  I
worked first in Perl, learning enough to be dangerous while building an
online discussion forum for Mother Jones magazine's Web site and then
moving to a Web shop, Organic Online, where I worked on big-for the
time-Web sites such as the one Nike put up during the 1996 Olympics.
Later I moved onto Java as an early developer at WebLogic, now part of
BEA. After WebLogic, I joined another startup where I was the lead
programmer on a team building a transactional messaging system in Java.
Along the way, my general interest in programming languages led me to
explore such mainstream languages as C, C++, and Python, as well as less
well-known ones such as Smalltalk, Eiffel, and Beta.

   So I knew two languages inside and out and was familiar with another
half dozen.  Eventually, however, I realized my interest in programming
languages was really rooted in the idea planted by my father's tales of
Lisp-that different languages really are different, and that, despite
the formal Turing equivalence of all programming languages, you really
can get more done more quickly in some languages than others and have
more fun doing it.  Yet, ironically, I had never spent that much time
with Lisp itself.  So, I started doing some Lisp hacking in my free
time.  And whenever I did, it was exhilarating how quickly I was able to
go from idea to working code.

   For example, one vacation, having a week or so to hack Lisp, I
decided to try writing a version of a program-a system for breeding
genetic algorithms to play the game of Go-that I had written early in my
career as a Java programmer.  Even handicapped by my then rudimentary
knowledge of Common Lisp and having to look up even basic functions, it
still felt more productive than it would have been to rewrite the same
program in Java, even with several extra years of Java experience
acquired since writing the first version.

   A similar experiment led to the library I'll discuss in Chapter 24.
Early in my time at WebLogic I had written a library, in Java, for
taking apart Java class files.  It worked, but the code was a bit of a
mess and hard to modify or extend.  I had tried several times, over the
years, to rewrite that library, thinking that with my ever-improving
Java chops I'd find some way to do it that didn't bog down in piles of
duplicated code.  I never found a way.  But when I tried to do it in
Common Lisp, it took me only two days, and I ended up not only with a
Java class file parser but with a general-purpose library for taking
apart any kind of binary file.  You'll see how that library works in
Chapter 24 and use it in Chapter 25 to write a parser for the ID3 tags
embedded in MP3 files.

* Menu:

* 1-1::              Why Lisp?
* 1-2::              Where It Began
* 1-3::              Who This Book Is For


File: pcl.info,  Node: 1-1,  Next: 1-2,  Prev: Chapter 1,  Up: Chapter 1

Why Lisp?
=========

It's hard, in only a few pages of an introductory chapter, to explain
why users of a language like it, and it's even harder to make the case
for why you should invest your time in learning a certain language.
Personal history only gets us so far.  Perhaps I like Lisp because of
some quirk in the way my brain is wired.  It could even be genetic,
since my dad has it too.  So before you dive into learning Lisp, it's
reasonable to want to know what the payoff is going to be.

   For some languages, the payoff is relatively obvious.  For instance,
if you want to write low-level code on Unix, you should learn C. Or if
you want to write certain kinds of cross-platform applications, you
should learn Java.  And any of a number companies still use a lot of
C++, so if you want to get a job at one of them, you should learn C++.

   For most languages, however, the payoff isn't so easily categorized;
it has to do with subjective criteria such as how it feels to use the
language.  Perl advocates like to say that Perl "makes easy things easy
and hard things possible" and revel in the fact that, as the Perl motto
has it, "There's more than one way to do it."  (1) Python's fans, on the
other hand, think Python is clean and simple and think Python code is
easier to understand because, as _their_ motto says, "There's only one
way to do it."

   So, why Common Lisp?  There's no immediately obvious payoff for
adopting Common Lisp the way there is for C, Java, and C++ (unless, of
course, you happen to own a Lisp Machine).  The benefits of using Lisp
have much more to do with the experience of using it.  I'll spend the
rest of this book showing you the specific features of Common Lisp and
how to use them so you can see for yourself what it's like.  For now
I'll try to give you a sense of Lisp's philosophy.

   The nearest thing Common Lisp has to a motto is the koan-like
description, "the programmable programming language."  While cryptic,
that description gets at the root of the biggest advantage Common Lisp
still has over other languages.  More than any other language, Common
Lisp follows the philosophy that what's good for the language's designer
is good for the language's users.  Thus, when you're programming in
Common Lisp, you almost never find yourself wishing the language
supported some feature that would make your program easier to write,
because, as you'll see throughout this book, you can just add the
feature yourself.

   Consequently, a Common Lisp program tends to provide a much clearer
mapping between your ideas about how the program works and the code you
actually write.  Your ideas aren't obscured by boilerplate code and
endlessly repeated idioms.  This makes your code easier to maintain
because you don't have to wade through reams of code every time you need
to make a change.  Even systemic changes to a program's behavior can
often be achieved with relatively small changes to the actual code.
This also means you'll develop code more quickly; there's less code to
write, and you don't waste time thrashing around trying to find a clean
way to express yourself within the limitations of the language.  (2)

   Common Lisp is also an excellent language for exploratory
programming-if you don't know exactly how your program is going to work
when you first sit down to write it, Common Lisp provides several
features to help you develop your code incrementally and interactively.

   For starters, the interactive read-eval-print loop, which I'll
introduce in the next chapter, lets you continually interact with your
program as you develop it.  Write a new function.  Test it.  Change it.
Try a different approach.  You never have to stop for a lengthy
compilation cycle.  (3)

   Other features that support a flowing, interactive programming style
are Lisp's dynamic typing and the Common Lisp condition system.  Because
of the former, you spend less time convincing the compiler you should be
allowed to run your code and more time actually running it and working
on it, (4) and the latter lets you develop even your error handling code
interactively.

   Another consequence of being "a programmable programming language" is
that Common Lisp, in addition to incorporating small changes that make
particular programs easier to write, can easily adopt big new ideas
about how programming languages should work.  For instance, the original
implementation of the Common Lisp Object System (CLOS), Common Lisp's
powerful object system, was as a library written in portable Common
Lisp.  This allowed Lisp programmers to gain actual experience with the
facilities it provided before it was officially incorporated into the
language.

   Whatever new paradigm comes down the pike next, it's extremely likely
that Common Lisp will be able to absorb it without requiring any changes
to the core language.  For example, a Lisper has recently written a
library, AspectL, that adds support for aspect-oriented programming
(AOP) to Common Lisp.  (5) If AOP turns out to be the next big thing,
Common Lisp will be able to support it without any changes to the base
language and without extra preprocessors and extra compilers.  (6)

   ---------- Footnotes ----------

   (1) Perl is also worth learning as "the duct tape of the Internet."

   (2) Unfortunately, there's little actual research on the productivity
of different languages.  One report that shows Lisp coming out well
compared to C++ and Java in the combination of programmer and program
efficiency is discussed at http://www.norvig.com/java-lisp.html.

   (3) Psychologists have identified a state of mind called flow in
which we're capable of incredible concentration and productivity.  The
importance of flow to programming has been recognized for nearly two
decades since it was discussed in the classic book about human factors
in programming Peopleware: Productive Projects and Teams by Tom DeMarco
and Timothy Lister (Dorset House, 1987).  The two key facts about flow
are that it takes around 15 minutes to get into a state of flow and that
even brief interruptions can break you right out of it, requiring
another 15-minute immersion to reenter.  DeMarco and Lister, like most
subsequent authors, concerned themselves mostly with flow-destroying
interruptions such as ringing telephones and inopportune visits from the
boss.  Less frequently considered but probably just as important to
programmers are the interruptions caused by our tools.  Languages that
require, for instance, a lengthy compilation before you can try your
latest code can be just as inimical to flow as a noisy phone or a nosy
boss.  So, one way to look at Lisp is as a language designed to keep you
in a state of flow.

   (4) This point is bound to be somewhat controversial, at least with
some folks.  Static versus dynamic typing is one of the classic
religious wars in programming.  If you're coming from C++ and Java (or
from statically typed functional languages such as Haskel and ML) and
refuse to consider living without static type checks, you might as well
put this book down now.  However, before you do, you might first want to
check out what self-described "statically typed bigot" Robert Martin
(author of Designing Object Oriented C++ Applications Using the Booch
Method [Prentice Hall, 1995]) and C++ and Java author Bruce Eckel
(author of Thinking in C++ [Prentice Hall, 1995] and Thinking in Java
[Prentice Hall, 1998]) have had to say about dynamic typing on their
weblogs (http://www.artima.com/weblogs/viewpost.jsp?thread=4639 and
http://www.mindview.net/WebLog/log-0025).  On the other hand, folks
coming from Smalltalk, Python, Perl, or Ruby should feel right at home
with this aspect of Common Lisp.

   (5) AspectL is an interesting project insofar as AspectJ, its
Java-based predecessor, was written by Gregor Kiczales, one of the
designers of Common Lisp's object and metaobject systems.  To many
Lispers, AspectJ seems like Kiczales's attempt to backport his ideas
from Common Lisp into Java.  However, Pascal Costanza, the author of
AspectL, thinks there are interesting ideas in AOP that could be useful
in Common Lisp.  Of course, the reason he's able to implement AspectL as
a library is because of the incredible flexibility of the Common Lisp
Meta Object Protocol Kiczales designed.  To implement AspectJ, Kiczales
had to write what was essentially a separate compiler that compiles a
new language into Java source code.  The AspectL project page is at
http://common-lisp.net/ project/aspectl/.

   (6) Or to look at it another, more technically accurate, way, Common
Lisp comes with a built-in facility for integrating compilers for
embedded languages.


File: pcl.info,  Node: 1-2,  Next: 1-3,  Prev: 1-1,  Up: Chapter 1

Where It Began
==============

Common Lisp is the modern descendant of the Lisp language first
conceived by John McCarthy in 1956.  Lisp circa 1956 was designed for
"symbolic data processing" (1) and derived its name from one of the
things it was quite good at: LISt Processing.  We've come a long way
since then: Common Lisp sports as fine an array of modern data types as
you can ask for: a condition system that, as you'll see in Chapter 19,
provides a whole level of flexibility missing from the exception systems
of languages such as Java, Python, and C++; powerful facilities for
doing object-oriented programming; and several language facilities that
just don't exist in other programming languages.  How is this possible?
What on Earth would provoke the evolution of such a well-equipped
language?

   Well, McCarthy was (and still is) an artificial intelligence (AI)
researcher, and many of the features he built into his initial version
of the language made it an excellent language for AI programming.
During the AI boom of the 1980s, Lisp remained a favorite tool for
programmers writing software to solve hard problems such as automated
theorem proving, planning and scheduling, and computer vision.  These
were problems that required a lot of hard-to-write software; to make a
dent in them, AI programmers needed a powerful language, and they grew
Lisp into the language they needed.  And the Cold War helped-as the
Pentagon poured money into the Defense Advanced Research Projects Agency
(DARPA), a lot of it went to folks working on problems such as
large-scale battlefield simulations, automated planning, and natural
language interfaces.  These folks also used Lisp and continued pushing
it to do what they needed.

   The same forces that drove Lisp's feature evolution also pushed the
envelope along other dimensions-big AI problems eat up a lot of
computing resources however you code them, and if you run Moore's law in
reverse for 20 years, you can imagine how scarce computing resources
were on circa-80s hardware.  The Lisp guys had to find all kinds of ways
to squeeze performance out of their implementations.  Modern Common Lisp
implementations are the heirs to those early efforts and often include
quite sophisticated, native machine code-generating compilers.  While
today, thanks to Moore's law, it's possible to get usable performance
from a purely interpreted language, that's no longer an issue for Common
Lisp.  As I'll show in Chapter 32, with proper (optional) declarations,
a good Lisp compiler can generate machine code quite similar to what
might be generated by a C compiler.

   The 1980s were also the era of the Lisp Machines, with several
companies, most famously Symbolics, producing computers that ran Lisp
natively from the chips up.  Thus, Lisp became a systems programming
language, used for writing the operating system, editors, compilers, and
pretty much everything else that ran on the Lisp Machines.

   In fact, by the early 1980s, with various AI labs and the Lisp
machine vendors all providing their own Lisp implementations, there was
such a proliferation of Lisp systems and dialects that the folks at
DARPA began to express concern about the Lisp community splintering.  To
address this concern, a grassroots group of Lisp hackers got together in
1981 and began the process of standardizing a new language called Common
Lisp that combined the best features from the existing Lisp dialects.
Their work was documented in the book Common Lisp the Language by Guy
Steele (Digital Press, 1984)-CLtL to the Lisp-cognoscenti.

   By 1986 the first Common Lisp implementations were available, and the
writing was on the wall for the dialects it was intended to replace.  In
1996, the American National Standards Institute (ANSI) released a
standard for Common Lisp that built on and extended the language
specified in CLtL, adding some major new features such as the CLOS and
the condition system.  And even that wasn't the last word: like CLtL
before it, the ANSI standard intentionally leaves room for implementers
to experiment with the best way to do things: a full Lisp implementation
provides a rich runtime environment with access to GUI widgets, multiple
threads of control, TCP/IP sockets, and more.  These days Common Lisp is
evolving much like other open-source languages-the folks who use it
write the libraries they need and often make them available to others.
In the last few years, in particular, there has been a spurt of activity
in open-source Lisp libraries.

   So, on one hand, Lisp is one of computer science's "classical"
languages, based on ideas that have stood the test of time.  (2) On the
other, it's a thoroughly modern, general-purpose language whose design
reflects a deeply pragmatic approach to solving real problems as
efficiently and robustly as possible.  The only downside of Lisp's
"classical" heritage is that lots of folks are still walking around with
ideas about Lisp based on some particular flavor of Lisp they were
exposed to at some particular time in the nearly half century since
McCarthy invented Lisp.  If someone tells you Lisp is only interpreted,
that it's slow, or that you have to use recursion for everything, ask
them what dialect of Lisp they're talking about and whether people were
wearing bell-bottoms when they learned it.  (3)

   ---------- Footnotes ----------

   (1) Lisp 1.5 Programmer's Manual (M.I.T. Press, 1962)

   (2) Ideas first introduced in Lisp include the if/then/else
construct, recursive function calls, dynamic memory allocation, garbage
collection, first-class functions, lexical closures, interactive
programming, incremental compilation, and dynamic typing.

   (3) One of the most commonly repeated myths about Lisp is that it's
"dead."  While it's true that Common Lisp isn't as widely used as, say,
Visual Basic or Java, it seems strange to describe a language that
continues to be used for new development and that continues to attract
new users as "dead."  Some recent Lisp success stories include Paul
Graham's Viaweb, which became Yahoo Store when Yahoo bought his company;
ITA Software's airfare pricing and shopping system, QPX, used by the
online ticket seller Orbitz and others; Naughty Dog's game for the
PlayStation 2, Jak and Daxter, which is largely written in a
domain-specific Lisp dialect Naughty Dog invented called GOAL, whose
compiler is itself written in Common Lisp; and the Roomba, the
autonomous robotic vacuum cleaner, whose software is written in L, a
downwardly compatible subset of Common Lisp.  Perhaps even more telling
is the growth of the Common-Lisp.net Web site, which hosts open-source
Common Lisp projects, and the number of local Lisp user groups that have
sprung up in the past couple of years.


File: pcl.info,  Node: 1-3,  Prev: 1-2,  Up: Chapter 1

Who This Book Is For
====================

This book is for you if you're curious about Common Lisp, regardless of
whether you're already convinced you want to use it or if you just want
to know what all the fuss is about.

   If you've learned some Lisp already but have had trouble making the
leap from academic exercises to real programs, this book should get you
on your way.  On the other hand, you don't have to be already convinced
that you want to use Lisp to get something out of this book.

   If you're a hard-nosed pragmatist who wants to know what advantages
Common Lisp has over languages such as Perl, Python, Java, C, or C#,
this book should give you some ideas.  Or maybe you don't even care
about using Lisp-maybe you're already sure Lisp isn't really any better
than other languages you know but are annoyed by some Lisper telling you
that's because you just don't "get it."  If so, this book will give you
a straight-to-the-point introduction to Common Lisp.  If, after reading
this book, you still think Common Lisp is no better than your current
favorite languages, you'll be in an excellent position to explain
exactly why.

   I cover not only the syntax and semantics of the language but also
how you can use it to write software that does useful stuff.  In the
first part of the book, I'll cover the language itself, mixing in a few
"practical" chapters, where I'll show you how to write real code.  Then,
after I've covered most of the language, including several parts that
other books leave for you to figure out on your own, the remainder of
the book consists of nine more practical chapters where I'll help you
write several medium-sized programs that actually do things you might
find useful: filter spam, parse binary files, catalog MP3s, stream MP3s
over a network, and provide a Web interface for the MP3 catalog and
server.

   After you finish this book, you'll be familiar with all the most
important features of the language and how they fit together, you'll
have used Common Lisp to write several nontrivial programs, and you'll
be well prepared to continue exploring the language on your own.  While
everyone's road to Lisp is different, I hope this book will help smooth
the way for you.  So, let's begin.

     (define (cube x) (* x x x))


File: pcl.info,  Node: Chapter 2,  Prev: Chapter 1,  Up: Top

2. Lather, Rinse, Repeat: A Tour of the REPL
============================================

In this chapter you'll set up your programming environment and write
your first Common Lisp programs.  We'll use the easy-to-install Lisp in
a Box developed by Matthew Danish and Mikel Evins, which packages a
Common Lisp implementation with Emacs, a powerful Lisp-aware text
editor, and SLIME,1 a Common Lisp development environment built on top
of Emacs.

   This combo provides a state-of-the-art Common Lisp development
environment that supports the incremental, interactive development style
that characterizes Lisp programming.  The SLIME environment has the
added advantage of providing a fairly uniform user interface regardless
of the operating system and Common Lisp implementation you choose.  I'll
use the Lisp in a Box environment in order to have a specific
development environment to talk about; folks who want to explore other
development environments such as the graphical integrated development
environments (IDEs) provided by some of the commercial Lisp vendors or
environments based on other editors shouldn't have too much trouble
translating the basics.2

* Menu:

* 2-1::              Choosing a Lisp Implementation
* 2-2::              Getting Up and Running with Lisp in a Box
* 2-3::              Free Your Mind: Interactive Programming
* 2-4::              Experimenting in the REPL
* 2-5::              "Hello, World," Lisp Style
* 2-6::              Saving Your Work


File: pcl.info,  Node: 2-1,  Next: 2-2,  Prev: Chapter 2,  Up: Chapter 2

Choosing a Lisp Implementation
==============================

The first thing you have to do is to choose a Lisp implementation.  This
may seem like a strange thing to have to do for folks used to languages
such as Perl, Python, Visual Basic (VB), C#, and Java.  The difference
between Common Lisp and these languages is that Common Lisp is defined
by its standard-there is neither a single implementation controlled by a
benevolent dictator, as with Perl and Python, nor a canonical
implementation controlled by a single company, as with VB, C#, and Java.
Anyone who wants to read the standard and implement the language is free
to do so.  Furthermore, changes to the standard have to be made in
accordance with a process controlled by the standards body American
National Standards Institute (ANSI). That process is designed to keep
any one entity, such as a single vendor, from being able to arbitrarily
change the standard.3 Thus, the Common Lisp standard is a contract
between any Common Lisp vendor and Common Lisp programmers.  The
contract tells you that if you write a program that uses the features of
the language the way they're described in the standard, you can count on
your program behaving the same in any conforming implementation.

   On the other hand, the standard may not cover everything you may want
to do in your programs-some things were intentionally left unspecified
in order to allow continuing experimentation by implementers in areas
where there wasn't consensus about the best way for the language to
support certain features.  So every implementation offers some features
above and beyond what's specified in the standard.  Depending on what
kind of programming you're going to be doing, it may make sense to just
pick one implementation that has the extra features you need and use
that.  On the other hand, if we're delivering Lisp source to be used by
others, such as libraries, you'll want-as far as possible-to write
portable Common Lisp.  For writing code that should be mostly portable
but that needs facilities not defined by the standard, Common Lisp
provides a flexible way to write code "conditionalized" on the features
available in a particular implementation.  You'll see an example of this
kind of code in Chapter 15 when we develop a simple library that
smoothes over some differences between how different Lisp
implementations deal with filenames.

   For the moment, however, the most important characteristic of an
implementation is whether it runs on our favorite operating system.  The
folks at Franz, makers of Allegro Common Lisp, are making available a
trial version of their product for use with this book that runs on
Linux, Windows, and OS X. Folks looking for an open-source
implementation have several options.  SBCL4 is a high-quality
open-source implementation that compiles to native code and runs on a
wide variety of Unixes, including Linux and OS X. SBCL is derived from
CMUCL,5 which is a Common Lisp developed at Carnegie Mellon University,
and, like CMUCL, is largely in the public domain, except a few sections
licensed under Berkeley Software Distribution (BSD) style licenses.
CMUCL itself is another fine choice, though SBCL tends to be easier to
install and now supports 21-bit Unicode.6 For OS X users, OpenMCL is an
excellent choice-it compiles to machine code, supports threads, and has
quite good integration with OS X's Carbon and Cocoa toolkits.  Other
open-source and commercial implementations are available.  See Chapter
32 for resources from which you can get more information.

   All the Lisp code in this book should work in any conforming Common
Lisp implementation unless otherwise noted, and SLIME will smooth out
some of the differences between implementations by providing us with a
common interface for interacting with Lisp.  The output shown in this
book is from Allegro running on GNU/Linux; in some cases, other Lisp's
may generate slightly different error messages or debugger output.


File: pcl.info,  Node: 2-2,  Next: 2-3,  Prev: 2-1,  Up: Chapter 2

Getting Up and Running with Lisp in a Box
=========================================

Since the Lisp in a Box packaging is designed to get new Lispers up and
running in a first-rate Lisp development environment with minimum
hassle, all you need to do to get it running is to grab the appropriate
package for your operating system and the preferred Lisp from the Lisp
in a Box Web site listed in Chapter 32 and then follow the installation
instructions.

   Since Lisp in a Box uses Emacs as its editor, you'll need to know at
least a bit about how to use it.  Perhaps the best way to get started
with Emacs is to work through its built-in tutorial.  To start the
tutorial, select the first item of the Help menu, Emacs tutorial.  Or
press the Ctrl key, type h, release the Ctrl key, and then press t.
Most Emacs commands are accessible via such key combinations; because
key combinations are so common, Emacs users have a notation for
describing key combinations that avoids having to constantly write out
combinations such as "Press the Ctrl key, type h, release the Ctrl key,
and then press t."  Keys to be pressed together-a so-called key
chord-are written together and separated by a hyphen.  Keys, or key
chords, to be pressed in sequence are separated by spaces.  In a key
chord, C represents the Ctrl key and M represents the Meta key (also
known as Alt).  Thus, we could write the key combination we just
described that starts the tutorial like so: C-h t.

   The tutorial describes other useful commands and the key combinations
that invoke them.  Emacs also comes with extensive online documentation
using its own built-in hypertext documentation browser, Info.  To read
the manual, type C-h i.  The Info system comes with its own tutorial,
accessible simply by pressing h while reading the manual.  Finally,
Emacs provides quite a few ways to get help, all bound to key combos
starting with C-h.  Typing C-h ?  brings up a complete list.  Two of the
most useful, besides the tutorial, are C-h k, which lets us type any key
combo and tells us what command it invokes, and C-h w, which lets us
enter the name of a command and tells us what key combination invokes
it.

   The other crucial bit of Emacs terminology, for folks who refuse to
work through the tutorial, is the notion of a buffer.  While working in
Emacs, each file you edit will be represented by a different buffer,
only one of which is "current" at any given time.  The current buffer
receives all input-whatever you type and any commands you invoke.
Buffers are also used to represent interactions with programs such as
Common Lisp.  Thus, one common action you'll take is to "switch
buffers," which means to make a different buffer the current buffer so
you can edit a particular file or interact with a particular program.
The command switch-to-buffer, bound to the key combination C-x b,
prompts for the name of a buffer in the area at the bottom of the Emacs
frame.  When entering a buffer name, hitting Tab will complete the name
based on the characters typed so far or will show a list of possible
completions.  The prompt also suggests a default buffer, which you can
accept just by hitting Return.  You can also switch buffers by selecting
a buffer from the Buffers menu.

   In certain contexts, other key combinations may be available for
switching to certain buffers.  For instance, when editing Lisp source
files, the key combo C-c C-z switches to the buffer where you interact
with Lisp.


File: pcl.info,  Node: 2-3,  Next: 2-4,  Prev: 2-2,  Up: Chapter 2

Free Your Mind: Interactive Programming
=======================================

When you start Lisp in a Box, you should see a buffer containing a
prompt that looks like this:

   CL-USER> This is the Lisp prompt.  Like a Unix or DOS shell prompt,
the Lisp prompt is a place where you can type expressions that will
cause things to happen.  However, instead of reading and interpreting a
line of shell commands, Lisp reads Lisp expressions, evaluates them
according to the rules of Lisp, and prints the result.  Then it does it
again with the next expression you type.  That endless cycle of reading,
evaluating, and printing is why it's called the read-eval-print loop, or
REPL for short.  It's also referred to as the top-level, the top-level
listener, or the Lisp listener.

   From within the environment provided by the REPL, you can define and
redefine program elements such as variables, functions, classes, and
methods; evaluate any Lisp expression; load files containing Lisp source
code or compiled code; compile whole files or individual functions;
enter the debugger; step through code; and inspect the state of
individual Lisp objects.

   All those facilities are built into the language, accessible via
functions defined in the language standard.  If you had to, you could
build a pretty reasonable programming environment out of just the REPL
and any text editor that knows how to properly indent Lisp code.  But
for the true Lisp programming experience, you need an environment, such
as SLIME, that lets you interact with Lisp both via the REPL and while
editing source files.  For instance, you don't want to have to cut and
paste a function definition from a source file to the REPL or have to
load a whole file just because you changed one function; your Lisp
environment should let us evaluate or compile both individual
expressions and whole files directly from your editor.


File: pcl.info,  Node: 2-4,  Next: 2-5,  Prev: 2-3,  Up: Chapter 2

Experimenting in the REPL
=========================

To try the REPL, you need a Lisp expression that can be read, evaluated,
and printed.  One of the simplest kinds of Lisp expressions is a number.
At the Lisp prompt, you can type 10 followed by Return and should see
something like this:

   CL-USER> 10 10 The first 10 is the one you typed.  The Lisp reader,
the R in REPL, reads the text "10" and creates a Lisp object
representing the number 10.  This object is a self-evaluating object,
which means that when given to the evaluator, the E in REPL, it
evaluates to itself.  This value is then given to the printer, which
prints the 10 on the line by itself.  While that may seem like a lot of
work just to get back to where you started, things get a bit more
interesting when you give Lisp something meatier to chew on.  For
instance, you can type (+ 2 3) at the Lisp prompt.

   CL-USER> (+ 2 3) 5 Anything in parentheses is a list, in this case a
list of three elements, the symbol +, and the numbers 2 and 3.  Lisp, in
general, evaluates lists by treating the first element as the name of a
function and the rest of the elements as expressions to be evaluated to
yield the arguments to the function.  In this case, the symbol + names a
function that performs addition.  2 and 3 evaluate to themselves and are
then passed to the addition function, which returns 5.  The value 5 is
passed to the printer, which prints it.  Lisp can evaluate a list
expression in other ways, but we needn't get into them right away.
First we have to write.  .  .


File: pcl.info,  Node: 2-5,  Next: 2-6,  Prev: 2-4,  Up: Chapter 2

"Hello, World," Lisp Style
==========================

No programming book is complete without a "hello, world"7 program.  As
it turns out, it's trivially easy to get the REPL to print "hello,
world."

   CL-USER> "hello, world" "hello, world" This works because strings,
like numbers, have a literal syntax that's understood by the Lisp reader
and are self-evaluating objects: Lisp reads the double-quoted string and
instantiates a string object in memory that, when evaluated, evaluates
to itself and is then printed in the same literal syntax.  The quotation
marks aren't part of the string object in memory-they're just the syntax
that tells the reader to read a string.  The printer puts them back on
when it prints the string because it tries to print objects in the same
syntax the reader understands.

   However, this may not really qualify as a "hello, world" program.
It's more like the "hello, world" value.

   You can take a step toward a real program by writing some code that
as a side effect prints the string "hello, world" to standard output.
Common Lisp provides a couple ways to emit output, but the most flexible
is the FORMAT function.  FORMAT takes a variable number of arguments,
but the only two required arguments are the place to send the output and
a string.  You'll see in the next chapter how the string can contain
embedded directives that allow you to interpolate subsequent arguments
into the string, à la printf or Python's string-%.  As long as the
string doesn't contain an ~, it will be emitted as-is.  If you pass t as
its first argument, it sends its output to standard output.  So a FORMAT
expression that will print "hello, world" looks like this:8

   CL-USER> (format t "hello, world") hello, world NIL One thing to note
about the result of the FORMAT expression is the NIL on the line after
the "hello, world" output.  That NIL is the result of evaluating the
FORMAT expression, printed by the REPL. (NIL is Lisp's version of false
and/or null.  More on that in Chapter 4.)  Unlike the other expressions
we've seen so far, a FORMAT expression is more interesting for its side
effect-printing to standard output in this case-than for its return
value.  But every expression in Lisp evaluates to some result.9

   However, it's still arguable whether you've yet written a true
"program."  But you're getting there.  And you're seeing the bottom-up
style of programming supported by the REPL: you can experiment with
different approaches and build a solution from parts you've already
tested.  Now that you have a simple expression that does what you want,
you just need to package it in a function.  Functions are one of the
basic program building blocks in Lisp and can be defined with a DEFUN
expression such as this:

   CL-USER> (defun hello-world () (format t "hello, world")) HELLO-WORLD
The hello-world after the DEFUN is the name of the function.  In Chapter
4 we'll look at exactly what characters can be used in a name, but for
now suffice it to say that lots of characters, such as -, that are
illegal in names in other languages are legal in Common Lisp.  It's
standard Lisp style-not to mention more in line with normal English
typography-to form compound names with hyphens, such as hello-world,
rather than with underscores, as in hello_world, or with inner caps such
as helloWorld.  The ()s after the name delimit the parameter list, which
is empty in this case because the function takes no arguments.  The rest
is the body of the function.

   At one level, this expression, like all the others you've seen, is
just another expression to be read, evaluated, and printed by the REPL.
The return value in this case is the name of the function you just
defined.10 But like the FORMAT expression, this expression is more
interesting for the side effects it has than for its return value.
Unlike the FORMAT expression, however, the side effects are invisible:
when this expression is evaluated, a new function that takes no
arguments and with the body (format t "hello, world") is created and
given the name HELLO-WORLD.

   Once you've defined the function, you can call it like this:

   CL-USER> (hello-world) hello, world NIL You can see that the output
is just the same as when you evaluated the FORMAT expression directly,
including the NIL value printed by the REPL. Functions in Common Lisp
automatically return the value of the last expression evaluated.


File: pcl.info,  Node: 2-6,  Next: Chapter 3,  Prev: 2-5,  Up: Chapter 2

Saving Your Work
================

You could argue that this is a complete "hello, world" program of sorts.
However, it still has a problem.  If you exit Lisp and restart, the
function definition will be gone.  Having written such a fine function,
you'll want to save your work.

   Easy enough.  You just need to create a file in which to save the
definition.  In Emacs you can create a new file by typing C-x C-f and
then, when Emacs prompts you, entering the name of the file you want to
create.  It doesn't matter particularly where you put the file.  It's
customary to name Common Lisp source files with a .lisp extension,
though some folks use .cl instead.

   Once you've created the file, you can type the definition you
previously entered at the REPL. Some things to note are that after you
type the opening parenthesis and the word DEFUN, at the bottom of the
Emacs window, SLIME will tell you the arguments expected.  The exact
form will depend somewhat on what Common Lisp implementation you're
using, but it'll probably look something like this:

   (defun name varlist &rest body) The message will disappear as you
start to type each new element but will reappear each time you enter a
space.  When you're entering the definition in the file, you might
choose to break the definition across two lines after the parameter
list.  If you hit Return and then Tab, SLIME will automatically indent
the second line appropriately, like this:11

   (defun hello-world () (format t "hello, world")) SLIME will also help
match up the parentheses-as you type a closing parenthesis, it will
flash the corresponding opening parenthesis.  Or you can just type C-c
C-q to invoke the command slime-close-parens-at-point, which will insert
as many closing parentheses as necessary to match all the currently open
parentheses.

   Now you can get this definition into your Lisp environment in several
ways.  The easiest is to type C-c C-c with the cursor anywhere in or
immediately after the DEFUN form, which runs the command
slime-compile-defun, which in turn sends the definition to Lisp to be
evaluated and compiled.  To make sure this is working, you can make some
change to hello-world, recompile it, and then go back to the REPL, using
C-c C-z or C-x b, and call it again.  For instance, you could make it a
bit more grammatical.

   (defun hello-world () (format t "Hello, world!"))  Next, recompile
with C-c C-c and then type C-c C-z to switch to the REPL to try the new
version.

   CL-USER> (hello-world) Hello, world!  NIL You'll also probably want
to save the file you've been working on; in the hello.lisp buffer, type
C-x C-s to invoke the Emacs command save-buffer.

   Now to try reloading this function from the source file, you'll need
to quit Lisp and restart.  To quit you can use a SLIME shortcut: at the
REPL, type a comma.  At the bottom of the Emacs window, you will be
prompted for a command.  Type quit (or sayoonara), and then hit Enter.
This will quit Lisp and close all the buffers created by SLIME such as
the REPL buffer.12 Now restart SLIME by typing M-x slime.

   Just for grins, you can try to invoke hello-world.

   CL-USER> (hello-world) At that point SLIME will pop up a new buffer
that starts with something that looks like this:

   attempt to call 'HELLO-WORLD' which is an undefined function.
[Condition of type UNDEFINED-FUNCTION]

   Restarts: 0: [TRY-AGAIN] Try calling HELLO-WORLD again.  1:
[RETURN-VALUE] Return a value instead of calling HELLO-WORLD. 2:
[USE-VALUE] Try calling a function other than HELLO-WORLD. 3:
[STORE-VALUE] Setf the symbol-function of HELLO-WORLD and call it again.
4: [ABORT] Abort handling SLIME request.  5: [ABORT] Abort entirely from
this process.

   Backtrace: 0: (SWANK::DEBUG-IN-EMACS #<UNDEFINED-FUNCTION
 #x716b082a>) 1: ((FLET SWANK:SWANK-DEBUGGER-HOOK SWANK::DEBUG-IT)) 2:
(SWANK:SWANK-DEBUGGER-HOOK #<UNDEFINED-FUNCTION  #x716b082a> #<Function
SWANK-DEBUGGER-HOOK>) 3: (ERROR #<UNDEFINED-FUNCTION  #x716b082a>) 4:
(EVAL (HELLO-WORLD)) 5: (SWANK::EVAL-REGION "(hello-world) " T) Blammo!
What happened?  Well, you tried to invoke a function that doesn't exist.
But despite the burst of output, Lisp is actually handling this
situation gracefully.  Unlike Java or Python, Common Lisp doesn't just
bail-throwing an exception and unwinding the stack.  And it definitely
doesn't dump core just because you tried to invoke a missing function.
Instead Lisp drops you into the debugger.

   While you're in the debugger you still have full access to Lisp, so
you can evaluate expressions to examine the state of our program and
maybe even fix things.  For now don't worry about that; just type q to
exit the debugger and get back to the REPL. The debugger buffer will go
away, and the REPL will show this:

   CL-USER> (hello-world) ; Evaluation aborted CL-USER> There's
obviously more that can be done from within the debugger than just
abort-we'll see, for instance, in Chapter 19 how the debugger integrates
with the error handling system.  For now, however, the important thing
to know is that you can always get out of it, and back to the REPL, by
typing q.

   Back at the REPL you can try again.  Things blew up because Lisp
didn't know the definition of hello-world.  So you need to let Lisp know
about the definition we saved in the file hello.lisp.  You have several
ways you could do this.  You could switch back to the buffer containing
the file (type C-x b and then enter hello.lisp when prompted) and
recompile the definition as you did before with C-c C-c.  Or you can
load the whole file, which would be a more convenient approach if the
file contained a bunch of definitions, using the LOAD function at the
REPL like this:

   CL-USER> (load "hello.lisp") ; Loading
/home/peter/my-lisp-programs/hello.lisp T The T means everything loaded
correctly.13 Loading a file with LOAD is essentially equivalent to
typing each of the expressions in the file at the REPL in the order they
appear in the file, so after the call to LOAD, hello-world should be
defined:

   CL-USER> (hello-world) Hello, world!  NIL Another way to load a
file's worth of definitions is to compile the file first with
COMPILE-FILE and then LOAD the resulting compiled file, called a FASL
file, which is short for fast-load file.  COMPILE-FILE returns the name
of the FASL file, so we can compile and load from the REPL like this:

   CL-USER> (load (compile-file "hello.lisp")) ;;; Compiling file
hello.lisp ;;; Writing fasl file hello.fasl ;;; Fasl write complete v;
Fast loading /home/peter/my-lisp-programs/hello.fasl T SLIME also
provides support for loading and compiling files without using the REPL.
When you're in a source code buffer, you can use C-c C-l to load the
file with slime-load-file.  Emacs will prompt for the name of a file to
load with the name of the current file already filled in; you can just
hit Enter.  Or you can type C-c C-k to compile and load the file
represented by the current buffer.  In some Common Lisp implementations,
compiling code this way will make it quite a bit faster; in others, it
won't, typically because they always compile everything.

   This should be enough to give you a flavor of how Lisp programming
works.  Of course I haven't covered all the tricks and techniques yet,
but you've seen the essential elements-interacting with the REPL trying
things out, loading and testing new code, tweaking and debugging.
Serious Lisp hackers often keep a Lisp image running for days on end,
adding, redefining, and testing bits of their program incrementally.

   Also, even when the Lisp app is deployed, there's often still a way
to get to a REPL. You'll see in Chapter 26 how you can use the REPL and
SLIME to interact with the Lisp that's running a Web server at the same
time as it's serving up Web pages.  It's even possible to use SLIME to
connect to a Lisp running on a different machine, allowing you-for
instance-to debug a remote server just like a local one.

   An even more impressive instance of remote debugging occurred on
NASA's 1998 Deep Space 1 mission.  A half year after the space craft
launched, a bit of Lisp code was going to control the spacecraft for two
days while conducting a sequence of experiments.  Unfortunately, a
subtle race condition in the code had escaped detection during ground
testing and was already in space.  When the bug manifested in the
wild-100 million miles away from Earth-the team was able to diagnose and
fix the running code, allowing the experiments to complete.14 One of the
programmers described it as follows:

   Debugging a program running on a $100M piece of hardware that is 100
million miles away is an interesting experience.  Having a
read-eval-print loop running on the spacecraft proved invaluable in
finding and fixing the problem.  You're not quite ready to send any Lisp
code into deep space, but in the next chapter you'll take a crack at
writing a program a bit more interesting than "hello, world."


File: pcl.info,  Node: Chapter 3,  Next: Chapter 4,  Prev: Chapter 2,  Up: Top

3. Practical: A Simple Database
===============================

content 3-intro

* Menu:

* 3-1::              CDs and Records
* 3-2::              Filing CDs
* 3-3::              Looking at the Database Contents
* 3-4::              Improving the User Interaction
* 3-5::              Saving and Loading the Database
* 3-6::              Querying the Database
* 3-7::              Updating Existing Records-Another Use for WHERE
* 3-8::              Removing Duplication and Winning Big
* 3-9::              Wrapping Up


File: pcl.info,  Node: 3-1,  Next: 3-2,  Prev: Chapter 3,  Up: Chapter 3

CDs and Records
===============

content 3-1


File: pcl.info,  Node: 3-2,  Next: 3-3,  Prev: 3-1,  Up: Chapter 3

Filing CDs
==========

content 3-2


File: pcl.info,  Node: 3-3,  Next: 3-4,  Prev: 3-2,  Up: Chapter 3

Looking at the Database Contents
================================

content 3-3


File: pcl.info,  Node: 3-4,  Next: 3-5,  Prev: 3-3,  Up: Chapter 3

Improving the User Interaction
==============================

content 3-4


File: pcl.info,  Node: 3-5,  Next: 3-6,  Prev: 3-4,  Up: Chapter 3

Saving and Loading the Database
===============================

content 3-5


File: pcl.info,  Node: 3-6,  Next: 3-7,  Prev: 3-5,  Up: Chapter 3

Querying the Database
=====================

content 3-6


File: pcl.info,  Node: 3-7,  Next: 3-8,  Prev: 3-6,  Up: Chapter 3

Updating Existing Records-Another Use for WHERE
===============================================

content 3-7


File: pcl.info,  Node: 3-8,  Next: 3-9,  Prev: 3-7,  Up: Chapter 3

Removing Duplication and Winning Big
====================================

content 3-8


File: pcl.info,  Node: 3-9,  Next: Chapter 4,  Prev: 3-7,  Up: Chapter 3

Wrapping Up
===========

content 3-9


File: pcl.info,  Node: Chapter 4,  Next: Chapter 5,  Prev: Chapter 3,  Up: Top

4. Syntax and Semantics
=======================

content 4-intro

* Menu:

* 4-1::              What's with All the Parentheses?
* 4-2::              Breaking Open the Black Box
* 4-3::              S-expressions
* 4-4::              S-expressions As Lisp Forms
* 4-5::              Function Calls
* 4-6::              Special Operators
* 4-7::              Macros
* 4-8::              Truth, Falsehood, and Equality
* 4-9::             Formatting Lisp Code


File: pcl.info,  Node: 4-1,  Next: 4-2,  Prev: Chapter 4,  Up: Chapter 4

What's with All the Parentheses?
================================

content 4-1


File: pcl.info,  Node: 4-2,  Next: 4-3,  Prev: 4-1,  Up: Chapter 4

Breaking Open the Black Box
===========================

content 4-2


File: pcl.info,  Node: 4-3,  Next: 4-4,  Prev: 4-2,  Up: Chapter 4

S-expressions
=============

content 4-3


File: pcl.info,  Node: 4-4,  Next: 4-5,  Prev: 4-3,  Up: Chapter 4

S-expressions As Lisp Forms
===========================

content 4-4


File: pcl.info,  Node: 4-5,  Next: 4-6,  Prev: 4-4,  Up: Chapter 4

Function Calls
==============

content 4-5


File: pcl.info,  Node: 4-6,  Next: 4-7,  Prev: 4-5,  Up: Chapter 4

Special Operators
=================

content 4-6


File: pcl.info,  Node: 4-7,  Next: 4-8,  Prev: 4-6,  Up: Chapter 4

Macros
======

content 4-7


File: pcl.info,  Node: 4-8,  Next: 4-9,  Prev: 4-7,  Up: Chapter 4

Truth, Falsehood, and Equality
==============================

content 4-8


File: pcl.info,  Node: 4-9,  Next: Chapter 5,  Prev: 4-7,  Up: Chapter 4

Formatting Lisp Code
====================

content 4-9


File: pcl.info,  Node: Chapter 5,  Next: Chapter 6,  Prev: Chapter 4,  Up: Top

5. Functions
============

content 5-intro

* Menu:

* 5-1::              Defining New Functions
* 5-2::              Function Parameter Lists
* 5-3::              Optional Parameters
* 5-4::              Rest Parameters
* 5-5::              Keyword Parameters
* 5-6::              Mixing Different Parameter Types
* 5-7::              Function Return Values
* 5-8::              Functions As Data, a.k.a. Higher-Order Functions
* 5-9::              Anonymous Functions


File: pcl.info,  Node: 5-1,  Next: 5-2,  Prev: Chapter 5,  Up: Chapter 5

Defining New Functions
======================

content 5-1


File: pcl.info,  Node: 5-2,  Next: 5-3,  Prev: 5-1,  Up: Chapter 5

Function Parameter Lists
========================

content 5-2


File: pcl.info,  Node: 5-3,  Next: 5-4,  Prev: 5-2,  Up: Chapter 5

Optional Parameters
===================

content 5-3


File: pcl.info,  Node: 5-4,  Next: 5-5,  Prev: 5-3,  Up: Chapter 5

Rest Parameters
===============

content 5-4


File: pcl.info,  Node: 5-5,  Next: 5-6,  Prev: 5-4,  Up: Chapter 5

Keyword Parameters
==================

content 5-5


File: pcl.info,  Node: 5-6,  Next: 5-7,  Prev: 5-5,  Up: Chapter 5

Mixing Different Parameter Types
================================

content 5-6


File: pcl.info,  Node: 5-7,  Next: 5-8,  Prev: 5-6,  Up: Chapter 5

Function Return Values
======================

content 5-7


File: pcl.info,  Node: 5-8,  Next: 5-9,  Prev: 5-7,  Up: Chapter 5

Functions As Data, a.k.a. Higher-Order Functions
================================================

content 5-8


File: pcl.info,  Node: 5-9,  Next: Chapter 6,  Prev: 5-7,  Up: Chapter 5

Anonymous Functions
===================

content 5-9


File: pcl.info,  Node: Chapter 6,  Next: Chapter 7,  Prev: Chapter 5,  Up: Top

6. Variables
============

content 6-intro

* Menu:

* 6-1::              Variable Basics
* 6-2::              Lexical Variables and Closures
* 6-3::              Dynamic, a.k.a. Special, Variables
* 6-4::              Constants
* 6-5::              Assignment
* 6-6::              Generalized Assignment


File: pcl.info,  Node: 6-1,  Next: 6-2,  Prev: Chapter 6,  Up: Chapter 6

Variable Basics
===============

content 6-1


File: pcl.info,  Node: 6-2,  Next: 6-3,  Prev: 6-1,  Up: Chapter 6

Lexical Variables and Closures
==============================

content 6-2


File: pcl.info,  Node: 6-3,  Next: 6-4,  Prev: 6-2,  Up: Chapter 6

Dynamic, a.k.a. Special, Variables
==================================

content 6-3


File: pcl.info,  Node: 6-4,  Next: 6-5,  Prev: 6-3,  Up: Chapter 6

Constants
=========

content 6-4


File: pcl.info,  Node: 6-5,  Next: 6-6,  Prev: 6-4,  Up: Chapter 6

Assignment
==========

content 6-5


File: pcl.info,  Node: 6-6,  Next: Chapter 7,  Prev: 6-5,  Up: Chapter 6

Generalized Assignment
======================

content 6-6


File: pcl.info,  Node: Chapter 7,  Next: Chapter 8,  Prev: Chapter 6,  Up: Top

7. Macros: Standard Control Constructs
======================================

content 7-intro

* Menu:

* 7-1::              WHEN and UNLESS
* 7-2::              COND
* 7-3::              AND, OR, and NOT
* 7-4::              Looping
* 7-5::              DOLIST and DOTIMES
* 7-6::              DO
* 7-7::              The Mighty LOOP


File: pcl.info,  Node: 7-1,  Next: 7-2,  Prev: Chapter 7,  Up: Chapter 7

WHEN and UNLESS
===============

content 7-1


File: pcl.info,  Node: 7-2,  Next: 7-3,  Prev: 7-1,  Up: Chapter 7

COND
====

content 7-2


File: pcl.info,  Node: 7-3,  Next: 7-4,  Prev: 7-2,  Up: Chapter 7

AND, OR, and NOT
================

content 7-3


File: pcl.info,  Node: 7-4,  Next: 7-5,  Prev: 7-3,  Up: Chapter 7

Looping
=======

content 7-4


File: pcl.info,  Node: 7-5,  Next: 7-6,  Prev: 7-4,  Up: Chapter 7

DOLIST and DOTIMES
==================

content 7-5


File: pcl.info,  Node: 7-6,  Next: 7-7,  Prev: 7-5,  Up: Chapter 7

DO
==

content 7-6


File: pcl.info,  Node: 7-7,  Next: Chapter 8,  Prev: 7-6,  Up: Chapter 7

The Mighty LOOP
===============

content 7-7


File: pcl.info,  Node: Chapter 8,  Next: Chapter 9,  Prev: Chapter 7,  Up: Top

8. Macros: Defining Your Own
============================

content 8-intro

* Menu:

* 8-1::                  The Story of Mac: A Just-So Story
* 8-2::                  Macro Expansion Time vs. Runtime
* 8-3::                  DEF MACRO
* 8-4::                  A Sample Macro: do-primes
* 8-5::                  Macro Parameters
* 8-6::                  Generating the Expansion
* 8-7::                  Plugging the Leaks
* 8-8::                  Macro-Writing Macros
* 8-9::                  Beyond Simple Macros


File: pcl.info,  Node: 8-1,  Next: 8-2,  Prev: Chapter 8,  Up: Chapter 8

The Story of Mac: A Just-So Story
=================================

content 8-1


File: pcl.info,  Node: 8-2,  Next: 8-3,  Prev: 8-1,  Up: Chapter 8

Macro Expansion Time vs. Runtime
================================

content 8-2


File: pcl.info,  Node: 8-3,  Next: 8-4,  Prev: 8-2,  Up: Chapter 8

DEF MACRO
=========

content 8-3


File: pcl.info,  Node: 8-4,  Next: 8-5,  Prev: 8-3,  Up: Chapter 8

A Sample Macro: do-primes
=========================

content 8-4


File: pcl.info,  Node: 8-5,  Next: 8-6,  Prev: 8-4,  Up: Chapter 8

Macro Parameters
================

content 8-5


File: pcl.info,  Node: 8-6,  Next: 8-7,  Prev: 8-5,  Up: Chapter 8

Generating the Expansion
========================

content 8-6


File: pcl.info,  Node: 8-7,  Next: 8-8,  Prev: 8-6,  Up: Chapter 8

Plugging the Leaks
==================

content 8-7


File: pcl.info,  Node: 8-8,  Next: 8-9,  Prev: 8-7,  Up: Chapter 8

Macro-Writing Macros
====================

content 8-8


File: pcl.info,  Node: 8-9,  Next: Chapter 9,  Prev: 8-8,  Up: Chapter 8

Beyond Simple Macros
====================

content 8-9


File: pcl.info,  Node: Chapter 9,  Next: Chapter 10,  Prev: Chapter 8,  Up: Top

9. Practical: Building a Unit Test Framework
============================================

content 9-intro

* Menu:

* 9-1::                  Two First Tries
* 9-2::                  Refactoring
* 9-3::                  Fixing the Return Value
* 9-4::                  Better Result Reporting
* 9-5::                  An Abstraction Emerges
* 9-6::                  A Hierarchy of Tests
* 9-7::                  Wrapping Up


File: pcl.info,  Node: 9-1,  Next: 9-2,  Prev: Chapter 9,  Up: Chapter 9

Two First Tries
===============

content 9-1


File: pcl.info,  Node: 9-2,  Next: 9-3,  Prev: 9-1,  Up: Chapter 9

Refactoring
===========

content 9-2


File: pcl.info,  Node: 9-3,  Next: 9-4,  Prev: 9-2,  Up: Chapter 9

Fixing the Return Value
=======================

content 9-3


File: pcl.info,  Node: 9-4,  Next: 9-5,  Prev: 9-3,  Up: Chapter 9

Better Result Reporting
=======================

content 9-4


File: pcl.info,  Node: 9-5,  Next: 9-6,  Prev: 9-4,  Up: Chapter 9

An Abstraction Emerges
======================

content 9-5


File: pcl.info,  Node: 9-6,  Next: 9-7,  Prev: 9-5,  Up: Chapter 9

A Hierarchy of Tests
====================

content 9-6


File: pcl.info,  Node: 9-7,  Next: Chapter 10,  Prev: 9-6,  Up: Chapter 9

Wrapping Up
===========

content 9-7


File: pcl.info,  Node: Chapter 10,  Next: Chapter 11,  Prev: Chapter 9,  Up: Top

10. Numbers, Characters, and Strings
====================================

content 10-intro

* Menu:

* 10-1::                 Numbers
* 10-2::                 Numeric Literals
* 10-3::                 Basic Math
* 10-4::                 Numeric Comparisons
* 10-5::                 Higher Math
* 10-6::                 Characters
* 10-7::                 Character Comparisons
* 10-8::                 Strings
* 10-9::                 String Comparisons


File: pcl.info,  Node: 10-1,  Next: 10-2,  Prev: Chapter 10,  Up: Chapter 10

Numbers
=======

content 10-1


File: pcl.info,  Node: 10-2,  Next: 10-3,  Prev: 10-1,  Up: Chapter 10

Numeric Literals
================

content 10-2


File: pcl.info,  Node: 10-3,  Next: 10-4,  Prev: 10-2,  Up: Chapter 10

Basic Math
==========

content 10-3


File: pcl.info,  Node: 10-4,  Next: 10-5,  Prev: 10-3,  Up: Chapter 10

Numeric Comparisons
===================

content 10-4


File: pcl.info,  Node: 10-5,  Next: 10-6,  Prev: 10-4,  Up: Chapter 10

Higher Math
===========

content 10-5


File: pcl.info,  Node: 10-6,  Next: 10-7,  Prev: 10-5,  Up: Chapter 10

Characters
==========

content 10-6


File: pcl.info,  Node: 10-7,  Next: 10-8,  Prev: 10-6,  Up: Chapter 10

Character Comparisons
=====================

content 10-7


File: pcl.info,  Node: 10-8,  Next: 10-9,  Prev: 10-7,  Up: Chapter 10

Strings
=======

content 10-8


File: pcl.info,  Node: 10-9,  Next: Chapter 11,  Prev: 10-8,  Up: Chapter 10

String Comparisons
==================

content 10-9


File: pcl.info,  Node: Chapter 11,  Next: Chapter 12,  Prev: Chapter 10,  Up: Top

11. Collections
===============

content 11-intro

* Menu:

* 11-1::                            Vectors
* 11-2::                            Subtypes of Vector
* 11-3::                            Vectors As Sequences
* 11-4::                            Sequence Iterating Functions
* 11-5::                            Higher-Order Function Variants
* 11-6::                            Whole Sequence Manipulations
* 11-7::                            Sorting and Merging
* 11-8::                            Subsequence Manipulations
* 11-9::                            Sequence Predicates
* 11-10::                           Sequence Mapping Functions
* 11-11::                           Hash Tables
* 11-12::                           Hash Table Iteration


File: pcl.info,  Node: 11-1,  Next: 11-2,  Prev: Chapter 11,  Up: Chapter 11

Vectors
=======

content 11-1


File: pcl.info,  Node: 11-2,  Next: 11-3,  Prev: 11-1,  Up: Chapter 11

Subtypes of Vector
==================

content 11-2


File: pcl.info,  Node: 11-3,  Next: 11-4,  Prev: 11-2,  Up: Chapter 11

Vectors As Sequences
====================

content 11-3


File: pcl.info,  Node: 11-4,  Next: 11-5,  Prev: 11-3,  Up: Chapter 11

Sequence Iterating Functions
============================

content 11-4


File: pcl.info,  Node: 11-5,  Next: 11-6,  Prev: 11-4,  Up: Chapter 11

Higher-Order Function Variants
==============================

content 11-5


File: pcl.info,  Node: 11-6,  Next: 11-7,  Prev: 11-5,  Up: Chapter 11

Whole Sequence Manipulations
============================

content 11-6


File: pcl.info,  Node: 11-7,  Next: 11-8,  Prev: 11-6,  Up: Chapter 11

Sorting and Merging
===================

content 11-7


File: pcl.info,  Node: 11-8,  Next: 11-9,  Prev: 11-7,  Up: Chapter 11

Subsequence Manipulations
=========================

content 11-8


File: pcl.info,  Node: 11-9,  Next: 11-10,  Prev: 11-8,  Up: Chapter 11

Sequence Predicates
===================

content 11-9


File: pcl.info,  Node: 11-10,  Next: 11-11,  Prev: 11-9,  Up: Chapter 11

Sequence Mapping Functions
==========================

content 11-10


File: pcl.info,  Node: 11-11,  Next: 11-12,  Prev: 11-10,  Up: Chapter 11

Hash Tables
===========

content 11-11


File: pcl.info,  Node: 11-12,  Next: Chapter 12,  Prev: 11-11,  Up: Chapter 11

Hash Table Iteration
====================

content 11-12


File: pcl.info,  Node: Chapter 12,  Next: Chapter 13,  Prev: Chapter 11,  Up: Top

12. They Called It LISP for a Reason: List Processing
=====================================================

content 12-intro

* Menu:

* 12-1::             "There Is No List"
* 12-2::             Functional Programming and Lists
* 12-3::             "Destructive" Operations
* 12-4::             Combining Recycling with Shared Structure
* 12-5::             List-Manipulation Functions
* 12-6::             Mapping
* 12-7::             Other Structures


File: pcl.info,  Node: 12-1,  Next: 12-2,  Prev: Chapter 12,  Up: Chapter 12

"There Is No List"
==================

content 12-1


File: pcl.info,  Node: 12-2,  Next: 12-3,  Prev: 12-1,  Up: Chapter 12

Functional Programming and Lists
================================

content 12-2


File: pcl.info,  Node: 12-3,  Next: 12-4,  Prev: 12-2,  Up: Chapter 12

"Destructive" Operations
========================

content 12-3


File: pcl.info,  Node: 12-4,  Next: 12-5,  Prev: 12-3,  Up: Chapter 12

Combining Recycling with Shared Structure
=========================================

content 12-4


File: pcl.info,  Node: 12-5,  Next: 12-6,  Prev: 12-4,  Up: Chapter 12

List-Manipulation Functions
===========================

content 12-5


File: pcl.info,  Node: 12-6,  Next: 12-7,  Prev: 12-5,  Up: Chapter 12

Mapping
=======

content 12-6


File: pcl.info,  Node: 12-7,  Next: Chapter 13,  Prev: 12-6,  Up: Chapter 12

Other Structures
================

content 12-7


File: pcl.info,  Node: Chapter 13,  Next: Chapter 14,  Prev: Chapter 12,  Up: Top

13. Beyond Lists: Other Uses for Cons Cells
===========================================

content 13-intro

* Menu:

* 13-1::                Trees
* 13-2::                Sets
* 13-3::                Lookup Tables: Alists and Plists
* 13-4::                DESTRUCTURING-BIND


File: pcl.info,  Node: 13-1,  Next: 13-2,  Prev: Chapter 13,  Up: Chapter 13

Trees
=====

content 13-1


File: pcl.info,  Node: 13-2,  Next: 13-3,  Prev: 13-1,  Up: Chapter 13

Sets
====

content 13-2


File: pcl.info,  Node: 13-3,  Next: 13-4,  Prev: 13-2,  Up: Chapter 13

Lookup Tables: Alists and Plists
================================

content 13-3


File: pcl.info,  Node: 13-4,  Next: Chapter 14,  Prev: 13-3,  Up: Chapter 13

DESTRUCTURING-BIND
==================

content 13-4


File: pcl.info,  Node: Chapter 14,  Next: Chapter 15,  Prev: Chapter 13,  Up: Top

14. Files and File I/O
======================

content 14-intro

* Menu:

* 14-1::      Reading File Data
* 14-2::      Reading Binary Data
* 14-3::      Bulk Reads
* 14-4::      File Output
* 14-5::      Closing Files
* 14-6::      Filenames
* 14-7::      How Pathnames Represent Filenames
* 14-8::      Constructing New Pathnames
* 14-9::      Two Representations of Directory Names
* 14-10::     Interacting with the File System
* 14-11::     Other Kinds of I/O


File: pcl.info,  Node: 14-1,  Next: 14-2,  Prev: Chapter 14,  Up: Chapter 14

Reading File Data
=================

content 14-1


File: pcl.info,  Node: 14-2,  Next: 14-3,  Prev: 14-1,  Up: Chapter 14

Reading Binary Data
===================

content 14-2


File: pcl.info,  Node: 14-3,  Next: 14-4,  Prev: 14-2,  Up: Chapter 14

Bulk Reads
==========

content 14-3


File: pcl.info,  Node: 14-4,  Next: 14-5,  Prev: 14-3,  Up: Chapter 14

File Output
===========

content 14-4


File: pcl.info,  Node: 14-5,  Next: 14-6,  Prev: 14-4,  Up: Chapter 14

Closing Files
=============

content 14-5


File: pcl.info,  Node: 14-6,  Next: 14-7,  Prev: 14-5,  Up: Chapter 14

Filenames
=========

content 14-6


File: pcl.info,  Node: 14-7,  Next: 14-8,  Prev: 14-6,  Up: Chapter 14

How Pathnames Represent Filenames
=================================

content 14-7


File: pcl.info,  Node: 14-8,  Next: 14-9,  Prev: 14-7,  Up: Chapter 14

Constructing New Pathnames
==========================

content 14-8


File: pcl.info,  Node: 14-9,  Next: 14-10,  Prev: 14-8,  Up: Chapter 14

Two Representations of Directory Names
======================================

content 14-9


File: pcl.info,  Node: 14-10,  Next: 14-11,  Prev: 14-9,  Up: Chapter 14

Interacting with the File System
================================

content 14-10


File: pcl.info,  Node: 14-11,  Next: Chapter 15,  Prev: 14-10,  Up: Chapter 14

Other Kinds of I/O
==================

content 14-11


File: pcl.info,  Node: Chapter 15,  Next: Chapter 16,  Prev: Chapter 14,  Up: Top

15. Practical: A Portable Pathname Library
==========================================

content 15-intro

* Menu:

* 15-1::       The API
* 15-2::       *FEATURES* and Read-Time Conditionalization
* 15-3::       Listing a Directory
* 15-4::       Testing a File's Existence
* 15-5::       Walking a Directory Tree


File: pcl.info,  Node: 15-1,  Next: 15-2,  Prev: Chapter 15,  Up: Chapter 15

The API
=======

content 15-1


File: pcl.info,  Node: 15-2,  Next: 15-3,  Prev: 15-1,  Up: Chapter 15

*FEATURES* and Read-Time Conditionalization
===========================================

content 15-2


File: pcl.info,  Node: 15-3,  Next: 15-4,  Prev: 15-2,  Up: Chapter 15

Listing a Directory
===================

content 15-3


File: pcl.info,  Node: 15-4,  Next: 15-5,  Prev: 15-3,  Up: Chapter 15

Testing a File's Existence
==========================

content 15-4


File: pcl.info,  Node: 15-5,  Next: Chapter 16,  Prev: 15-4,  Up: Chapter 15

Walking a Directory Tree
========================

content 15-5


File: pcl.info,  Node: Chapter 16,  Next: Chapter 17,  Prev: Chapter 15,  Up: Top

16. Object Reorientation: Generic Functions
===========================================

content 16-intro

* Menu:

* 16-1::   Generic Functions and Classes
* 16-2::   Generic Functions and Methods
* 16-3::   DEFGENERIC
* 16-4::   DEFMETHOD
* 16-5::   Method Combination
* 16-6::   The Standard Method Combination
* 16-7::   Other Method Combinations
* 16-8::   Multimethods
* 16-9::   To Be Continued . . .


File: pcl.info,  Node: 16-1,  Next: 16-2,  Prev: Chapter 16,  Up: Chapter 16

Generic Functions and Classes
=============================

content 16-1


File: pcl.info,  Node: 16-2,  Next: 16-3,  Prev: 16-1,  Up: Chapter 16

Generic Functions and Methods
=============================

content 16-2


File: pcl.info,  Node: 16-3,  Next: 16-4,  Prev: 16-2,  Up: Chapter 16

DEFGENERIC
==========

content 16-3


File: pcl.info,  Node: 16-4,  Next: 16-5,  Prev: 16-3,  Up: Chapter 16

DEFMETHOD
=========

content 16-4


File: pcl.info,  Node: 16-5,  Next: 16-6,  Prev: 16-4,  Up: Chapter 16

Method Combination
==================

content 16-5


File: pcl.info,  Node: 16-6,  Next: 16-7,  Prev: 16-5,  Up: Chapter 16

The Standard Method Combination
===============================

content 16-6


File: pcl.info,  Node: 16-7,  Next: 16-8,  Prev: 16-6,  Up: Chapter 16

Other Method Combinations
=========================

content 16-7


File: pcl.info,  Node: 16-8,  Next: 16-9,  Prev: 16-7,  Up: Chapter 16

Multimethods
============

content 16-8


File: pcl.info,  Node: 16-9,  Next: Chapter 17,  Prev: 16-8,  Up: Chapter 16

To Be Continued . . .
=====================

content 16-9


File: pcl.info,  Node: Chapter 17,  Next: Chapter 18,  Prev: Chapter 16,  Up: Top

17. Object Reorientation: Classes
=================================

content 17-intro

* Menu:

* 17-1::   DEFCLASS
* 17-2::   Slot Specifiers
* 17-3::   Object Initialization
* 17-4::   Accessor Functions
* 17-5::   WITH-SLOTS and WITH-ACCESSORS
* 17-6::   Class-Allocated Slots
* 17-7::   Slots and Inheritance
* 17-8::   Multiple Inheritance
* 17-9::   Good Object-Oriented Design


File: pcl.info,  Node: 17-1,  Next: 17-2,  Prev: Chapter 17,  Up: Chapter 17

DEFCLASS
========

content 17-1


File: pcl.info,  Node: 17-2,  Next: 17-3,  Prev: 17-1,  Up: Chapter 17

Slot Specifiers
===============

content 17-2


File: pcl.info,  Node: 17-3,  Next: 17-4,  Prev: 17-2,  Up: Chapter 17

Object Initialization
=====================

content 17-3


File: pcl.info,  Node: 17-4,  Next: 17-5,  Prev: 17-3,  Up: Chapter 17

Accessor Functions
==================

content 17-4


File: pcl.info,  Node: 17-5,  Next: 17-6,  Prev: 17-4,  Up: Chapter 17

WITH-SLOTS and WITH-ACCESSORS
=============================

content 17-5


File: pcl.info,  Node: 17-6,  Next: 17-7,  Prev: 17-5,  Up: Chapter 17

Class-Allocated Slots
=====================

content 17-6


File: pcl.info,  Node: 17-7,  Next: 17-8,  Prev: 17-6,  Up: Chapter 17

Slots and Inheritance
=====================

content 17-7


File: pcl.info,  Node: 17-8,  Next: 17-9,  Prev: 17-7,  Up: Chapter 17

Multiple Inheritance
====================

content 17-8


File: pcl.info,  Node: 17-9,  Next: Chapter 18,  Prev: 17-8,  Up: Chapter 17

Good Object-Oriented Design
===========================

content 17-9


File: pcl.info,  Node: Chapter 18,  Next: Chapter 19,  Prev: Chapter 17,  Up: Top

18. A Few FORMAT Recipes
========================

content 18-intro

* Menu:

* 18-1::         The FORMAT Function
* 18-2::         FORMAT Directives
* 18-3::         Basic Formatting
* 18-4::         Character and Integer Directives
* 18-5::         Floating-Point Directives
* 18-6::         English-Language Directives
* 18-7::         Conditional Formatting
* 18-8::         Iteration
* 18-9::         Hop, Skip, Jump
* 18-10::        And More . . .


File: pcl.info,  Node: 18-1,  Next: 18-2,  Prev: Chapter 18,  Up: Chapter 18

The FORMAT Function
===================

content 18-1


File: pcl.info,  Node: 18-2,  Next: 18-3,  Prev: 18-1,  Up: Chapter 18

FORMAT Directives
=================

content 18-2


File: pcl.info,  Node: 18-3,  Next: 18-4,  Prev: 18-2,  Up: Chapter 18

Basic Formatting
================

content 18-3


File: pcl.info,  Node: 18-4,  Next: 18-5,  Prev: 18-3,  Up: Chapter 18

Character and Integer Directives
================================

content 18-4


File: pcl.info,  Node: 18-5,  Next: 18-6,  Prev: 18-4,  Up: Chapter 18

Floating-Point Directives
=========================

content 18-5


File: pcl.info,  Node: 18-6,  Next: 18-7,  Prev: 18-5,  Up: Chapter 18

English-Language Directives
===========================

content 18-6


File: pcl.info,  Node: 18-7,  Next: 18-8,  Prev: 18-6,  Up: Chapter 18

Conditional Formatting
======================

content 18-7


File: pcl.info,  Node: 18-8,  Next: 18-9,  Prev: 18-7,  Up: Chapter 18

Iteration
=========

content 18-8


File: pcl.info,  Node: 18-9,  Next: 18-10,  Prev: 18-8,  Up: Chapter 18

Hop, Skip, Jump
===============

content 18-9


File: pcl.info,  Node: 18-10,  Next: Chapter 19,  Prev: 18-9,  Up: Chapter 18

And More . . .
==============

content 18-10


File: pcl.info,  Node: Chapter 19,  Next: Chapter 20,  Prev: Chapter 18,  Up: Top

19. Beyond Exception Handling: Conditions and Restarts
======================================================

content 19-intro

* Menu:

* 19-1::             The Lisp Way
* 19-2::             Conditions
* 19-3::             Condition Handlers
* 19-4::             Restarts
* 19-5::             Providing Multiple Restarts
* 19-6::             Other Uses for Conditions


File: pcl.info,  Node: 19-1,  Next: 19-2,  Prev: Chapter 19,  Up: Chapter 19

The Lisp Way
============

content 19-1


File: pcl.info,  Node: 19-2,  Next: 19-3,  Prev: 19-1,  Up: Chapter 19

Conditions
==========

content 19-2


File: pcl.info,  Node: 19-3,  Next: 19-4,  Prev: 19-2,  Up: Chapter 19

Condition Handlers
==================

content 19-3


File: pcl.info,  Node: 19-4,  Next: 19-5,  Prev: 19-3,  Up: Chapter 19

Restarts
========

content 19-4


File: pcl.info,  Node: 19-5,  Next: 19-6,  Prev: 19-4,  Up: Chapter 19

Providing Multiple Restarts
===========================

content 19-5


File: pcl.info,  Node: 19-6,  Next: Chapter 20,  Prev: 19-5,  Up: Chapter 19

Other Uses for Conditions
=========================

content 19-6


File: pcl.info,  Node: Chapter 20,  Next: Chapter 21,  Prev: Chapter 19,  Up: Top

20. The Special Operators
=========================

content 20-intro

* Menu:

* 20-1::        Controlling Evaluation
* 20-2::        Manipulating the Lexical Environment
* 20-3::        Local Flow of Control
* 20-4::        Unwinding the Stack
* 20-5::        Multiple Values
* 20-6::        EVAL-WHEN
* 20-7::        Other Special Operators


File: pcl.info,  Node: 20-1,  Next: 20-2,  Prev: Chapter 20,  Up: Chapter 20

Controlling Evaluation
======================

content 20-1


File: pcl.info,  Node: 20-2,  Next: 20-3,  Prev: 20-1,  Up: Chapter 20

Manipulating the Lexical Environment
====================================

content 20-2


File: pcl.info,  Node: 20-3,  Next: 20-4,  Prev: 20-2,  Up: Chapter 20

Local Flow of Control
=====================

content 20-3


File: pcl.info,  Node: 20-4,  Next: 20-5,  Prev: 20-3,  Up: Chapter 20

Unwinding the Stack
===================

content 20-4


File: pcl.info,  Node: 20-5,  Next: 20-6,  Prev: 20-4,  Up: Chapter 20

Multiple Values
===============

content 20-5


File: pcl.info,  Node: 20-6,  Next: 20-7,  Prev: 20-5,  Up: Chapter 20

EVAL-WHEN
=========

content 20-6


File: pcl.info,  Node: 20-7,  Next: Chapter 21,  Prev: 20-6,  Up: Chapter 20

Other Special Operators
=======================

content 20-7


File: pcl.info,  Node: Chapter 21,  Next: Chapter 22,  Prev: Chapter 20,  Up: Top

21. Programming in the Large: Packages and Symbols
==================================================

content 21-intro

* Menu:

* 21-1::        How the Reader Uses Packages
* 21-2::        A Bit of Package and Symbol Vocabulary
* 21-3::        Three Standard Packages
* 21-4::        Defining Your Own Packages
* 21-5::        Packaging Reusable Libraries
* 21-6::        Importing Individual Names
* 21-7::        Packaging Mechanics
* 21-8::        Package Gotchas


File: pcl.info,  Node: 21-1,  Next: 21-2,  Prev: Chapter 21,  Up: Chapter 21

How the Reader Uses Packages
============================

content 21-1


File: pcl.info,  Node: 21-2,  Next: 21-3,  Prev: 21-1,  Up: Chapter 21

A Bit of Package and Symbol Vocabulary
======================================

content 21-2


File: pcl.info,  Node: 21-3,  Next: 21-4,  Prev: 21-2,  Up: Chapter 21

Three Standard Packages
=======================

content 21-3


File: pcl.info,  Node: 21-4,  Next: 21-5,  Prev: 21-3,  Up: Chapter 21

Defining Your Own Packages
==========================

content 21-4


File: pcl.info,  Node: 21-5,  Next: 21-6,  Prev: 21-4,  Up: Chapter 21

Packaging Reusable Libraries
============================

content 21-5


File: pcl.info,  Node: 21-6,  Next: 21-7,  Prev: 21-5,  Up: Chapter 21

Importing Individual Names
==========================

content 21-6


File: pcl.info,  Node: 21-7,  Next: 21-8,  Prev: 21-6,  Up: Chapter 21

Packaging Mechanics
===================

content 21-7


File: pcl.info,  Node: 21-8,  Next: Chapter 22,  Prev: 21-7,  Up: Chapter 21

Package Gotchas
===============

content 21-8


File: pcl.info,  Node: Chapter 22,  Next: Chapter 23,  Prev: Chapter 21,  Up: Top

22. LOOP for Black Belts
========================

content 22-intro

* Menu:

* 22-1::     The Parts of a LOOP
* 22-2::     Iteration Control
* 22-3::     Counting Loops
* 22-4::     Looping Over Collections and Packages
* 22-5::     Equals-Then Iteration
* 22-6::     Local Variables
* 22-7::     Destructuring Variables
* 22-8::     Value Accumulation
* 22-9::     Unconditional Execution
* 22-10::    Conditional Execution
* 22-11::    Setting Up and Tearing Down
* 22-12::    Termination Tests
* 22-13::    Putting It All Together


File: pcl.info,  Node: 22-1,  Next: 22-2,  Prev: Chapter 22,  Up: Chapter 22

The Parts of a LOOP
===================

content 22-1


File: pcl.info,  Node: 22-2,  Next: 22-3,  Prev: 22-1,  Up: Chapter 22

Iteration Control
=================

content 22-2


File: pcl.info,  Node: 22-3,  Next: 22-4,  Prev: 22-2,  Up: Chapter 22

Counting Loops
==============

content 22-3


File: pcl.info,  Node: 22-4,  Next: 22-5,  Prev: 22-3,  Up: Chapter 22

Looping Over Collections and Packages
=====================================

content 22-4


File: pcl.info,  Node: 22-5,  Next: 22-6,  Prev: 22-4,  Up: Chapter 22

Equals-Then Iteration
=====================

content 22-5


File: pcl.info,  Node: 22-6,  Next: 22-7,  Prev: 22-5,  Up: Chapter 22

Local Variables
===============

content 22-6


File: pcl.info,  Node: 22-7,  Next: 22-8,  Prev: 22-6,  Up: Chapter 22

Destructuring Variables
=======================

content 22-7


File: pcl.info,  Node: 22-8,  Next: 22-9,  Prev: 22-7,  Up: Chapter 22

Value Accumulation
==================

content 22-8


File: pcl.info,  Node: 22-9,  Next: 22-10,  Prev: 22-8,  Up: Chapter 22

Unconditional Execution
=======================

content 22-9


File: pcl.info,  Node: 22-10,  Next: 22-11,  Prev: 22-9,  Up: Chapter 22

Conditional Execution
=====================

content 22-10


File: pcl.info,  Node: 22-11,  Next: 22-12,  Prev: 22-10,  Up: Chapter 22

Setting Up and Tearing Down
===========================

content 22-11


File: pcl.info,  Node: 22-12,  Next: 22-13,  Prev: 22-11,  Up: Chapter 22

Termination Tests
=================

content 22-12


File: pcl.info,  Node: 22-13,  Next: Chapter 23,  Prev: 22-12,  Up: Chapter 22

Putting It All Together
=======================

content 22-13


File: pcl.info,  Node: Chapter 23,  Next: Chapter 24,  Prev: Chapter 22,  Up: Top

23. Practical: A Spam Filter
============================

content 23-intro

* Menu:

* 23-1::       The Heart of a Spam Filter
* 23-2::       Training the Filter
* 23-3::       Per-Word Statistics
* 23-4::       Combining Probabilities
* 23-5::       Inverse Chi Square
* 23-6::       Training the Filter
* 23-7::       Testing the Filter
* 23-8::       A Couple of Utility Functions
* 23-9::       Analyzing the Results
* 23-10::      What's Next


File: pcl.info,  Node: 23-1,  Next: 23-2,  Prev: Chapter 23,  Up: Chapter 23

The Heart of a Spam Filter
==========================

content 23-1


File: pcl.info,  Node: 23-2,  Next: 23-3,  Prev: 23-1,  Up: Chapter 23

Training the Filter
===================

content 23-2


File: pcl.info,  Node: 23-3,  Next: 23-4,  Prev: 23-2,  Up: Chapter 23

Per-Word Statistics
===================

content 23-3


File: pcl.info,  Node: 23-4,  Next: 23-5,  Prev: 23-3,  Up: Chapter 23

Combining Probabilities
=======================

content 23-4


File: pcl.info,  Node: 23-5,  Next: 23-6,  Prev: 23-4,  Up: Chapter 23

Inverse Chi Square
==================

content 23-5


File: pcl.info,  Node: 23-6,  Next: 23-7,  Prev: 23-5,  Up: Chapter 23

Training the Filter
===================

content 23-6


File: pcl.info,  Node: 23-7,  Next: 23-8,  Prev: 23-6,  Up: Chapter 23

Testing the Filter
==================

content 23-7


File: pcl.info,  Node: 23-8,  Next: 23-9,  Prev: 23-7,  Up: Chapter 23

A Couple of Utility Functions
=============================

content 23-8


File: pcl.info,  Node: 23-9,  Next: 23-10,  Prev: 23-8,  Up: Chapter 23

Analyzing the Results
=====================

content 23-9


File: pcl.info,  Node: 23-10,  Next: Chapter 24,  Prev: 23-9,  Up: Chapter 23

What's Next
===========

content 23-10


File: pcl.info,  Node: Chapter 24,  Next: Chapter 25,  Prev: Chapter 23,  Up: Top

24. Practical: Parsing Binary Files
===================================

content 24-intro

* Menu:

* 24-1::       Binary Files
* 24-2::       Binary Format Basics
* 24-3::       Strings in Binary Files
* 24-4::       Composite Structures
* 24-5::       Designing the Macros
* 24-6::       Making the Dream a Reality
* 24-7::       Reading Binary Objects
* 24-8::       Writing Binary Objects
* 24-9::       Adding Inheritance and Tagged Structures
* 24-10::      Keeping Track of Inherited Slots
* 24-11::      Tagged Structures
* 24-12::      Primitive Binary Types
* 24-13::      The Current Object Stack


File: pcl.info,  Node: 24-1,  Next: 24-2,  Prev: Chapter 24,  Up: Chapter 24

Binary Files
============

content 24-1


File: pcl.info,  Node: 24-2,  Next: 24-3,  Prev: 24-1,  Up: Chapter 24

Binary Format Basics
====================

content 24-2


File: pcl.info,  Node: 24-3,  Next: 24-4,  Prev: 24-2,  Up: Chapter 24

Strings in Binary Files
=======================

content 24-3


File: pcl.info,  Node: 24-4,  Next: 24-5,  Prev: 24-3,  Up: Chapter 24

Composite Structures
====================

content 24-4


File: pcl.info,  Node: 24-5,  Next: 24-6,  Prev: 24-4,  Up: Chapter 24

Designing the Macros
====================

content 24-5


File: pcl.info,  Node: 24-6,  Next: 24-7,  Prev: 24-5,  Up: Chapter 24

Making the Dream a Reality
==========================

content 24-6


File: pcl.info,  Node: 24-7,  Next: 24-8,  Prev: 24-6,  Up: Chapter 24

Reading Binary Objects
======================

content 24-7


File: pcl.info,  Node: 24-8,  Next: 24-9,  Prev: 24-7,  Up: Chapter 24

Writing Binary Objects
======================

content 24-8


File: pcl.info,  Node: 24-9,  Next: 24-10,  Prev: 24-8,  Up: Chapter 24

Adding Inheritance and Tagged Structures
========================================

content 24-9


File: pcl.info,  Node: 24-10,  Next: 24-11,  Prev: 24-9,  Up: Chapter 24

Keeping Track of Inherited Slots
================================

content 24-10


File: pcl.info,  Node: 24-11,  Next: 24-12,  Prev: 24-10,  Up: Chapter 24

Tagged Structures
=================

content 24-11


File: pcl.info,  Node: 24-12,  Next: 24-13,  Prev: 24-11,  Up: Chapter 24

Primitive Binary Types
======================

content 24-12


File: pcl.info,  Node: 24-13,  Next: Chapter 25,  Prev: 24-12,  Up: Chapter 24

The Current Object Stack
========================

content 24-13


File: pcl.info,  Node: Chapter 25,  Next: Chapter 26,  Prev: Chapter 24,  Up: Top

25. Practical: An ID3 Parser
============================

content 25-intro

* Menu:

* 25-1::       Structure of an ID3v2 Tag
* 25-2::       Defining a Package
* 25-3::       Integer Types
* 25-4::       String Types
* 25-5::       ID3 Tag Header
* 25-6::       ID3 Frames
* 25-7::       Detecting Tag Padding
* 25-8::       Supporting Multiple Versions of ID3
* 25-9::       Versioned Frame Base Classes
* 25-10::      Versioned Concrete Frame Classes
* 25-11::      What Frames Do You Actually Need?
* 25-12::      Text Information Frames
* 25-13::      Comment Frames
* 25-14::      Extracting Information from an ID3 Tag


File: pcl.info,  Node: 25-1,  Next: 25-2,  Prev: Chapter 25,  Up: Chapter 25

Structure of an ID3v2 Tag
=========================

content 25-1


File: pcl.info,  Node: 25-2,  Next: 25-3,  Prev: 25-1,  Up: Chapter 25

Defining a Package
==================

content 25-2


File: pcl.info,  Node: 25-3,  Next: 25-4,  Prev: 25-2,  Up: Chapter 25

Integer Types
=============

content 25-3


File: pcl.info,  Node: 25-4,  Next: 25-5,  Prev: 25-3,  Up: Chapter 25

String Types
============

content 25-4


File: pcl.info,  Node: 25-5,  Next: 25-6,  Prev: 25-4,  Up: Chapter 25

ID3 Tag Header
==============

content 25-5


File: pcl.info,  Node: 25-6,  Next: 25-7,  Prev: 25-5,  Up: Chapter 25

ID3 Frames
==========

content 25-6


File: pcl.info,  Node: 25-7,  Next: 25-8,  Prev: 25-6,  Up: Chapter 25

Detecting Tag Padding
=====================

content 25-7


File: pcl.info,  Node: 25-8,  Next: 25-9,  Prev: 25-7,  Up: Chapter 25

Supporting Multiple Versions of ID3
===================================

content 25-8


File: pcl.info,  Node: 25-9,  Next: 25-10,  Prev: 25-8,  Up: Chapter 25

Versioned Frame Base Classes
============================

content 25-9


File: pcl.info,  Node: 25-10,  Next: 25-11,  Prev: 25-9,  Up: Chapter 25

Versioned Concrete Frame Classes
================================

content 25-10


File: pcl.info,  Node: 25-11,  Next: 25-12,  Prev: 25-10,  Up: Chapter 25

What Frames Do You Actually Need?
=================================

content 25-11


File: pcl.info,  Node: 25-12,  Next: 25-13,  Prev: 25-11,  Up: Chapter 25

Text Information Frames
=======================

content 25-12


File: pcl.info,  Node: 25-13,  Next: 25-14,  Prev: 25-12,  Up: Chapter 25

Comment Frames
==============

content 25-13


File: pcl.info,  Node: 25-14,  Next: Chapter 26,  Prev: 25-13,  Up: Chapter 25

Extracting Information from an ID3 Tag
======================================

content 25-14


File: pcl.info,  Node: Chapter 26,  Next: Chapter 27,  Prev: Chapter 25,  Up: Top

26. Practical: Web Programming with AllegroServe
================================================

content 26-intro

* Menu:

* 26-1::       A 30-Second Intro to Server-Side Web Programming
* 26-2::       AllegroServe
* 26-3::       Generating Dynamic Content with AllegroServe
* 26-4::       Generating HTML
* 26-5::       HTML Macros
* 26-6::       Query Parameters
* 26-7::       Cookies
* 26-8::       A Small Application Framework
* 26-9::       The Implementation


File: pcl.info,  Node: 26-1,  Next: 26-2,  Prev: Chapter 26,  Up: Chapter 26

A 30-Second Intro to Server-Side Web Programming
================================================

content 26-1


File: pcl.info,  Node: 26-2,  Next: 26-3,  Prev: 26-1,  Up: Chapter 26

AllegroServe
============

content 26-2


File: pcl.info,  Node: 26-3,  Next: 26-4,  Prev: 26-2,  Up: Chapter 26

Generating Dynamic Content with AllegroServe
============================================

content 26-3


File: pcl.info,  Node: 26-4,  Next: 26-5,  Prev: 26-3,  Up: Chapter 26

Generating HTML
===============

content 26-4


File: pcl.info,  Node: 26-5,  Next: 26-6,  Prev: 26-4,  Up: Chapter 26

HTML Macros
===========

content 26-5


File: pcl.info,  Node: 26-6,  Next: 26-7,  Prev: 26-5,  Up: Chapter 26

Query Parameters
================

content 26-6


File: pcl.info,  Node: 26-7,  Next: 26-8,  Prev: 26-6,  Up: Chapter 26

Cookies
=======

content 26-7


File: pcl.info,  Node: 26-8,  Next: 26-9,  Prev: 26-7,  Up: Chapter 26

A Small Application Framework
=============================

content 26-8


File: pcl.info,  Node: 26-9,  Next: Chapter 27,  Prev: 26-8,  Up: Chapter 26

The Implementation
==================

content 26-9


File: pcl.info,  Node: Chapter 27,  Next: Chapter 28,  Prev: Chapter 26,  Up: Top

27. Practical: An MP3 Database
==============================

content 27-intro

* Menu:

* 27-1::       The Database
* 27-2::       Defining a Schema
* 27-3::       Inserting Values
* 27-4::       Querying the Database
* 27-5::       Matching Functions
* 27-6::       Getting at the Results
* 27-7::       Other Database Operations


File: pcl.info,  Node: 27-1,  Next: 27-2,  Prev: Chapter 27,  Up: Chapter 27

The Database
============

content 27-1


File: pcl.info,  Node: 27-2,  Next: 27-3,  Prev: 27-1,  Up: Chapter 27

Defining a Schema
=================

content 27-2


File: pcl.info,  Node: 27-3,  Next: 27-4,  Prev: 27-2,  Up: Chapter 27

Inserting Values
================

content 27-3


File: pcl.info,  Node: 27-4,  Next: 27-5,  Prev: 27-3,  Up: Chapter 27

Querying the Database
=====================

content 27-4


File: pcl.info,  Node: 27-5,  Next: 27-6,  Prev: 27-4,  Up: Chapter 27

Matching Functions
==================

content 27-5


File: pcl.info,  Node: 27-6,  Next: 27-7,  Prev: 27-5,  Up: Chapter 27

Getting at the Results
======================

content 27-6


File: pcl.info,  Node: 27-7,  Next: Chapter 28,  Prev: 27-6,  Up: Chapter 27

Other Database Operations
=========================

content 27-7


File: pcl.info,  Node: Chapter 28,  Next: Chapter 29,  Prev: Chapter 27,  Up: Top

28. Practical: A Shoutcast Server
=================================

content 28-intro

* Menu:

* 28-1::       The Shoutcast Protocol
* 28-2::       Song Sources
* 28-3::       Implementing Shoutcast


File: pcl.info,  Node: 28-1,  Next: 28-2,  Prev: Chapter 28,  Up: Chapter 28

The Shoutcast Protocol
======================

content 28-1


File: pcl.info,  Node: 28-2,  Next: 28-3,  Prev: 28-1,  Up: Chapter 28

Song Sources
============

content 28-2


File: pcl.info,  Node: 28-3,  Next: Chapter 29,  Prev: 28-2,  Up: Chapter 28

Implementing Shoutcast
======================

content 28-3


File: pcl.info,  Node: Chapter 29,  Next: Chapter 30,  Prev: Chapter 28,  Up: Top

29. Practical: An MP3 Browser
=============================

content 29-intro

* Menu:

* 29-1::       Playlists
* 29-2::       Playlists As Song Sources
* 29-3::       Manipulating the Playlist
* 29-4::       Query Parameter Types
* 29-5::       Boilerplate HTML
* 29-6::       The Browse Page
* 29-7::       The Playlist
* 29-8::       Finding a Playlist
* 29-9::       Running the App


File: pcl.info,  Node: 29-1,  Next: 29-2,  Prev: Chapter 29,  Up: Chapter 29

Playlists
=========

content 29-1


File: pcl.info,  Node: 29-2,  Next: 29-3,  Prev: 29-1,  Up: Chapter 29

Playlists As Song Sources
=========================

content 29-2


File: pcl.info,  Node: 29-3,  Next: 29-4,  Prev: 29-2,  Up: Chapter 29

Manipulating the Playlist
=========================

content 29-3


File: pcl.info,  Node: 29-4,  Next: 29-5,  Prev: 29-3,  Up: Chapter 29

Query Parameter Types
=====================

content 29-4


File: pcl.info,  Node: 29-5,  Next: 29-6,  Prev: 29-4,  Up: Chapter 29

Boilerplate HTML
================

content 29-5


File: pcl.info,  Node: 29-6,  Next: 29-7,  Prev: 29-5,  Up: Chapter 29

The Browse Page
===============

content 29-6


File: pcl.info,  Node: 29-7,  Next: 29-8,  Prev: 29-6,  Up: Chapter 29

The Playlist
============

content 29-7


File: pcl.info,  Node: 29-8,  Next: 29-9,  Prev: 29-7,  Up: Chapter 29

Finding a Playlist
==================

content 29-8


File: pcl.info,  Node: 29-9,  Next: Chapter 30,  Prev: 29-8,  Up: Chapter 29

Running the App
===============

content 29-9


File: pcl.info,  Node: Chapter 30,  Next: Chapter 31,  Prev: Chapter 29,  Up: Top

30. Practical: An HTML Generation Library, the Interpreter
==========================================================

content 30-intro

* Menu:

* 30-1::       Designing a Domain-Specific Language
* 30-2::       The FOO Language
* 30-3::       Character Escaping
* 30-4::       Indenting Printer
* 30-5::       HTML Processor Interface
* 30-6::       The Pretty Printer Backend
* 30-7::       The Basic Evaluation Rule
* 30-8::       What's Next?


File: pcl.info,  Node: 30-1,  Next: 30-2,  Prev: Chapter 30,  Up: Chapter 30

Designing a Domain-Specific Language
====================================

content 30-1


File: pcl.info,  Node: 30-2,  Next: 30-3,  Prev: 30-1,  Up: Chapter 30

The FOO Language
================

content 30-2


File: pcl.info,  Node: 30-3,  Next: 30-4,  Prev: 30-2,  Up: Chapter 30

Character Escaping
==================

content 30-3


File: pcl.info,  Node: 30-4,  Next: 30-5,  Prev: 30-3,  Up: Chapter 30

Indenting Printer
=================

content 30-4


File: pcl.info,  Node: 30-5,  Next: 30-6,  Prev: 30-4,  Up: Chapter 30

HTML Processor Interface
========================

content 30-5


File: pcl.info,  Node: 30-6,  Next: 30-7,  Prev: 30-5,  Up: Chapter 30

The Pretty Printer Backend
==========================

content 30-6


File: pcl.info,  Node: 30-7,  Next: 30-8,  Prev: 30-6,  Up: Chapter 30

The Basic Evaluation Rule
=========================

content 30-7


File: pcl.info,  Node: 30-8,  Next: Chapter 31,  Prev: 30-7,  Up: Chapter 30

What's Next?
============

content 30-8


File: pcl.info,  Node: Chapter 31,  Next: Chapter 32,  Prev: Chapter 30,  Up: Top

31. Practical: An HTML Generation Library, the Compiler
=======================================================

content 31-intro

* Menu:

* 31-1::       The Compiler
* 31-2::       FOO Special Operators
* 31-3::       FOO Macros
* 31-4::       The Public API
* 31-5::       The End of the Line


File: pcl.info,  Node: 31-1,  Next: 31-2,  Prev: Chapter 31,  Up: Chapter 31

The Compiler
============

content 31-1


File: pcl.info,  Node: 31-2,  Next: 31-3,  Prev: 31-1,  Up: Chapter 31

FOO Special Operators
=====================

content 31-2


File: pcl.info,  Node: 31-3,  Next: 31-4,  Prev: 31-2,  Up: Chapter 31

FOO Macros
==========

content 31-3


File: pcl.info,  Node: 31-4,  Next: 31-5,  Prev: 31-3,  Up: Chapter 31

The Public API
==============

content 31-4


File: pcl.info,  Node: 31-5,  Next: Chapter 32,  Prev: 31-4,  Up: Chapter 31

The End of the Line
===================

content 31-5


File: pcl.info,  Node: Chapter 32,  Prev: Chapter 31,  Up: Top

32. Conclusion: What's Next?
============================

content 32-intro

* Menu:

* 32-1::        Finding Lisp Libraries
* 32-2::        Interfacing with Other Languages
* 32-3::        Make It Work, Make It Right, Make It Fast
* 32-4::        Delivering Applications
* 32-5::        Where to Go Next


File: pcl.info,  Node: 32-1,  Next: 32-2,  Prev: Chapter 32,  Up: Chapter 32

Finding Lisp Libraries
======================

content 32-1


File: pcl.info,  Node: 32-2,  Next: 32-3,  Prev: 32-1,  Up: Chapter 32

Interfacing with Other Languages
================================

content 32-2


File: pcl.info,  Node: 32-3,  Next: 32-4,  Prev: 32-2,  Up: Chapter 32

Make It Work, Make It Right, Make It Fast
=========================================

content 32-3


File: pcl.info,  Node: 32-4,  Next: 32-5,  Prev: 32-3,  Up: Chapter 32

Delivering Applications
=======================

content 32-4


File: pcl.info,  Node: 32-5,  Next: Chapter 32,  Prev: 32-4,  Up: Chapter 32

Where to Go Next
================

content 32-5


Tag Table:
Node: Top67
Node: Preface13435
Node: Letter14393
Node: Blurbs16261
Node: Chapter 125457
Node: 1-131160
Ref: 1-1-Footnote-136462
Ref: 1-1-Footnote-236534
Ref: 1-1-Footnote-336811
Ref: 1-1-Footnote-437958
Ref: 1-1-Footnote-538964
Ref: 1-1-Footnote-639769
Node: 1-239928
Ref: 1-2-Footnote-145380
Ref: 1-2-Footnote-245438
Ref: 1-2-Footnote-345697
Node: 1-346773
Node: Chapter 249114
Node: 2-150665
Node: 2-254728
Node: 2-358275
Node: 2-460244
Node: 2-561866
Node: 2-666358
Node: Chapter 375410
Node: 3-176015
Node: 3-276137
Node: 3-376243
Node: 3-476393
Node: 3-576539
Node: 3-676687
Node: 3-776815
Node: 3-876995
Node: 3-977153
Node: Chapter 477267
Node: 4-177808
Node: 4-277964
Node: 4-378104
Node: 4-478216
Node: 4-578356
Node: 4-678470
Node: 4-778590
Node: 4-878688
Node: 4-978834
Node: Chapter 578966
Node: 5-179519
Node: 5-279655
Node: 5-379789
Node: 5-479913
Node: 5-580029
Node: 5-680151
Node: 5-780301
Node: 5-880431
Node: 5-980613
Node: Chapter 680743
Node: 6-181131
Node: 6-281253
Node: 6-381399
Node: 6-481553
Node: 6-581657
Node: 6-681763
Node: Chapter 781899
Node: 7-182318
Node: 7-282440
Node: 7-382534
Node: 7-482652
Node: 7-582752
Node: 7-682874
Node: 7-782964
Node: Chapter 883086
Node: 8-183685
Node: 8-283843
Node: 8-383993
Node: 8-484097
Node: 8-584233
Node: 8-684351
Node: 8-784485
Node: 8-884607
Node: 8-984733
Node: Chapter 984865
Node: 9-185373
Node: 9-285495
Node: 9-385603
Node: 9-485735
Node: 9-585867
Node: 9-685997
Node: 9-786123
Node: Chapter 1086238
Node: 10-186778
Node: 10-286889
Node: 10-387012
Node: 10-487123
Node: 10-587252
Node: 10-687365
Node: 10-787476
Node: 10-887609
Node: 10-987714
Node: Chapter 1187847
Node: 11-188688
Node: 11-288799
Node: 11-388926
Node: 11-489057
Node: 11-589204
Node: 11-689355
Node: 11-789502
Node: 11-889631
Node: 11-989772
Node: 11-1089902
Node: 11-1190048
Node: 11-1290165
Node: Chapter 1290305
Node: 12-190846
Node: 12-290979
Node: 12-391134
Node: 12-491273
Node: 12-591446
Node: 12-691591
Node: 12-791696
Node: Chapter 1391825
Node: 13-192186
Node: 13-292293
Node: 13-392392
Node: 13-492547
Node: Chapter 1492680
Node: 14-193231
Node: 14-293362
Node: 14-393491
Node: 14-493602
Node: 14-593715
Node: 14-693832
Node: 14-793941
Node: 14-894098
Node: 14-994241
Node: 14-1094409
Node: 14-1194567
Node: Chapter 1594703
Node: 15-195102
Node: 15-295213
Node: 15-395390
Node: 15-495519
Node: 15-595662
Node: Chapter 1695807
Node: 16-196301
Node: 16-296456
Node: 16-396605
Node: 16-496716
Node: 16-596825
Node: 16-696952
Node: 16-797105
Node: 16-897246
Node: 16-997361
Node: Chapter 1797500
Node: 17-197970
Node: 17-298083
Node: 17-398204
Node: 17-498337
Node: 17-598464
Node: 17-698613
Node: 17-798746
Node: 17-898879
Node: 17-999010
Node: Chapter 1899161
Node: 18-199701
Node: 18-299836
Node: 18-399961
Node: 18-4100084
Node: 18-5100239
Node: 18-6100380
Node: 18-7100525
Node: 18-8100660
Node: 18-9100769
Node: 18-10100891
Node: Chapter 19101018
Node: 19-1101474
Node: 19-2101595
Node: 19-3101706
Node: 19-4101833
Node: 19-5101940
Node: 19-6102085
Node: Chapter 20102232
Node: 20-1102662
Node: 20-2102803
Node: 20-3102966
Node: 20-4103099
Node: 20-5103228
Node: 20-6103349
Node: 20-7103458
Node: Chapter 21103601
Node: 21-1104156
Node: 21-2104309
Node: 21-3104476
Node: 21-4104613
Node: 21-5104756
Node: 21-6104903
Node: 21-7105046
Node: 21-8105175
Node: Chapter 22105302
Node: 22-1105923
Node: 22-2106058
Node: 22-3106183
Node: 22-4106302
Node: 22-5106467
Node: 22-6106600
Node: 22-7106721
Node: 22-8106858
Node: 22-9106985
Node: 22-10107123
Node: 22-11107259
Node: 22-12107408
Node: 22-13107537
Node: Chapter 23107683
Node: 23-1108218
Node: 23-2108367
Node: 23-3108496
Node: 23-4108625
Node: 23-5108762
Node: 23-6108889
Node: 23-7109018
Node: 23-8109145
Node: 23-9109294
Node: 23-10109428
Node: Chapter 24109549
Node: 24-1110243
Node: 24-2110364
Node: 24-3110495
Node: 24-4110632
Node: 24-5110763
Node: 24-6110894
Node: 24-7111037
Node: 24-8111172
Node: 24-9111307
Node: 24-10111479
Node: 24-11111637
Node: 24-12111766
Node: 24-13111905
Node: Chapter 25112053
Node: 25-1112765
Node: 25-2112912
Node: 25-3113039
Node: 25-4113156
Node: 25-5113271
Node: 25-6113390
Node: 25-7113501
Node: 25-8113634
Node: 25-9113795
Node: 25-10113943
Node: 25-11114101
Node: 25-12114262
Node: 25-13114403
Node: 25-14114526
Node: Chapter 26114702
Node: 26-1115258
Node: 26-2115451
Node: 26-3115566
Node: 26-4115745
Node: 26-5115866
Node: 26-6115979
Node: 26-7116102
Node: 26-8116207
Node: 26-9116356
Node: Chapter 27116489
Node: 27-1116908
Node: 27-2117029
Node: 27-3117154
Node: 27-4117277
Node: 27-5117410
Node: 27-6117537
Node: 27-7117672
Node: Chapter 28117819
Node: 28-1118105
Node: 28-2118246
Node: 28-3118361
Node: Chapter 29118502
Node: 29-1118976
Node: 29-2119091
Node: 29-3119232
Node: 29-4119373
Node: 29-5119506
Node: 29-6119629
Node: 29-7119750
Node: 29-8119865
Node: 29-9119992
Node: Chapter 30120119
Node: 30-1120653
Node: 30-2120822
Node: 30-3120945
Node: 30-4121072
Node: 30-5121197
Node: 30-6121336
Node: 30-7121479
Node: 30-8121620
Node: Chapter 31121741
Node: 31-1122123
Node: 31-2122244
Node: 31-3122377
Node: 31-4122488
Node: 31-5122607
Node: Chapter 32122742
Node: 32-1123114
Node: 32-2123255
Node: 32-3123410
Node: 32-4123583
Node: 32-5123720

End Tag Table
