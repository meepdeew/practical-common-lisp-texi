This is pcl.info, produced by makeinfo version 5.2 from pcl.texi.


File: pcl.info,  Node: 26-3,  Next: 26-4,  Prev: 26-2,  Up: Chapter 26

Generating Dynamic Content with AllegroServe
============================================

Publishing entities that generate dynamic content is nearly as simple as
publishing static content.  The functions publish and publish-prefix are
the dynamic analogs of publish-file and publish-directory.  The basic
idea of these two functions is that you publish a function that will be
called to generate the response to a request for either a specific URL
or any URL with a given prefix.  The function will be called with two
arguments: an object representing the request and the published entity.
Most of time you don't need to do anything with the entity object except
to pass it along to a couple macros I'll discuss in a moment.  On the
other hand, you'll use the request object to obtain information
submitted by the browser-query parameters included in the URL or data
posted using an HTML form.

   For a trivial example of using a function to generate dynamic
content, let's write a function that generates a page with a different
random number each time it's requested.

   (defun random-number (request entity) (with-http-response (request
entity :content-type "text/html") (with-http-body (request entity)
(format (request-reply-stream request) "<html>~ 
<head><title>Random</title></head>~  <body>~  <p>Random number: ~d</p>~ 
</body>~  </html>~  " (random 1000))))) The macros with-http-response
and with-http-body are part of AllegroServe.  The former starts the
process of generating an HTTP response and can be used, as here, to
specify things such as the type of content that will be returned.  It
also handles various parts of HTTP such as dealing with
If-Modified-Since requests.  The with-http-body actually sends the HTTP
response headers and then executes its body, which should contain code
that generates the content of the reply.  Within with-http-response but
before the with-http-body, you can add or change HTTP headers to be sent
in the reply.  The function request-reply-stream is also part of
AllegroServe and returns the stream to which you should write output
intended to be sent to the browser.

   As this function shows, you can just use FORMAT to print HTML to the
stream returned by request-reply-stream.  In the next section, I'll show
you more convenient ways to programmatically generate HTML.9

   Now you're ready to publish this function.

   WEB> (publish :path "/random-number" :function 'random-number)
#<COMPUTED-ENTITY  #x7262bab2> As it does in the publish-file function,
the :path argument specifies the path part of the URL that will result
in this function being invoked.  The :function argument specifies either
the name or an actual function object.  Using the name of a function, as
shown here, allows you to redefine the function later without
republishing and have AllegroServe use the new function definition.
After evaluating the call to publish, you can point your browser at
http:// localhost:2001/random-number to get a page with a random number
on it, as shown in Figure 26-3.

   Figure 26-3.  http://localhost:2001/random-number


File: pcl.info,  Node: 26-4,  Next: 26-5,  Prev: 26-3,  Up: Chapter 26

Generating HTML
===============

Although using FORMAT to emit HTML works fine for the simple pages I've
discussed so far, as you start building more elaborate pages it'd be
nice to have a more concise way to generate HTML. Several libraries are
available for generating HTML from an s-expression representation
including one, htmlgen, that's included with AllegroServe.  In this
chapter you'll use a library called FOO,10 which is loosely modeled on
Franz's htmlgen and whose implementation you'll look at in more detail
in Chapters 30 and 31.  For now, however, you just need to know how to
use FOO.

   Generating HTML from within Lisp is quite natural since s-expressions
and HTML are essentially isomorphic.  You can represent HTML elements
with s-expressions by treating each element in HTML as a list "tagged"
with an appropriate first element, such as a keyword symbol of the same
name as the HTML tag.  Thus, the HTML <p>foo</p> is represented by the
s-expression (:p "foo").  Because HTML elements nest the same way lists
in s-expressions do, this scheme extends to more complex HTML. For
instance, this HTML:

   <html> <head> <title>Hello</title> </head> <body> <p>Hello,
world!</p> </body> </html> could be represented with the following
s-expression:

   (:html (:head (:title "Hello")) (:body (:p "Hello, world!")))  HTML
elements with attributes complicate things a bit but not in an
insurmountable way.  FOO supports two ways of including attributes in a
tag.  One is to simply follow the first item of the list with
keyword/value pairs.  The first element that follows a keyword/value
pair that's not itself a keyword symbol marks the beginning of the
element's contents.  Thus, you'd represent this HTML:

   <a href="foo.html">This is a link</a> with the following
s-expression:

   (:a :href "foo.html" "This is a link") The other syntax FOO supports
is to group the tag name and attributes into their own list like this:

   ((:a :href "foo.html") "This is link.")  FOO can use the s-expression
representation of HTML in two ways.  The function emit-html takes an
HTML s-expression and outputs the corresponding HTML.

   WEB> (emit-html '(:html (:head (:title "Hello")) (:body (:p "Hello,
world!"))))  <html> <head> <title>Hello</title> </head> <body> <p>Hello,
world!</p> </body> </html> T However, emit-html isn't always the most
efficient way to generate HTML because its argument must be a complete
s-expression representation of the HTML to be generated.  While it's
easy to build such a representation, it's not always particularly
efficient.  For instance, suppose you wanted to make an HTML page
containing a list of 10,000 random numbers.  You could build the
s-expression using a backquote template and then pass it to emit-html
like this:

   (emit-html '(:html (:head (:title "Random numbers")) (:body (:h1
"Random numbers") (:p ,@(loop repeat 10000 collect (random 1000) collect
" "))))) However, this has to build a tree containing a 10,000-element
list before it can even start emitting HTML, and the whole s-expression
will become garbage as soon as the HTML is emitted.  To avoid this
inefficiency, FOO also provides a macro html, which allows you to embed
bits of Lisp code in the middle of an HTML s-expression.

   Literal values such as strings and numbers in the input to html are
interpolated into the output HTML. Likewise, symbols are treated as
variable references, and code is generated to emit their value at
runtime.  Thus, both of these:

   (html (:p "foo"))

   (let ((x "foo")) (html (:p x))) will emit the following:

   <p>foo</p> List forms that don't start with a keyword symbol are
assumed to be code and are embedded in the generated code.  Any values
the embedded code returns will be ignored, but the code can emit more
HTML by calling html itself.  For instance, to emit the contents of a
list in HTML, you might write this:

   (html (:ul (dolist (item (list 1 2 3)) (html (:li item))))) which
will emit the following HTML:

   <ul> <li>1</li> <li>2</li> <li>3</li> </ul> If you want to emit the
value of a list form, you must wrap it in the pseudotag :print.  Thus,
this expression:

   (html (:p (+ 1 2))) generates this HTML after computing and
discarding the value 3:

   <p></p> To emit the 3, you must write this:

   (html (:p (:print (+ 1 2)))) Or you could compute the value and store
it in a variable outside the call to html like this:

   (let ((x (+ 1 2))) (html (:p x))) Thus, you can use the html macro to
generate the list of random numbers like this:

   (html (:html (:head (:title "Random numbers")) (:body (:h1 "Random
numbers") (:p (loop repeat 10 do (html (:print (random 1000)) " "))))))
The macro version will be quite a bit more efficient than the emit-html
version.  Not only do you never have to generate an s-expression
representing the whole page, also much of the work that emit-html does
at runtime to interpret the s-expression will be done once, when the
macro is expanded, rather than every time the code is run.

   You can control where the output generated by both html and emit-html
is sent with the macro with-html-output, which is part of the FOO
library.  Thus, you can use the with-html-output and html macros from
FOO to rewrite random-number like this:

   (defun random-number (request entity) (with-http-response (request
entity :content-type "text/html") (with-http-body (request entity)
(with-html-output ((request-reply-stream request)) (html (:html (:head
(:title "Random")) (:body (:p "Random number: " (:print (random
1000))))))))))


File: pcl.info,  Node: 26-5,  Next: 26-6,  Prev: 26-4,  Up: Chapter 26

HTML Macros
===========

Another feature of FOO is that it allows you to define HTML "macros"
that can translate arbitrary forms into HTML s-expressions that the html
macro understands.  For instance, suppose you frequently find yourself
writing pages of this form:

   (:html (:head (:title "Some title")) (:body (:h1 "Some title") ...
stuff ...))  You could define an HTML macro to capture that pattern like
this:

   (define-html-macro :standard-page ((&key title) &body body) '(:html
(:head (:title ,title)) (:body (:h1 ,title) ,@body))) Now you can use
the "tag" :standard-page in your s-expression HTML, and it'll be
expanded before being interpreted or compiled.  For instance, the
following:

   (html (:standard-page (:title "Hello") (:p "Hello, world.")))
generates the following HTML:

   <html> <head> <title>Hello</title> </head> <body> <h1>Hello</h1>
<p>Hello, world.</p> </body> </html>


File: pcl.info,  Node: 26-6,  Next: 26-7,  Prev: 26-5,  Up: Chapter 26

Query Parameters
================

Of course, generating HTML output is only half of Web programming.  The
other thing you need to do is get input from the user.  As I discussed
in the "A 30-Second Intro to Server-Side Web Programming" section, when
a browser requests a page from a Web server, it can send query
parameters in the URL and post data, both of which act as input to the
server-side code.

   AllegroServe, like most Web programming frameworks, takes care of
parsing both these sources of input for you.  By the time your published
functions are called, all the key/value pairs from the query string
and/or post data have been decoded and placed into an alist that you can
retrieve from the request object with the function request-query.  The
following function returns a page showing all the query parameters it
receives:

   (defun show-query-params (request entity) (with-http-response
(request entity :content-type "text/html") (with-http-body (request
entity) (with-html-output ((request-reply-stream request)) (html
(:standard-page (:title "Query Parameters") (if (request-query request)
(html (:table :border 1 (loop for (k .  v) in (request-query request) do
(html (:tr (:td k) (:td v)))))) (html (:p "No query
parameters.")))))))))

   (publish :path "/show-query-params" :function 'show-query-params) If
you give your browser a URL with a query string in it like the
following:

   http://localhost:2001/show-query-params?foo=bar&baz=10 you should get
back a page similar to the one shown in Figure 26-4.

   Figure 26-4.  http://localhost:2001/show-query-params?foo=bar&baz=10
To generate some post data, you need an HTML form.  The following
function generates a simple form, which submits its data to
show-query-params:

   (defun simple-form (request entity) (with-http-response (request
entity :content-type "text/html") (with-http-body (request entity) (let
((*html-output* (request-reply-stream request))) (html (:html (:head
(:title "Simple Form")) (:body (:form :method "POST" :action
"/show-query-params" (:table (:tr (:td "Foo") (:td (:input :name "foo"
:size 20))) (:tr (:td "Password") (:td (:input :name "password" :type
"password" :size 20)))) (:p (:input :name "submit" :type "submit" :value
"Okay") (:input ::type "reset" :value "Reset"))))))))))

   (publish :path "/simple-form" :function 'simple-form) Point your
browser to http://localhost:2001/simple-form, and you should see a page
like the one in Figure 26-5.

   If you fill in the form with the "abc" and "def" values, clicking the
Okay button should take you to a page like the one in Figure 26-6.

   Figure 26-5.  http://localhost:2001/simple-form

   Figure 26-6.  Result of submitting the simple form However, most of
the time you won't need to iterate over all the query parameters; you'll
want to pick out individual parameters.  For instance, you might want to
modify random-number so the limit value you pass to RANDOM can be
supplied via a query parameter.  In that case, you use the function
request-query-value, which takes the request object and the name of the
parameter whose value you want and returns the value as a string or NIL
if no such parameter has been supplied.  A parameterizable version of
random-number might look like this:

   (defun random-number (request entity) (with-http-response (request
entity :content-type "text/html") (with-http-body (request entity) (let*
((*html-output* (request-reply-stream request)) (limit-string (or
(request-query-value "limit" request) "")) (limit (or (parse-integer
limit-string :junk-allowed t) 1000))) (html (:html (:head (:title
"Random")) (:body (:p "Random number: " (:print (random limit))))))))))
Because request-query-value can return either NIL or an empty string,
you have to deal with both those cases when parsing the parameter into a
number to pass to RANDOM. You can deal with a NIL value when you bind
limit-string, binding it to "" if there's no "limit" query parameter.
Then you can use the :junk-allowed argument to PARSE-INTEGER to ensure
that it returns either NIL (if it can't parse an integer from the string
given) or an integer.  In the section "A Small Application Framework,"
you'll develop some macros to make it easier to deal with grabbing query
parameters and converting them to various types.


File: pcl.info,  Node: 26-7,  Next: 26-8,  Prev: 26-6,  Up: Chapter 26

Cookies
=======

In AllegroServe you can send a Set-Cookie header that tells the browser
to save a cookie and send it along with subsequent requests by calling
the function set-cookie-header within the body of with-http-response but
before the call to with-http-body.  The first argument to the function
is the request object, and the remaining arguments are keyword arguments
used to set the various properties of the cookie.  The only two you must
pass are the :name and :value arguments, both of which should be
strings.  The other possible arguments that affect the cookie sent to
the browser are :expires, :path, :domain, and :secure.

   Of these, you need to worry only about :expires.  It controls how
long the browser should save the cookie.  If :expires is NIL (the
default), the browser will save the cookie only until it exits.  Other
possible values are :never, which means the cookie should be kept
forever, or a universal time as returned by GET-UNIVERSAL-TIME or
ENCODE-UNIVERSAL-TIME. An :expires of zero tells the client to
immediately discard an existing cookie.11

   After you've set a cookie, you can use the function get-cookie-values
to get an alist containing one name/value pair for each cookie sent by
the browser.  From that alist, you can pick out individual cookie values
using ASSOC and CDR.

   The following function shows the names and values of all the cookies
sent by the browser:

   (defun show-cookies (request entity) (with-http-response (request
entity :content-type "text/html") (with-http-body (request entity)
(with-html-output ((request-reply-stream request)) (html (:standard-page
(:title "Cookies") (if (null (get-cookie-values request)) (html (:p "No
cookies."))  (html (:table (loop for (key .  value) in
(get-cookie-values request) do (html (:tr (:td key) (:td
value)))))))))))))

   (publish :path "/show-cookies" :function 'show-cookies) The first
time you load the page http://localhost:2001/show-cookies it should say
"No cookies" as shown in Figure 26-7 since you haven't set any yet.

   Figure 26-7.  http://localhost:2001/show-cookies with no cookies To
set a cookie, you need another function, such as the following:

   (defun set-cookie (request entity) (with-http-response (request
entity :content-type "text/html") (set-cookie-header request :name
"MyCookie" :value "A cookie value") (with-http-body (request entity)
(with-html-output ((request-reply-stream request)) (html (:standard-page
(:title "Set Cookie") (:p "Cookie set.")  (:p (:a :href "/show-cookies"
"Look at cookie jar."))))))))

   (publish :path "/set-cookie" :function 'set-cookie) If you enter the
URL http://localhost:2001/set-cookie, your browser should display a page
like the one in Figure 26-8.  Additionally, the server will send a
Set-Cookie header with a cookie named "MyCookie" with "A cookie value"
as its value.  If you click the link Look at cookie jar, you'll be taken
to the /show-cookies page where you'll see the new cookie, as shown in
Figure 26-9.  Because you didn't specify an :expires argument, the
browser will continue to send the cookie with each request until you
quit the browser.

   Figure 26-8.  http://localhost:2001/set-cookie

   Figure 26-9.  http://localhost:2001/show-cookies after setting a
cookie


File: pcl.info,  Node: 26-8,  Next: 26-9,  Prev: 26-7,  Up: Chapter 26

A Small Application Framework
=============================

Although AllegroServe provides fairly straightforward access to all the
basic facilities you need to write server-side Web code (access to query
parameters from both the URL's query string and the post data; the
ability to set cookies and retrieve their values; and, of course, the
ability to generate the response sent back to the browser), there's a
fair bit of annoyingly repetitive code.

   For instance, every HTML-generating function you write is going to
take the arguments request and entity and then will contain calls to
with-http-response, with-http-response, and-if you're going to use FOO
to generate HTML-with-html-output.  Then, in functions that need to get
at query parameters, there will be a bunch of calls to
request-query-value and then more code to convert the string returned to
whatever type you actually want.  Finally, you need to remember to
publish the function.

   To reduce the amount of boilerplate you have to write, you can write
a small framework on top of AllegroServe to make it easier to define
functions that handle requests for a particular URL.

   The basic approach will be to define a macro, define-url-function,
that you'll use to define functions that will automatically be published
via publish.  This macro will expand into a DEFUN that contains the
appropriate boilerplate as well as code to publish the function under a
URL of the same name.  It'll also take care of generating code to
extract values from query parameters and cookies and to bind them to
variables declared in the function's parameter list.  Thus, the basic
form of a define-url-function definition is this:

   (define-url-function name (request query-parameter*) body) where the
body is the code to emit the HTML of the page.  It'll be wrapped in a
call to FOO's html macro, so for simple pages it might contain nothing
but s-expression HTML.

   Within the body, the query parameter variables will be bound to
values of query parameters with the same name or from a cookie.  In the
simplest case, a query parameter's value will be the string taken from
the query parameter or post data field of the same name.  If the query
parameter is specified with a list, you can also specify an automatic
type conversion, a default value, and whether to look for and save the
value of the parameter in a cookie.  The complete syntax for a
query-parameter is as follows:

   name | (name type [default-value] [stickiness]) The type must be a
name recognized by define-url-function.  I'll discuss in a moment how to
define new types.  The default-value must be a value of the given type.
Finally, stickiness, if supplied, indicates that the parameter's value
should be taken from an appropriately named cookie if no query parameter
is supplied and that a Set-Cookie header should be sent in the response
that saves the value in the cookie of the same name.  Thus, a sticky
parameter, after being explicitly supplied a value via a query
parameter, will keep that value on subsequent requests of the page even
when no query parameter is supplied.

   The name of the cookie used depends on the value of stickiness: with
a value of :global, the cookie will be named the same as the parameter.
Thus, different functions that use globally sticky parameters with the
same name will share the value.  If stickiness is :package, then the
cookie name is constructed from the name of the parameter and the
package of the function's name; this allows functions in the same
package to share values but not have to worry about stomping on
parameters of functions in other packages.  Finally, a parameter with a
stickiness value of :local will use a cookie made from the name of the
parameter, the package of the function name, and the function name,
making it unique to that function.

   For instance, you can use define-url-function to replace the previous
eleven-line definition of random-page with this five-line version:

   (define-url-function random-number (request (limit integer 1000))
(:html (:head (:title "Random")) (:body (:p "Random number: " (:print
(random limit)))))) If you wanted the limit argument to be sticky, you
could change the limit declaration to (limit integer 1000 :local).


File: pcl.info,  Node: 26-9,  Next: Chapter 27,  Prev: 26-8,  Up: Chapter 26

The Implementation
==================

I'll explain the implementation of define-url-function from the top
down.  The macro itself looks like this:

   (defmacro define-url-function (name (request &rest params) &body
body) (with-gensyms (entity) (let ((params (mapcar #'normalize-param
params))) '(progn (defun ,name (,request ,entity) (with-http-response
(,request ,entity :content-type "text/html") (let* (,@(param-bindings
name request params)) ,@(set-cookies-code name request params)
(with-http-body (,request ,entity) (with-html-output
((request-reply-stream ,request)) (html ,@body)))))) (publish :path
,(format nil "/~(~a~)" name) :function ',name))))) Let's take it bit by
bit, starting with the first few lines.

   (defmacro define-url-function (name (request &rest params) &body
body) (with-gensyms (entity) (let ((params (mapcar #'normalize-param
params))) Up to here you're just getting ready to generate code.  You
GENSYM a symbol to use later as the name of the entity parameter in the
DEFUN. Then you normalize the parameters, converting plain symbols to
list form using this function:

   (defun normalize-param (param) (etypecase param (list param) (symbol
'(,param string nil nil)))) In other words, declaring a parameter with
just a symbol is the same as declaring a nonsticky, string parameter
with no default value.

   Then comes the PROGN. You must expand into a PROGN because you need
to generate code to do two things: define a function with DEFUN and call
publish.  You should define the function first so if there's an error in
the definition, the function won't be published.  The first two lines of
the DEFUN are just boilerplate.

   (defun ,name (,request ,entity) (with-http-response (,request ,entity
:content-type "text/html") Now you do the real work.  The following two
lines generate the bindings for the parameters specified in
define-url-function other than request and the code that calls
set-cookie-header for the sticky parameters.  Of course, the real work
is done by helper functions that you'll look at in a moment.12

   (let* (,@(param-bindings name request params)) ,@(set-cookies-code
name request params) The rest is just more boilerplate, putting the body
from the define-url-function definition in the appropriate context of
with-http-body, with-html-output, and html macros.  Then comes the call
to publish.

   (publish :path ,(format nil "/~(~a~)" name) :function ',name) The
expression (format nil "/~(~a~)" name) is evaluated at macro expansion
time, generating a string consisting of /, followed by an all-lowercase
version of the name of the function you're about to define.  That string
becomes the :path argument to publish, while the function name is
interpolated as the :function argument.

   Now let's look at the helper functions used to generate the DEFUN
form.  To generate parameter bindings, you need to loop over the params
and collect a snippet of code for each one, generated by param-binding.
That snippet will be a list containing the name of the variable to bind
and the code that will compute the value of that variable.  The exact
form of code used to compute the value will depend on the type of the
parameter, whether it's sticky, and the default value, if any.  Because
you already normalized the params, you can use DESTRUCTURING-BIND to
take them apart in param-binding.

   (defun param-bindings (function-name request params) (loop for param
in params collect (param-binding function-name request param)))

   (defun param-binding (function-name request param)
(destructuring-bind (name type &optional default sticky) param (let
((query-name (symbol->query-name name)) (cookie-name
(symbol->cookie-name function-name name sticky))) '(,name (or
(string->type ',type (request-query-value ,query-name ,request)) ,@(if
cookie-name (list '(string->type ',type (get-cookie-value ,request
,cookie-name)))) ,default))))) The function string->type, which you use
to convert strings obtained from the query parameters and cookies to the
desired type, is a generic function with the following signature:

   (defgeneric string->type (type value)) To make a particular name
usable as a type name for a query parameter, you just need to define a
method on string->type.  You'll need to define at least a method
specialized on the symbol string since that's the default type.  Of
course, that's pretty easy.  Since browsers sometimes submit forms with
empty strings to indicate no value was supplied for a particular value,
you'll want to convert an empty string to NIL as this method does:

   (defmethod string->type ((type (eql 'string)) value) (and (plusp
(length value)) value)) You can add conversions for other types needed
by your application.  For instance, to make integer usable as a query
parameter type so you can handle the limit parameter of random-page, you
might define this method:

   (defmethod string->type ((type (eql 'integer)) value) (parse-integer
(or value "") :junk-allowed t)) Another helper function used in the code
generated by param-binding is get-cookie-value, which is just a bit of
sugar around the get-cookie-values function provided by AllegroServe.
It looks like this:

   (defun get-cookie-value (request name) (cdr (assoc name
(get-cookie-values request) :test #'string=))) The functions that
compute the query parameter and cookies names are similarly
straightforward.

   (defun symbol->query-name (sym) (string-downcase sym))

   (defun symbol->cookie-name (function-name sym sticky) (let
((package-name (package-name (symbol-package function-name)))) (when
sticky (ecase sticky (:global (string-downcase sym)) (:package (format
nil "~(~a:~a~)" package-name sym)) (:local (format nil "~(~a:~a:~a~)"
package-name function-name sym)))))) To generate the code that sets
cookies for sticky parameters, you again loop over the list of
parameters, this time collecting a snippet of code for each sticky
param.  You can use the when and collect it LOOP forms to collect only
the non-NIL values returned by set-cookie-code.

   (defun set-cookies-code (function-name request params) (loop for
param in params when (set-cookie-code function-name request param)
collect it))

   (defun set-cookie-code (function-name request param)
(destructuring-bind (name type &optional default sticky) param (declare
(ignore type default)) (if sticky '(when ,name (set-cookie-header
,request :name ,(symbol->cookie-name function-name name sticky) :value
(princ-to-string ,name)))))) One of the advantages of defining macros in
terms of helper functions like this is that it's easy to make sure the
individual bits of code you're generating look right.  For instance, you
can check that the following set-cookie-code:

   (set-cookie-code 'foo 'request '(x integer 20 :local)) generates
something like this:

   (WHEN X (SET-COOKIE-HEADER REQUEST :NAME "com.gigamonkeys.web:foo:x"
:VALUE (PRINC-TO-STRING X))) Assuming this code will occur in a context
where x is the name of a variable, this looks good.

   Once again, macros have allowed you to distill the code you need to
write down to its essence-in this case, the data you want to extract
from the request and the HTML you want to generate.  That said, this
framework isn't meant to be the be-all and end-all of Web application
frameworks-it's just a little sugar to make it a bit easier to write
simple apps like the one you'll write in Chapter 29.

   But before you can get to that, you need to write the guts of the
application for which the Chapter 29 application will be the user
interface.  You'll start in the next chapter with a souped-up version of
the database you wrote in Chapter 3, this time to keep track of ID3 data
extracted from MP3 files.


File: pcl.info,  Node: Chapter 27,  Next: Chapter 28,  Prev: Chapter 26,  Up: Top

27. Practical: An MP3 Database
==============================

In this chapter you'll revisit the idea first explored in Chapter 3 of
building an in-memory database out of basic Lisp data structures.  This
time your goal is to hold information that you'll extract from a
collection of MP3 files using the ID3v2 library from Chapter 25.  You'll
then use this database in Chapters 28 and 29 as part of a Web-based
streaming MP3 server.  Of course, this time around you can use some of
the language features you've learned since Chapter 3 to build a more
sophisticated version.

* Menu:

* 27-1::       The Database
* 27-2::       Defining a Schema
* 27-3::       Inserting Values
* 27-4::       Querying the Database
* 27-5::       Matching Functions
* 27-6::       Getting at the Results
* 27-7::       Other Database Operations


File: pcl.info,  Node: 27-1,  Next: 27-2,  Prev: Chapter 27,  Up: Chapter 27

The Database
============

The main problem with the database in Chapter 3 is that there's only one
table, the list stored in the variable *db*.  Another is that the code
doesn't know anything about what type of values are stored in different
columns.  In Chapter 3 you got away with that by using the fairly
general-purpose EQUAL method to compare column values when selecting
rows from the database, but you would've been in trouble if you had
wanted to store values that couldn't be compared with EQUAL or if you
had wanted to sort the rows in the database since there's no ordering
function that's as general as EQUAL.

   This time you'll solve both problems by defining a class, table, to
represent individual database tables.  Each table instance will consist
of two slots-one to hold the table's data and another to hold
information about the columns in the table that database operations will
be able to use.  The class looks like this:

   (defclass table () ((rows :accessor rows :initarg :rows :initform
(make-rows)) (schema :accessor schema :initarg :schema))) As in Chapter
3, you can represent the individual rows with plists, but this time
around you'll create an abstraction that will make that an
implementation detail you can change later without too much trouble.
And this time you'll store the rows in a vector rather than a list since
certain operations that you'll want to support, such as random access to
rows by a numeric index and the ability to sort a table, can be more
efficiently implemented with vectors.

   The function make-rows used to initialize the rows slot can be a
simple wrapper around MAKE-ARRAY that builds an empty, adjustable,vector
with a fill pointer.

   (defparameter *default-table-size* 100)

   (defun make-rows (&optional (size *default-table-size*)) (make-array
size :adjustable t :fill-pointer 0)) To represent a table's schema, you
need to define another class, column, each instance of which will
contain information about one column in the table: its name, how to
compare values in the column for equality and ordering, a default value,
and a function that will be used to normalize the column's values when
inserting data into the table and when querying the table.  The schema
slot will hold a list of column objects.  The class definition looks
like this:

   (defclass column () ((name :reader name :initarg :name)

   (equality-predicate :reader equality-predicate :initarg
:equality-predicate)

   (comparator :reader comparator :initarg :comparator)

   (default-value :reader default-value :initarg :default-value
:initform nil)

   (value-normalizer :reader value-normalizer :initarg :value-normalizer
:initform #'(lambda (v column) (declare (ignore column)) v)))) The
equality-predicate and comparator slots of a column object hold
functions used to compare values from the given column for equivalence
and ordering.  Thus, a column containing string values might have
STRING= as its equality-predicate and STRING< as its comparator, while a
column containing numbers might have = and <.

   The default-value and value-normalizer slots are used when inserting
rows into the database and, in the case of value-normalizer, when
querying the database.  When you insert a row into the database, if no
value is provided for a particular column, you can use the value stored
in the column's default-value slot.  Then the value-defaulted or
otherwise-is normalized by passing it and the column object to the
function stored in the value-normalizer slot.  You pass the column in
case the value-normalizer function needs to use some data associated
with the column object.  (You'll see an example of this in the next
section.)  You should also normalize values passed in queries before
comparing them with values in the database.

   Thus, the value-normalizer's responsibility is primarily to return a
value that can be safely and correctly passed to the equality-predicate
and comparator functions.  If the value-normalizer can't figure out an
appropriate value to return, it can signal an error.

   The other reason to normalize values before you store them in the
database is to save both memory and CPU cycles.  For instance, if you
have a column that's going to contain string values but the number of
distinct strings that will be stored in the column is small-for
instance, the genre column in the MP3 database-you can save space and
speed by using the value-normalizer to intern the strings (translate all
STRING= values to a single string object).  Thus, you'll need only as
many strings as there are distinct values, regardless of how many rows
are in the table, and you can use EQL to compare column values rather
than the slower STRING=.1


File: pcl.info,  Node: 27-2,  Next: 27-3,  Prev: 27-1,  Up: Chapter 27

Defining a Schema
=================

Thus, to make an instance of table, you need to build a list of column
objects.  You could build the list by hand, using LIST and
MAKE-INSTANCE. But you'll soon notice that you're frequently making a
lot column objects with the same comparator and equality-predicate
combinations.  This is because the combination of a comparator and
equality predicate essentially defines a column type.  It'd be nice if
there was a way to give those types names that would allow you to say
simply that a given column is a string column, rather than having to
specify STRING< as its comparator and STRING= as its equality predicate.
One way is to define a generic function, make-column, like this:

   (defgeneric make-column (name type &optional default-value)) Now you
can implement methods on this generic function that specialize on type
with EQL specializers and return column objects with the slots filled in
with appropriate values.  Here's the generic function and methods that
define column types for the type names string and number:

   (defmethod make-column (name (type (eql 'string)) &optional
default-value) (make-instance 'column :name name :comparator #'string<
:equality-predicate #'string= :default-value default-value
:value-normalizer #'not-nullable))

   (defmethod make-column (name (type (eql 'number)) &optional
default-value) (make-instance 'column :name name :comparator #'<
:equality-predicate #'= :default-value default-value)) The following
function, not-nullable, used as the value-normalizer for string columns,
simply returns the value it's given unless the value is NIL, in which
case it signals an error:

   (defun not-nullable (value column) (or value (error "Column ~a can't
be null" (name column)))) This is important because STRING< and STRING=
will signal an error if called on NIL; it's better to catch bad values
before they go into the table rather than when you try to use them.2

   Another column type you'll need for the MP3 database is an
interned-string whose values are interned as discussed previously.
Since you need a hash table in which to intern values, you should define
a subclass of column, interned-values-column, that adds a slot whose
value is the hash table you use to intern.

   To implement the actual interning, you'll also need to provide an
:initform for value-normalizer of a function that interns the value in
the column's interned-values hash table.  And because one of the main
reasons to intern values is to allow you to use EQL as the equality
predicate, you should also add an :initform for the equality-predicate
of #'eql.

   (defclass interned-values-column (column) ((interned-values :reader
interned-values :initform (make-hash-table :test #'equal))
(equality-predicate :initform #'eql) (value-normalizer :initform
#'intern-for-column)))

   (defun intern-for-column (value column) (let ((hash (interned-values
column))) (or (gethash (not-nullable value column) hash) (setf (gethash
value hash) value)))) You can then define a make-column method
specialized on the name interned-string that returns an instance of
interned-values-column.

   (defmethod make-column (name (type (eql 'interned-string)) &optional
default-value) (make-instance 'interned-values-column :name name
:comparator #'string< :default-value default-value)) With these methods
defined on make-column, you can now define a function, make-schema, that
builds a list of column objects from a list of column specifications
consisting of a column name, a column type name, and, optionally, a
default value.

   (defun make-schema (spec) (mapcar #'(lambda (column-spec) (apply
#'make-column column-spec)) spec)) For instance, you can define the
schema for the table you'll use to store data extracted from MP3s like
this:

   (defparameter *mp3-schema* (make-schema '((:file string) (:genre
interned-string "Unknown") (:artist interned-string "Unknown") (:album
interned-string "Unknown") (:song string) (:track number 0) (:year
number 0) (:id3-size number)))) To make an actual table for holding
information about MP3s, you pass *mp3-schema* as the :schema initarg to
MAKE-INSTANCE.

   (defparameter *mp3s* (make-instance 'table :schema *mp3-schema*))


File: pcl.info,  Node: 27-3,  Next: 27-4,  Prev: 27-2,  Up: Chapter 27

Inserting Values
================

Now you're ready to define your first table operation, insert-row, which
takes a plist of names and values and a table and adds a row to the
table containing the given values.  The bulk of the work is done in a
helper function, normalize-row, that builds a plist with a defaulted,
normalized value for each column, using the values from names-and-values
if available and the default-value for the column if not.

   (defun insert-row (names-and-values table) (vector-push-extend
(normalize-row names-and-values (schema table)) (rows table)))

   (defun normalize-row (names-and-values schema) (loop for column in
schema for name = (name column) for value = (or (getf names-and-values
name) (default-value column)) collect name collect (normalize-for-column
value column))) It's worth defining a separate helper function,
normalize-for-column, that takes a value and a column object and returns
the normalized value because you'll need to perform the same
normalization on query arguments.

   (defun normalize-for-column (value column) (funcall (value-normalizer
column) value column)) Now you're ready to combine this database code
with code from previous chapters to build a database of data extracted
from MP3 files.  You can define a function, file->row, that uses
read-id3 from the ID3v2 library to extract an ID3 tag from a file and
turns it into a plist that you can pass to insert-row.

   (defun file->row (file) (let ((id3 (read-id3 file))) (list :file
(namestring (truename file)) :genre (translated-genre id3) :artist
(artist id3) :album (album id3) :song (song id3) :track (parse-track
(track id3)) :year (parse-year (year id3)) :id3-size (size id3)))) You
don't have to worry about normalizing the values since insert-row takes
care of that for you.  You do, however, have to convert the string
values returned by the track and year into numbers.  The track number in
an ID3 tag is sometimes stored as the ASCII representation of the track
number and sometimes as a number followed by a slash followed by the
total number of tracks on the album.  Since you care only about the
actual track number, you should use the :end argument to PARSE-INTEGER
to specify that it should parse only up to the slash, if any.3

   (defun parse-track (track) (when track (parse-integer track :end
(position #\/ track))))

   (defun parse-year (year) (when year (parse-integer year))) Finally,
you can put all these functions together, along with walk-directory from
the portable pathnames library and mp3-p from the ID3v2 library, to
define a function that loads an MP3 database with data extracted from
all the MP3 files it can find under a given directory.

   (defun load-database (dir db) (let ((count 0)) (walk-directory dir
#'(lambda (file) (princ #\.)  (incf count) (insert-row (file->row file)
db)) :test #'mp3-p) (format t "~&Loaded ~d files into database."
count)))


File: pcl.info,  Node: 27-4,  Next: 27-5,  Prev: 27-3,  Up: Chapter 27

Querying the Database
=====================

Once you've loaded your database with data, you'll need a way to query
it.  For the MP3 application you'll need a slightly more sophisticated
query function than you wrote in Chapter 3.  This time around you want
not only to be able to select rows matching particular criteria but also
to limit the results to particular columns, to limit the results to
unique rows, and perhaps to sort the rows by particular columns.  In
keeping with the spirit of relational database theory, the result of a
query will be a new table object containing the desired rows and
columns.

   The query function you'll write, select, is loosely modeled on the
SELECT statement from Structured Query Language (SQL). It'll take five
keyword parameters: :from, :columns, :where, :distinct, and :order-by.
The :from argument is the table object you want to query.  The :columns
argument specifies which columns should be included in the result.  The
value should be a list of column names, a single column name, or a T,
the default, meaning return all columns.  The :where argument, if
provided, should be a function that accepts a row and returns true if it
should be included in the results.  In a moment, you'll write two
functions, matching and in, that return functions appropriate for use as
:where arguments.  The :order-by argument, if supplied, should be a list
of column names; the results will be sorted by the named columns.  As
with the :columns argument, you can specify a single column using just
the name, which is equivalent to a one-item list containing the same
name.  Finally, the :distinct argument is a boolean that says whether to
eliminate duplicate rows from the results.  The default value for
:distinct is NIL.

   Here are some examples of using select:

   ;; Select all rows where the :artist column is "Green Day" (select
:from *mp3s* :where (matching *mp3s* :artist "Green Day"))

   ;; Select a sorted list of artists with songs in the genre "Rock"
(select :columns :artist :from *mp3s* :where (matching *mp3s* :genre
"Rock") :distinct t :order-by :artist) The implementation of select with
its immediate helper functions looks like this:

   (defun select (&key (columns t) from where distinct order-by) (let
((rows (rows from)) (schema (schema from)))

   (when where (setf rows (restrict-rows rows where)))

   (unless (eql columns 't) (setf schema (extract-schema (mklist
columns) schema)) (setf rows (project-columns rows schema)))

   (when distinct (setf rows (distinct-rows rows schema)))

   (when order-by (setf rows (sorted-rows rows schema (mklist
order-by))))

   (make-instance 'table :rows rows :schema schema)))

   (defun mklist (thing) (if (listp thing) thing (list thing)))

   (defun extract-schema (column-names schema) (loop for c in
column-names collect (find-column c schema)))

   (defun find-column (column-name schema) (or (find column-name schema
:key #'name) (error "No column: ~a in schema: ~a" column-name schema)))

   (defun restrict-rows (rows where) (remove-if-not where rows))

   (defun project-columns (rows schema) (map 'vector (extractor schema)
rows))

   (defun distinct-rows (rows schema) (remove-duplicates rows :test
(row-equality-tester schema)))

   (defun sorted-rows (rows schema order-by) (sort (copy-seq rows)
(row-comparator order-by schema))) Of course, the really interesting
part of select is how you implement the functions extractor,
row-equality-tester, and row-comparator.

   As you can tell by how they're used, each of these functions must
return a function.  For instance, project-columns uses the value
returned by extractor as the function argument to MAP. Since the purpose
of project-columns is to return a set of rows with only certain column
values, you can infer that extractor returns a function that takes a row
as an argument and returns a new row containing only the columns
specified in the schema it's passed.  Here's how you can implement it:

   (defun extractor (schema) (let ((names (mapcar #'name schema)))
#'(lambda (row) (loop for c in names collect c collect (getf row c)))))
Note how you can do the work of extracting the names from the schema
outside the body of the closure: since the closure will be called many
times, you want it to do as little work as possible each time it's
called.

   The functions row-equality-tester and row-comparator are implemented
in a similar way.  To decide whether two rows are equivalent, you need
to apply the appropriate equality predicate for each column to the
appropriate column values.  Recall from Chapter 22 that the LOOP clause
always will return NIL as soon as a pair of values fails their test or
will cause the LOOP to return T.

   (defun row-equality-tester (schema) (let ((names (mapcar #'name
schema)) (tests (mapcar #'equality-predicate schema))) #'(lambda (a b)
(loop for name in names and test in tests always (funcall test (getf a
name) (getf b name)))))) Ordering two rows is a bit more complex.  In
Lisp, comparator functions return true if their first argument should be
sorted ahead of the second and NIL otherwise.  Thus, a NIL can mean that
the second argument should be sorted ahead of the first or that they're
equivalent.  You want your row comparators to behave the same way:
return T if the first row should be sorted ahead of the second and NIL
otherwise.

   Thus, to compare two rows, you should compare the values from the
columns you're sorting by, in order, using the appropriate comparator
for each column.  First call the comparator with the value from the
first row as the first argument.  If the comparator returns true, that
means the first row should definitely be sorted ahead of the second row,
so you can immediately return T.

   But if the column comparator returns NIL, then you need to determine
whether that's because the second value should sort ahead of the first
value or because they're equivalent.  So you should call the comparator
again with the arguments reversed.  If the comparator returns true this
time, it means the second column value sorts ahead of the first and thus
the second row ahead of the first row, so you can return NIL
immediately.  Otherwise, the column values are equivalent, and you need
to move onto the next column.  If you get through all the columns
without one row's value ever winning the comparison, then the rows are
equivalent, and you return NIL. A function that implements this
algorithm looks like this:

   (defun row-comparator (column-names schema) (let ((comparators
(mapcar #'comparator (extract-schema column-names schema)))) #'(lambda
(a b) (loop for name in column-names for comparator in comparators for
a-value = (getf a name) for b-value = (getf b name) when (funcall
comparator a-value b-value) return t when (funcall comparator b-value
a-value) return nil finally (return nil)))))


File: pcl.info,  Node: 27-5,  Next: 27-6,  Prev: 27-4,  Up: Chapter 27

Matching Functions
==================

The :where argument to select can be any function that takes a row
object and returns true if it should be included in the results.  In
practice, however, you'll rarely need the full power of arbitrary code
to express query criteria.  So you should provide two functions,
matching and in, that will build query functions that allow you to
express the common kinds of queries and that take care of using the
proper equality predicates and value normalizers for each column.

   The workhouse query-function constructor will be matching, which
returns a function that will match rows with specific column values.
You saw how it was used in the earlier examples of select.  For
instance, this call to matching:

   (matching *mp3s* :artist "Green Day") returns a function that matches
rows whose :artist value is "Green Day".  You can also pass multiple
names and values; the returned function matches when all the columns
match.  For example, the following returns a closure that matches rows
where the artist is "Green Day" and the album is "American Idiot":

   (matching *mp3s* :artist "Green Day" :album "American Idiot") You
have to pass matching the table object because it needs access to the
table's schema in order to get at the equality predicates and value
normalizer functions for the columns it matches against.

   You build up the function returned by matching out of smaller
functions, each responsible for matching one column's value.  To build
these functions, you should define a function, column-matcher, that
takes a column object and an unnormalized value you want to match and
returns a function that accepts a single row and returns true when the
value of the given column in the row matches the normalized version of
the given value.

   (defun column-matcher (column value) (let ((name (name column))
(predicate (equality-predicate column)) (normalized
(normalize-for-column value column))) #'(lambda (row) (funcall predicate
(getf row name) normalized)))) You then build a list of column-matching
functions for the names and values you care about with the following
function, column-matchers:

   (defun column-matchers (schema names-and-values) (loop for (name
value) on names-and-values by #'cddr when value collect (column-matcher
(find-column name schema) value))) Now you can implement matching.
Again, note that you do as much work as possible outside the closure in
order to do it only once rather than once per row in the table.

   (defun matching (table &rest names-and-values) "Build a where
function that matches rows with the given column values."  (let
((matchers (column-matchers (schema table) names-and-values))) #'(lambda
(row) (every #'(lambda (matcher) (funcall matcher row)) matchers))))
This function is a bit of a twisty maze of closures, but it's worth
contemplating for a moment to get a flavor of the possibilities of
programming with functions as first-class objects.

   The job of matching is to return a function that will be invoked on
each row in a table to determine whether it should be included in the
new table.  So, matching returns a closure with one parameter, row.

   Now recall that the function EVERY takes a predicate function as its
first argument and returns true if, and only if, that function returns
true each time it's applied to an element of the list passed as EVERY's
second argument.  However, in this case, the list you pass to EVERY is
itself a list of functions, the column matchers.  What you want to know
is that every column matcher, when invoked on the row you're currently
testing, returns true.  So, as the predicate argument to EVERY, you pass
yet another closure that FUNCALLs the column matcher, passing it the
row.

   Another matching function that you'll occasionally find useful is in,
which returns a function that matches rows where a particular column is
in a given set of values.  You'll define in to take two arguments: a
column name and a table that contains the values you want to match.  For
instance, suppose you wanted to find all the songs in the MP3 database
that have names the same as a song performed by the Dixie Chicks.  You
can write that where clause using in and a subselect like this:4

   (select :columns '(:artist :song) :from *mp3s* :where (in :song
(select :columns :song :from *mp3s* :where (matching *mp3s* :artist
"Dixie Chicks")))) Although the queries are more complex, the definition
of in is much simpler than that of matching.

   (defun in (column-name table) (let ((test (equality-predicate
(find-column column-name (schema table)))) (values (map 'list #'(lambda
(r) (getf r column-name)) (rows table)))) #'(lambda (row) (member (getf
row column-name) values :test test))))


File: pcl.info,  Node: 27-6,  Next: 27-7,  Prev: 27-5,  Up: Chapter 27

Getting at the Results
======================

Since select returns another table, you need to think a bit about how
you want to get at the individual row and column values in a table.  If
you're sure you'll never want to change the way you represent the data
in a table, you can just make the structure of a table part of the
API-that table has a slot rows that's a vector of plists-and use all the
normal Common Lisp functions for manipulating vectors and plists to get
at the values in the table.  But that representation is really an
internal detail that you might want to change.  Also, you don't
necessarily want other code manipulating the data structures
directly-for instance, you don't want anyone to use SETF to put an
unnormalized column value into a row.  So it might be a good idea to
define a few abstractions that provide the operations you want to
support.  Then if you decide to change the internal representation
later, you'll need to change only the implementation of these functions
and macros.  And while Common Lisp doesn't enable you to absolutely
prevent folks from getting at "internal" data, by providing an official
API you at least make it clear where the boundary is.

   Probably the most common thing you'll need to do with the results of
a query is to iterate over the individual rows and extract specific
column values.  So you need to provide a way to do both those things
without touching the rows vector directly or using GETF to get at the
column values within a row.

   For now these operations are trivial to implement; they're merely
wrappers around the code you'd write if you didn't have these
abstractions.  You can provide two ways to iterate over the rows of a
table: a macro do-rows, which provides a basic looping construct, and a
function map-rows, which builds a list containing the results of
applying a function to each row in the table.5

   (defmacro do-rows ((row table) &body body) '(loop for ,row across
(rows ,table) do ,@body))

   (defun map-rows (fn table) (loop for row across (rows table) collect
(funcall fn row))) To get at individual column values within a row, you
should provide a function, column-value, that takes a row and a column
name and returns the appropriate value.  Again, it's a trivial wrapper
around the code you'd write otherwise.  But if you change the internal
representation of a table later, users of column-value needn't be any
the wiser.

   (defun column-value (row column-name) (getf row column-name)) While
column-value is a sufficient abstraction for getting at column values,
you'll often want to get at the values of multiple columns at once.  So
you can provide a bit of syntactic sugar, a macro, with-column-values,
that binds a set of variables to the values extracted from a row using
the corresponding keyword names.  Thus, instead of writing this:

   (do-rows (row table) (let ((song (column-value row :song)) (artist
(column-value row :artist)) (album (column-value row :album))) (format t
"~a by ~a from ~a~%" song artist album))) you can simply write the
following:

   (do-rows (row table) (with-column-values (song artist album) row
(format t "~a by ~a from ~a~%" song artist album))) Again, the actual
implementation isn't complicated if you use the once-only macro from
Chapter 8.

   (defmacro with-column-values ((&rest vars) row &body body) (once-only
(row) '(let ,(column-bindings vars row) ,@body)))

   (defun column-bindings (vars row) (loop for v in vars collect '(,v
(column-value ,row ,(as-keyword v)))))

   (defun as-keyword (symbol) (intern (symbol-name symbol) :keyword))
Finally, you should provide abstractions for getting at the number of
rows in a table and for accessing a specific row by numeric index.

   (defun table-size (table) (length (rows table)))

   (defun nth-row (n table) (aref (rows table) n))


File: pcl.info,  Node: 27-7,  Next: Chapter 28,  Prev: 27-6,  Up: Chapter 27

Other Database Operations
=========================

Finally, you'll implement a few other database operations that you'll
need in Chapter 29.  The first two are analogs of the SQL DELETE
statement.  The function delete-rows is used to delete rows from a table
that match particular criteria.  Like select, it takes :from and :where
keyword arguments.  Unlike select, it doesn't return a new table-it
actually modifies the table passed as the :from argument.

   (defun delete-rows (&key from where) (loop with rows = (rows from)
with store-idx = 0 for read-idx from 0 for row across rows do (setf
(aref rows read-idx) nil) unless (funcall where row) do (setf (aref rows
store-idx) row) (incf store-idx) finally (setf (fill-pointer rows)
store-idx))) In the interest of efficiency, you might want to provide a
separate function for deleting all the rows from a table.

   (defun delete-all-rows (table) (setf (rows table) (make-rows
*default-table-size*))) The remaining table operations don't really map
to normal relational database operations but will be useful in the MP3
browser application.  The first is a function to sort the rows of a
table in place.

   (defun sort-rows (table &rest column-names) (setf (rows table) (sort
(rows table) (row-comparator column-names (schema table)))) table) On
the flip side, in the MP3 browser application, you'll need a function
that shuffles a table's rows in place using the function nshuffle-vector
from Chapter 23.

   (defun shuffle-table (table) (nshuffle-vector (rows table)) table)
And finally, again for the purposes of the MP3 browser, you should
provide a function that selects n random rows, returning the results as
a new table.  It also uses nshuffle-vector along with a version of
random-sample based on Algorithm S from Donald Knuth's The Art of
Computer Programming, Volume 2: Seminumerical Algorithms, Third Edition
(Addison-Wesley, 1998) that I discussed in Chapter 20.

   (defun random-selection (table n) (make-instance 'table :schema
(schema table) :rows (nshuffle-vector (random-sample (rows table) n))))

   (defun random-sample (vector n) "Based on Algorithm S from Knuth.
TAOCP, vol.  2.  p.  142" (loop with selected = (make-array n
:fill-pointer 0) for idx from 0 do (loop with to-select = (- n (length
selected)) for remaining = (- (length vector) idx) while (>= (*
remaining (random 1.0)) to-select) do (incf idx)) (vector-push (aref
vector idx) selected) when (= (length selected) n) return selected))
With this code you'll be ready, in Chapter 29, to build a Web interface
for browsing a collection of MP3 files.  But before you get to that, you
need to implement the part of the server that streams MP3s using the
Shoutcast protocol, which is the topic of the next chapter.


File: pcl.info,  Node: Chapter 28,  Next: Chapter 29,  Prev: Chapter 27,  Up: Top

28. Practical: A Shoutcast Server
=================================

In this chapter you'll develop another important part of what will
eventually be a Web-based application for streaming MP3s, namely, the
server that implements the Shoutcast protocol for actually streaming
MP3s to clients such as iTunes, XMMS,1 or Winamp.

* Menu:

* 28-1::       The Shoutcast Protocol
* 28-2::       Song Sources
* 28-3::       Implementing Shoutcast


File: pcl.info,  Node: 28-1,  Next: 28-2,  Prev: Chapter 28,  Up: Chapter 28

The Shoutcast Protocol
======================

The Shoutcast protocol was invented by the folks at Nullsoft, the makers
of the Winamp MP3 software.  It was designed to support Internet audio
broadcasting-Shoutcast DJs send audio data from their personal computers
to a central Shoutcast server that then turns around and streams it out
to any connected listeners.

   The server you'll build is actually only half a true Shoutcast
server-you'll use the protocol that Shoutcast servers use to stream MP3s
to listeners, but your server will be able to serve only songs already
stored on the file system of the computer where the server is running.

   You need to worry about only two parts of the Shoutcast protocol: the
request that a client makes in order to start receiving a stream and the
format of the response, including the mechanism by which metadata about
what song is currently playing is embedded in the stream.

   The initial request from the MP3 client to the Shoutcast server is
formatted as a normal HTTP request.  In response, the Shoutcast server
sends an ICY response that looks like an HTTP response except with the
string "ICY"2 in place of the normal HTTP version string and with
different headers.  After sending the headers and a blank line, the
server streams a potentially endless amount of MP3 data.

   The only tricky thing about the Shoutcast protocol is the way
metadata about the songs being streamed is embedded in the data sent to
the client.  The problem facing the Shoutcast designers was to provide a
way for the Shoutcast server to communicate new title information to the
client each time it started playing a new song so the client could
display it in its UI. (Recall from Chapter 25 that the MP3 format
doesn't make any provision for encoding metadata.)  While one of the
design goals of ID3v2 had been to make it better suited for use when
streaming MP3s, the Nullsoft folks decided to go their own route and
invent a new scheme that's fairly easy to implement on both the client
side and the server side.  That, of course, was ideal for them since
they were also the authors of their own MP3 client.

   Their scheme was to simply ignore the structure of MP3 data and embed
a chunk of self-delimiting metadata every n bytes.  The client would
then be responsible for stripping out this metadata so it wasn't treated
as MP3 data.  Since metadata sent to a client that isn't ready for it
will cause glitches in the sound, the server is supposed to send
metadata only if the client's original request contains a special
Icy-Metadata header.  And in order for the client to know how often to
expect metadata, the server must send back a header Icy-Metaint whose
value is the number of bytes of MP3 data that will be sent between each
chunk of metadata.

   The basic content of the metadata is a string of the form
"StreamTitle='title';" where title is the title of the current song and
can't contain single quote marks.  This payload is encoded as a
length-delimited array of bytes: a single byte is sent indicating how
many 16-byte blocks follow, and then that many blocks are sent.  They
contain the string payload as an ASCII string, with the final block
padded out with null bytes as necessary.

   Thus, the smallest legal metadata chunk is a single byte, zero,
indicating zero subsequent blocks.  If the server doesn't need to update
the metadata, it can send such an empty chunk, but it must send at least
the one byte so the client doesn't throw away actual MP3 data.


File: pcl.info,  Node: 28-2,  Next: 28-3,  Prev: 28-1,  Up: Chapter 28

Song Sources
============

Because a Shoutcast server has to keep streaming songs to the client for
as long as it's connected, you need to provide your server with a source
of songs to draw on.  In the Web-based application, each connected
client will have a playlist that can be manipulated via the Web
interface.  But in the interest of avoiding excessive coupling, you
should define an interface that the Shoutcast server can use to obtain
songs to play.  You can write a simple implementation of this interface
now and then a more complex one as part of the Web application you'll
build in Chapter 29.

   The idea behind the interface is that the Shoutcast server will find
a source of songs based on an ID extracted from the AllegroServe request
object.  It can then do three things with the song source it's given.

   Get the current song from the source Tell the song source that it's
done with the current song Ask the source whether the song it was given
earlier is still the current song The last operation is necessary
because there may be ways-and will be in Chapter 29-to manipulate the
songs source outside the Shoutcast server.  You can express the
operations the Shoutcast server needs with the following generic
functions:

   (defgeneric current-song (source) (:documentation "Return the
currently playing song or NIL."))

   (defgeneric maybe-move-to-next-song (song source) (:documentation "If
the given song is still the current one update the value returned by
current-song."))

   (defgeneric still-current-p (song source) (:documentation "Return
true if the song given is the same as the current-song."))  The function
maybe-move-to-next-song is defined the way it is so a single operation
checks whether the song is current and, if it is, moves the song source
to the next song.  This will be important in the next chapter when you
need to implement a song source that can be safely manipulated from two
different threads.3

   To represent the information about a song that the Shoutcast server
needs, you can define a class, song, with slots to hold the name of the
MP3 file, the title to send in the Shoutcast metadata, and the size of
the ID3 tag so you can skip it when serving up the file.

   (defclass song () ((file :reader file :initarg :file) (title :reader
title :initarg :title) (id3-size :reader id3-size :initarg :id3-size)))
The value returned by current-song (and thus the first argument to
still-current-p and maybe-move-to-next-song) will be an instance of
song.

   In addition, you need to define a generic function that the server
can use to find a song source based on the type of source desired and
the request object.  Methods will specialize the type parameter in order
to return different kinds of song source and will pull whatever
information they need from the request object to determine which source
to return.

   (defgeneric find-song-source (type request) (:documentation "Find the
song-source of the given type for the given request."))  However, for
the purposes of this chapter, you can use a trivial implementation of
this interface that always uses the same object, a simple queue of song
objects that you can manipulate from the REPL. You can start by defining
a class, simple-song-queue, and a global variable, *songs*, that holds
an instance of this class.

   (defclass simple-song-queue () ((songs :accessor songs :initform
(make-array 10 :adjustable t :fill-pointer 0)) (index :accessor index
:initform 0)))

   (defparameter *songs* (make-instance 'simple-song-queue)) Then you
can define a method on find-song-source that specializes type with an
EQL specializer on the symbol singleton and returns the instance stored
in *songs*.

   (defmethod find-song-source ((type (eql 'singleton)) request)
(declare (ignore request)) *songs*) Now you just need to implement
methods on the three generic functions that the Shoutcast server will
use.

   (defmethod current-song ((source simple-song-queue)) (when
(array-in-bounds-p (songs source) (index source)) (aref (songs source)
(index source))))

   (defmethod still-current-p (song (source simple-song-queue)) (eql
song (current-song source)))

   (defmethod maybe-move-to-next-song (song (source simple-song-queue))
(when (still-current-p song source) (incf (index source)))) And for
testing purposes you should provide a way to add songs to this queue.

   (defun add-file-to-songs (file) (vector-push-extend (file->song file)
(songs *songs*)))

   (defun file->song (file) (let ((id3 (read-id3 file))) (make-instance
'song :file (namestring (truename file)) :title (format nil "~a by ~a
from ~a" (song id3) (artist id3) (album id3)) :id3-size (size id3))))


File: pcl.info,  Node: 28-3,  Next: Chapter 29,  Prev: 28-2,  Up: Chapter 28

Implementing Shoutcast
======================

Now you're ready to implement the Shoutcast server.  Since the Shoutcast
protocol is loosely based on HTTP, you can implement the server as a
function within AllegroServe.  However, since you need to interact with
some of the low-level features of AllegroServe, you can't use the
define-url-function macro from Chapter 26.  Instead, you need to write a
regular function that looks like this:

   (defun shoutcast (request entity) (with-http-response (request entity
:content-type "audio/MP3" :timeout *timeout-seconds*)
(prepare-icy-response request *metadata-interval*) (let
((wants-metadata-p (header-slot-value request :icy-metadata)))
(with-http-body (request entity) (play-songs (request-socket request)
(find-song-source *song-source-type* request) (if wants-metadata-p
*metadata-interval*)))))) Then publish that function under the path
/stream.mp3 like this:4

   (publish :path "/stream.mp3" :function 'shoutcast) In the call to
with-http-response, in addition to the usual request and entity
arguments, you need to pass :content-type and :timeout arguments.  The
:content-type argument tells AllegroServe how to set the Content-Type
header it sends.  And the :timeout argument specifies the number of
seconds AllegroServe gives the function to generate its response.  By
default AllegroServe times out each request after five minutes.  Because
you're going to stream an essentially endless sequence of MP3s, you need
much more time.  There's no way to tell AllegroServe to never time out
the request, so you should set it to the value of *timeout-seconds*,
which you can define to some suitably large value such as the number of
seconds in ten years.

   (defparameter *timeout-seconds* (* 60 60 24 7 52 10)) Then, within
the body of the with-http-response and before the call to with-http-body
that will cause the response headers to be sent, you need to manipulate
the reply that AllegroServe will send.  The function
prepare-icy-response encapsulates the necessary manipulations: changing
the protocol string from the default of "HTTP" to "ICY" and adding the
Shoutcast-specific headers.5 You also need, in order to work around a
bug in iTunes, to tell AllegroServe not to use chunked
transfer-encoding.6 The functions request-reply-protocol-string,
request-uri, and reply-header-slot-value are all part of AllegroServe.

   (defun prepare-icy-response (request metadata-interval) (setf
(request-reply-protocol-string request) "ICY") (loop for (k v) in
(reverse '((:|icy-metaint| ,(princ-to-string metadata-interval))
(:|icy-notice1| "<BR>This stream blah blah blah<BR>") (:|icy-notice2|
"More blah") (:|icy-name| "MyLispShoutcastServer") (:|icy-genre|
"Unknown") (:|icy-url| ,(request-uri request)) (:|icy-pub| "1"))) do
(setf (reply-header-slot-value request k) v)) ;; iTunes, despite
claiming to speak HTTP/1.1, doesn't understand ;; chunked
Transfer-encoding.  Grrr.  So we just turn it off.
(turn-off-chunked-transfer-encoding request))

   (defun turn-off-chunked-transfer-encoding (request) (setf
(request-reply-strategy request) (remove :chunked
(request-reply-strategy request)))) Within the with-http-body of
shoutcast, you actually stream the MP3 data.  The function play-songs
takes the stream to which it should write the data, the song source, and
the metadata interval it should use or NIL if the client doesn't want
metadata.  The stream is the socket obtained from the request object,
the song source is obtained by calling find-song-source, and the
metadata interval comes from the global variable *metadata-interval*.
The type of song source is controlled by the variable
*song-source-type*, which for now you can set to singleton in order to
use the simple-song-queue you implemented previously.

   (defparameter *metadata-interval* (expt 2 12))

   (defparameter *song-source-type* 'singleton) The function play-songs
itself doesn't do much-it loops calling the function play-current, which
does all the heavy lifting of sending the contents of a single MP3 file,
skipping the ID3 tag and embedding ICY metadata.  The only wrinkle is
that you need to keep track of when to send the metadata.

   Since you must send metadata chunks at a fixed intervals, regardless
of when you happen to switch from one MP3 file to the next, each time
you call play-current you need to tell it when the next metadata is due,
and when it returns, it must tell you the same thing so you can pass the
information to the next call to play-current.  If play-current gets NIL
from the song source, it returns NIL, which allows the play-songs LOOP
to end.

   In addition to handling the looping, play-songs also provides a
HANDLER-CASE to trap the error that will be signaled when the MP3 client
disconnects from the server and one of the writes to the socket, down in
play-current, fails.  Since the HANDLER-CASE is outside the LOOP,
handling the error will break out of the loop, allowing play-songs to
return.

   (defun play-songs (stream song-source metadata-interval)
(handler-case (loop for next-metadata = metadata-interval then
(play-current stream song-source next-metadata metadata-interval) while
next-metadata) (error (e) (format *trace-output* "Caught error in
play-songs: ~a" e)))) Finally, you're ready to implement play-current,
which actually sends the Shoutcast data.  The basic idea is that you get
the current song from the song source, open the song's file, and then
loop reading data from the file and writing it to the socket until
either you reach the end of the file or the current song is no longer
the current song.

   There are only two complications: One is that you need to make sure
you send the metadata at the correct interval.  The other is that if the
file starts with an ID3 tag, you want to skip it.  If you don't worry
too much about I/O efficiency, you can implement play-current like this:

   (defun play-current (out song-source next-metadata metadata-interval)
(let ((song (current-song song-source))) (when song (let ((metadata
(make-icy-metadata (title song)))) (with-open-file (mp3 (file song))
(unless (file-position mp3 (id3-size song)) (error "Can't skip to
position ~d in ~a" (id3-size song) (file song))) (loop for byte =
(read-byte mp3 nil nil) while (and byte (still-current-p song
song-source)) do (write-byte byte out) (decf next-metadata) when (and
(zerop next-metadata) metadata-interval) do (write-sequence metadata
out) (setf next-metadata metadata-interval))

   (maybe-move-to-next-song song song-source))) next-metadata))) This
function gets the current song from the song source and gets a buffer
containing the metadata it'll need to send by passing the title to
make-icy-metadata.  Then it opens the file and skips past the ID3 tag
using the two-argument form of FILE-POSITION. Then it commences reading
bytes from the file and writing them to the request stream.7

   It'll break out of the loop either when it reaches the end of the
file or when the song source's current song changes out from under it.
In the meantime, whenever next-metadata gets to zero (if you're supposed
to send metadata at all), it writes metadata to the stream and resets
next-metadata.  Once it finishes the loop, it checks to see if the song
is still the song source's current song; if it is, that means it broke
out of the loop because it read the whole file, in which case it tells
the song source to move to the next song.  Otherwise, it broke out of
the loop because someone changed the current song out from under it, and
it just returns.  In either case, it returns the number of bytes left
before the next metadata is due so it can be passed in the next call to
play-current.8

   The function make-icy-metadata, which takes the title of the current
song and generates an array of bytes containing a properly formatted
chunk of ICY metadata, is also straightforward.9

   (defun make-icy-metadata (title) (let* ((text (format nil
"StreamTitle='~a';" (substitute #\Space #\' title))) (blocks (ceiling
(length text) 16)) (buffer (make-array (1+ (* blocks 16)) :element-type
'(unsigned-byte 8) :initial-element 0))) (setf (aref buffer 0) blocks)
(loop for char across text for i from 1 do (setf (aref buffer i)
(char-code char))) buffer)) Depending on how your particular Lisp
implementation handles its streams, and also how many MP3 clients you
want to serve at once, the simple version of play-current may or may not
be efficient enough.

   The potential problem with the simple implementation is that you have
to call READ-BYTE and WRITE-BYTE for every byte you transfer.  It's
possible that each call may result in a relatively expensive system call
to read or write one byte.  And even if Lisp implements its own streams
with internal buffering so not every call to READ-BYTE or WRITE-BYTE
results in a system call, function calls still aren't free.  In
particular, in implementations that provide user-extensible streams
using so-called Gray Streams, READ-BYTE and WRITE-BYTE may result in a
generic function call under the covers to dispatch on the class of the
stream argument.  While generic function dispatch is normally speedy
enough that you don't have to worry about it, it's a bit more expensive
than a nongeneric function call and thus not something you necessarily
want to do several million times in a few minutes if you can avoid it.

   A more efficient, if slightly more complex, way to implement
play-current is to read and write multiple bytes at a time using the
functions READ-SEQUENCE and WRITE-SEQUENCE. This also gives you a chance
to match your file reads with the natural block size of the file system,
which will likely give you the best disk throughput.  Of course, no
matter what buffer size you use, keeping track of when to send the
metadata becomes a bit more complicated.  A more efficient version of
play-current that uses READ-SEQUENCE and WRITE-SEQUENCE might look like
this:

   (defun play-current (out song-source next-metadata metadata-interval)
(let ((song (current-song song-source))) (when song (let ((metadata
(make-icy-metadata (title song))) (buffer (make-array size :element-type
'(unsigned-byte 8)))) (with-open-file (mp3 (file song)) (labels
((write-buffer (start end) (if metadata-interval
(write-buffer-with-metadata start end) (write-sequence buffer out :start
start :end end)))

   (write-buffer-with-metadata (start end) (cond ((> next-metadata (-
end start)) (write-sequence buffer out :start start :end end) (decf
next-metadata (- end start))) (t (let ((middle (+ start next-metadata)))
(write-sequence buffer out :start start :end middle) (write-sequence
metadata out) (setf next-metadata metadata-interval)
(write-buffer-with-metadata middle end))))))

   (multiple-value-bind (skip-blocks skip-bytes) (floor (id3-size song)
(length buffer))

   (unless (file-position mp3 (* skip-blocks (length buffer))) (error
"Couldn't skip over ~d ~d byte blocks."  skip-blocks (length buffer)))

   (loop for end = (read-sequence buffer mp3) for start = skip-bytes
then 0 do (write-buffer start end) while (and (= end (length buffer))
(still-current-p song song-source)))

   (maybe-move-to-next-song song song-source))))) next-metadata))) Now
you're ready to put all the pieces together.  In the next chapter you'll
write a Web interface to the Shoutcast server developed in this chapter,
using the MP3 database from Chapter 27 as the source of songs.


File: pcl.info,  Node: Chapter 29,  Next: Chapter 30,  Prev: Chapter 28,  Up: Top

29. Practical: An MP3 Browser
=============================

The final step in building the MP3 streaming application is to provide a
Web interface that allows a user to find the songs they want to listen
to and add them to a playlist that the Shoutcast server will draw upon
when the user's MP3 client requests the stream URL. For this component
of the application, you'll pull together several bits of code from the
previous few chapters: the MP3 database, the define-url-function macro
from Chapter 26, and, of course, the Shoutcast server itself.

* Menu:

* 29-1::       Playlists
* 29-2::       Playlists As Song Sources
* 29-3::       Manipulating the Playlist
* 29-4::       Query Parameter Types
* 29-5::       Boilerplate HTML
* 29-6::       The Browse Page
* 29-7::       The Playlist
* 29-8::       Finding a Playlist
* 29-9::       Running the App


File: pcl.info,  Node: 29-1,  Next: 29-2,  Prev: Chapter 29,  Up: Chapter 29

Playlists
=========

The basic idea behind the interface will be that each MP3 client that
connects to the Shoutcast server gets its own playlist, which serves as
the source of songs for the Shoutcast server.  A playlist will also
provide facilities beyond those needed by the Shoutcast server: through
the Web interface the user will be able to add songs to the playlist,
delete songs already in the playlist, and reorder the playlist by
sorting and shuffling.

   You can define a class to represent playlists like this:

   (defclass playlist () ((id :accessor id :initarg :id) (songs-table
:accessor songs-table :initform (make-playlist-table)) (current-song
:accessor current-song :initform *empty-playlist-song*) (current-idx
:accessor current-idx :initform 0) (ordering :accessor ordering
:initform :album) (shuffle :accessor shuffle :initform :none) (repeat
:accessor repeat :initform :none) (user-agent :accessor user-agent
:initform "Unknown") (lock :reader lock :initform (make-process-lock))))
The id of a playlist is the key you extract from the request object
passed to find-song-source when looking up a playlist.  You don't
actually need to store it in the playlist object, but it makes debugging
a bit easier if you can find out from an arbitrary playlist object what
its id is.

   The heart of the playlist is the songs-table slot, which will hold a
table object.  The schema for this table will be the same as for the
main MP3 database.  The function make-playlist-table, which you use to
initialize songs-table, is simply this:

   (defun make-playlist-table () (make-instance 'table :schema
*mp3-schema*))

   By storing the list of songs as a table, you can use the database
functions from Chapter 27 to manipulate the playlist: you can add to the
playlist with insert-row, delete songs with delete-rows, and reorder the
playlist with sort-rows and shuffle-table.

   The current-song and current-idx slots keep track of which song is
playing: current-song is an actual song object, while current-idx is the
index into the songs-table of the row representing the current song.
You'll see in the section "Manipulating the Playlist" how to make sure
current-song is updated whenever current-idx changes.

   The ordering and shuffle slots hold information about how the songs
in songs-table are to be ordered.  The ordering slot holds a keyword
that tells how the songs-table should be sorted when it's not shuffled.
The legal values are :genre, :artist, :album, and :song.  The shuffle
slot holds one of the keywords :none, :song, or :album, which specifies
how songs-table should be shuffled, if at all.

   The repeat slot also holds a keyword, one of :none, :song, or :all,
which specifies the repeat mode for the playlist.  If repeat is :none,
after the last song in the songs-table has been played, the current-song
goes back to a default MP3.  When :repeat is :song, the playlist keeps
returning the same current-song forever.  And if it's :all, after the
last song, current-song goes back to the first song.

   The user-agent slot holds the value of the User-Agent header sent by
the MP3 client in its request for the stream.  You need to hold onto
this value purely for use in the Web interface-the User-Agent header
identifies the program that made the request, so you can display the
value on the page that lists all the playlists to make it easier to tell
which playlist goes with which connection when multiple clients connect.

   Finally, the lock slot holds a process lock created with the function
make-process-lock, which is part of Allegro's MULTIPROCESSING package.
You'll need to use that lock in certain functions that manipulate
playlist objects to ensure that only one thread at a time manipulates a
given playlist object.  You can define the following macro, built upon
the with-process-lock macro from MULTIPROCESSING, to give an easy way to
wrap a body of code that should be performed while holding a playlist's
lock:

   (defmacro with-playlist-locked ((playlist) &body body)
'(with-process-lock ((lock ,playlist)) ,@body))

   The with-process-lock macro acquires exclusive access to the process
lock given and then executes the body forms, releasing the lock
afterward.  By default, with-process-lock allows recursive locks,
meaning the same thread can safely acquire the same lock multiple times.


File: pcl.info,  Node: 29-2,  Next: 29-3,  Prev: 29-1,  Up: Chapter 29

Playlists As Song Sources
=========================

To use playlists as a source of songs for the Shoutcast server, you'll
need to implement a method on the generic function find-song-source from
Chapter 28.  Since you're going to have multiple playlists, you need a
way to find the right one for each client that connects to the server.
The mapping part is easy-you can define a variable that holds an EQUAL
hash table that you can use to map from some identifier to the playlist
object.

   (defvar *playlists* (make-hash-table :test #'equal)) You'll also need
to define a process lock to protect access to this hash table like this:

   (defparameter *playlists-lock* (make-process-lock :name
"playlists-lock")) Then define a function that looks up a playlist given
an ID, creating a new playlist object if necessary and using
with-process-lock to ensure that only one thread at a time manipulates
the hash table.1

   (defun lookup-playlist (id) (with-process-lock (*playlists-lock*) (or
(gethash id *playlists*) (setf (gethash id *playlists*) (make-instance
'playlist :id id))))) Then you can implement find-song-source on top of
that function and another, playlist-id, that takes an AllegroServe
request object and returns the appropriate playlist identifier.  The
find-song-source function is also where you grab the User-Agent string
out of the request object and stash it in the playlist object.

   (defmethod find-song-source ((type (eql 'playlist)) request) (let
((playlist (lookup-playlist (playlist-id request))))
(with-playlist-locked (playlist) (let ((user-agent (header-slot-value
request :user-agent))) (when user-agent (setf (user-agent playlist)
user-agent)))) playlist)) The trick, then, is how you implement
playlist-id, the function that extracts the identifier from the request
object.  You have a couple options, each with different implications for
the user interface.  You can pull whatever information you want out of
the request object, but however you decide to identify the client, you
need some way for the user of the Web interface to get hooked up to the
right playlist.

   For now you can take an approach that "just works" as long as there's
only one MP3 client per machine connecting to the server and as long as
the user is browsing the Web interface from the machine running the MP3
client: you'll use the IP address of the client machine as the
identifier.  This way you can find the right playlist for a request
regardless of whether the request is from the MP3 client or a Web
browser.  You will, however, provide a way in the Web interface to
select a different playlist from the browser, so the only real
constraint this choice puts on the application is that there can be only
one connected MP3 client per client IP address.2 The implementation of
playlist-id looks like this:

   (defun playlist-id (request) (ipaddr-to-dotted (remote-host
(request-socket request)))) The function request-socket is part of
AllegroServe, while remote-host and ipaddr-to-dotted are part of
Allegro's socket library.

   To make a playlist usable as a song source by the Shoutcast server,
you need to define methods on current-song, still-current-p, and
maybe-move-to-next-song that specialize their source parameter on
playlist.  The current-song method is already taken care of: by defining
the accessor current-song on the eponymous slot, you automatically got a
current-song method specialized on playlist that returns the value of
that slot.  However, to make accesses to the playlist thread safe, you
need to lock the playlist before accessing the current-song slot.  In
this case, the easiest way is to define an :around method like the
following:

   (defmethod current-song :around ((playlist playlist))
(with-playlist-locked (playlist) (call-next-method))) Implementing
still-current-p is also quite simple, assuming you can be sure that
current-song gets updated with a new song object only when the current
song actually changes.  Again, you need to acquire the process lock to
ensure you get a consistent view of the playlist's state.

   (defmethod still-current-p (song (playlist playlist))
(with-playlist-locked (playlist) (eql song (current-song playlist))))
The trick, then, is to make sure the current-song slot gets updated at
the right times.  However, the current song can change in a number of
ways.  The obvious one is when the Shoutcast server calls
maybe-move-to-next-song.  But it can also change when songs are added to
the playlist, when the Shoutcast server has run out of songs, or even if
the playlist's repeat mode is changed.

   Rather than trying to write code specific to every situation to
determine whether to update current-song, you can define a function,
update-current-if-necessary, that updates current-song if the song
object in current-song no longer matches the file that the current-idx
slot says should be playing.  Then, if you call this function after any
manipulation of the playlist that could possibly put those two slots out
of sync, you're sure to keep current-song set properly.  Here are
update-current-if-necessary and its helper functions:

   (defun update-current-if-necessary (playlist) (unless (equal (file
(current-song playlist)) (file-for-current-idx playlist))
(reset-current-song playlist)))

   (defun file-for-current-idx (playlist) (if (at-end-p playlist) nil
(column-value (nth-row (current-idx playlist) (songs-table playlist))
:file)))

   (defun at-end-p (playlist) (>= (current-idx playlist) (table-size
(songs-table playlist)))) You don't need to add locking to these
functions since they'll be called only from functions that will take
care of locking the playlist first.

   The function reset-current-song introduces one more wrinkle: because
you want the playlist to provide an endless stream of MP3s to the
client, you don't want to ever set current-song to NIL. Instead, when a
playlist runs out of songs to play-when songs-table is empty or after
the last song has been played and repeat is set to :none-then you need
to set current-song to a special song whose file is an MP3 of silence3
and whose title explains why no music is playing.  Here's some code to
define two parameters, *empty-playlist-song* and *end-of-playlist-song*,
each set to a song with the file named by *silence-mp3* as their file
and an appropriate title:

   (defparameter *silence-mp3* ...)

   (defun make-silent-song (title &optional (file *silence-mp3*))
(make-instance 'song :file file :title title :id3-size (if (id3-p file)
(size (read-id3 file)) 0)))

   (defparameter *empty-playlist-song* (make-silent-song "Playlist
empty."))

   (defparameter *end-of-playlist-song* (make-silent-song "At end of
playlist."))  reset-current-song uses these parameters when the
current-idx doesn't point to a row in songs-table.  Otherwise, it sets
current-song to a song object representing the current row.

   (defun reset-current-song (playlist) (setf (current-song playlist)
(cond ((empty-p playlist) *empty-playlist-song*) ((at-end-p playlist)
*end-of-playlist-song*) (t (row->song (nth-row (current-idx playlist)
(songs-table playlist)))))))

   (defun row->song (song-db-entry) (with-column-values (file song
artist album id3-size) song-db-entry (make-instance 'song :file file
:title (format nil "~a by ~a from ~a" song artist album) :id3-size
id3-size)))

   (defun empty-p (playlist) (zerop (table-size (songs-table
playlist)))) Now, at last, you can implement the method on
maybe-move-to-next-song that moves current-idx to its next value, based
on the playlist's repeat mode, and then calls
update-current-if-necessary.  You don't change current-idx when it's
already at the end of the playlist because you want it to keep its
current value, so it'll point at the next song you add to the playlist.
This function must lock the playlist before manipulating it since it's
called by the Shoutcast server code, which doesn't do any locking.

   (defmethod maybe-move-to-next-song (song (playlist playlist))
(with-playlist-locked (playlist) (when (still-current-p song playlist)
(unless (at-end-p playlist) (ecase (repeat playlist) (:song) ; nothing
changes (:none (incf (current-idx playlist))) (:all (setf (current-idx
playlist) (mod (1+ (current-idx playlist)) (table-size (songs-table
playlist))))))) (update-current-if-necessary playlist))))


File: pcl.info,  Node: 29-3,  Next: 29-4,  Prev: 29-2,  Up: Chapter 29

Manipulating the Playlist
=========================

The rest of the playlist code is functions used by the Web interface to
manipulate playlist objects, including adding and deleting songs,
sorting and shuffling, and setting the repeat mode.  As in the helper
functions in the previous section, you don't need to worry about locking
in these functions because, as you'll see, the lock will be acquired in
the Web interface function that calls these.

   Adding and deleting is mostly a question of manipulating the
songs-table.  The only extra work you have to do is to keep the
current-song and current-idx in sync.  For instance, whenever the
playlist is empty, its current-idx will be zero, and the current-song
will be the *empty-playlist-song*.  If you add a song to an empty
playlist, then the index of zero is now in bounds, and you should change
the current-song to the newly added song.  By the same token, when
you've played all the songs in a playlist and current-song is
*end-of-playlist-song*, adding a song should cause current-song to be
reset.  All this really means, though, is that you need to call
update-current-if-necessary at the appropriate points.

   Adding songs to a playlist is a bit involved because of the way the
Web interface communicates which songs to add.  For reasons I'll discuss
in the next section, the Web interface code can't just give you a simple
set of criteria to use in selecting songs from the database.  Instead,
it gives you the name of a column and a list of values, and you're
supposed to add all the songs from the main database where the given
column has a value in the list of values.  Thus, to add the right songs,
you need to first build a table object containing the desired values,
which you can then use with an in query against the song database.  So,
add-songs looks like this:

   (defun add-songs (playlist column-name values) (let ((table
(make-instance 'table :schema (extract-schema (list column-name) (schema
*mp3s*))))) (dolist (v values) (insert-row (list column-name v) table))
(do-rows (row (select :from *mp3s* :where (in column-name table)))
(insert-row row (songs-table playlist)))) (update-current-if-necessary
playlist)) Deleting songs is a bit simpler; you just need to be able to
delete songs from the songs-table that match particular criteria-either
a particular song or all songs in a particular genre, by a particular
artist, or from a particular album.  So, you can provide a delete-songs
function that takes keyword/value pairs, which are used to construct a
matching :where clause you can pass to the delete-rows database
function.

   Another complication that arises when deleting songs is that
current-idx may need to change.  Assuming the current song isn't one of
the ones just deleted, you'd like it to remain the current song.  But if
songs before it in songs-table are deleted, it'll be in a different
position in the table after the delete.  So after a call to delete-rows,
you need to look for the row containing the current song and reset
current-idx.  If the current song has itself been deleted, then, for
lack of anything better to do, you can reset current-idx to zero.  After
updating current-idx, calling update-current-if-necessary will take care
of updating current-song.  And if current-idx changed but still points
at the same song, current-song will be left alone.

   (defun delete-songs (playlist &rest names-and-values) (delete-rows
:from (songs-table playlist) :where (apply #'matching (songs-table
playlist) names-and-values)) (setf (current-idx playlist) (or
(position-of-current playlist) 0)) (update-current-if-necessary
playlist))

   (defun position-of-current (playlist) (let* ((table (songs-table
playlist)) (matcher (matching table :file (file (current-song
playlist)))) (pos 0)) (do-rows (row table) (when (funcall matcher row)
(return-from position-of-current pos)) (incf pos)))) You can also
provide a function to completely clear the playlist, which uses
delete-all-rows and doesn't have to worry about finding the current song
since it has obviously been deleted.  The call to
update-current-if-necessary will take care of setting current-song to
NIL.

   (defun clear-playlist (playlist) (delete-all-rows (songs-table
playlist)) (setf (current-idx playlist) 0) (update-current-if-necessary
playlist)) Sorting and shuffling the playlist are related in that the
playlist is always either sorted or shuffled.  The shuffle slot says
whether the playlist should be shuffled and if so how.  If it's set to
:none, then the playlist is ordered according to the value in the
ordering slot.  When shuffle is :song, the playlist will be randomly
permuted.  And when it's set to :album, the list of albums is randomly
permuted, but the songs within each album are listed in track order.
Thus, the sort-playlist function, which will be called by the Web
interface code whenever the user selects a new ordering, needs to set
ordering to the desired ordering and set shuffle to :none before calling
order-playlist, which actually does the sort.  As in delete-songs, you
need to use position-of-current to reset current-idx to the new location
of the current song.  However, this time you don't need to call
update-current-if-necessary since you know the current song is still in
the table.

   (defun sort-playlist (playlist ordering) (setf (ordering playlist)
ordering) (setf (shuffle playlist) :none) (order-playlist playlist)
(setf (current-idx playlist) (position-of-current playlist))) In
order-playlist, you can use the database function sort-rows to actually
perform the sort, passing a list of columns to sort by based on the
value of ordering.

   (defun order-playlist (playlist) (apply #'sort-rows (songs-table
playlist) (case (ordering playlist) (:genre '(:genre :album :track))
(:artist '(:artist :album :track)) (:album '(:album :track)) (:song
'(:song))))) The function shuffle-playlist, called by the Web interface
code when the user selects a new shuffle mode, works in a similar
fashion except it doesn't need to change the value of ordering.  Thus,
when shuffle-playlist is called with a shuffle of :none, the playlist
goes back to being sorted according to the most recent ordering.
Shuffling by songs is simple-just call shuffle-table on songs-table.
Shuffling by albums is a bit more involved but still not rocket science.

   (defun shuffle-playlist (playlist shuffle) (setf (shuffle playlist)
shuffle) (case shuffle (:none (order-playlist playlist)) (:song
(shuffle-by-song playlist)) (:album (shuffle-by-album playlist))) (setf
(current-idx playlist) (position-of-current playlist)))

   (defun shuffle-by-song (playlist) (shuffle-table (songs-table
playlist)))

   (defun shuffle-by-album (playlist) (let ((new-table
(make-playlist-table))) (do-rows (album-row (shuffled-album-names
playlist)) (do-rows (song (songs-for-album playlist (column-value
album-row :album))) (insert-row song new-table))) (setf (songs-table
playlist) new-table)))

   (defun shuffled-album-names (playlist) (shuffle-table (select
:columns :album :from (songs-table playlist) :distinct t)))

   (defun songs-for-album (playlist album) (select :from (songs-table
playlist) :where (matching (songs-table playlist) :album album)
:order-by :track)) The last manipulation you need to support is setting
the playlist's repeat mode.  Most of the time you don't need to take any
extra action when setting repeat-its value comes into play only in
maybe-move-to-next-song.  However, you need to update the current-song
as a result of changing repeat in one situation, namely, if current-idx
is at the end of a nonempty playlist and repeat is being changed to
:song or :all.  In that case, you want to continue playing, either
repeating the last song or starting at the beginning of the playlist.
So, you should define an :after method on the generic function (setf
repeat).

   (defmethod (setf repeat) :after (value (playlist playlist)) (if (and
(at-end-p playlist) (not (empty-p playlist))) (ecase value (:song (setf
(current-idx playlist) (1- (table-size (songs-table playlist)))))
(:none) (:all (setf (current-idx playlist) 0)))
(update-current-if-necessary playlist))) Now you have all the underlying
bits you need.  All that remains is the code that will provide a
Web-based user interface for browsing the MP3 database and manipulating
playlists.  The interface will consist of three main functions defined
with define-url-function: one for browsing the song database, one for
viewing and manipulating a single playlist, and one for listing all the
available playlists.

   But before you get to writing these three functions, you need to
start with some helper functions and HTML macros that they'll use.


File: pcl.info,  Node: 29-4,  Next: 29-5,  Prev: 29-3,  Up: Chapter 29

Query Parameter Types
=====================

Since you'll be using define-url-function, you need to define a few
methods on the string->type generic function from Chapter 28 that
define-url-function uses to convert string query parameters into Lisp
objects.  In this application, you'll need methods to convert strings to
integers, keyword symbols, and a list of values.

   The first two are quite simple.

   (defmethod string->type ((type (eql 'integer)) value) (parse-integer
(or value "") :junk-allowed t))

   (defmethod string->type ((type (eql 'keyword)) value) (and (plusp
(length value)) (intern (string-upcase value) :keyword))) The last
string->type method is slightly more complex.  For reasons I'll get to
in a moment, you'll need to generate pages that display a form that
contains a hidden field whose value is a list of strings.  Since you're
responsible for generating the value in the hidden field and for parsing
it when it comes back, you can use whatever encoding is convenient.  You
could use the functions WRITE-TO-STRING and READ-FROM-STRING, which use
the Lisp printer and reader to write and read data to and from strings,
except the printed representation of strings can contain quotation marks
and other characters that may cause problems when embedded in the value
attribute of an INPUT element.  So, you'll need to escape those
characters somehow.  Rather than trying to come up with your own
escaping scheme, you can just use base 64, an encoding commonly used to
protect binary data sent through e-mail.  AllegroServe comes with two
functions, base64-encode and base64-decode, that do the encoding and
decoding for you, so all you have to do is write a pair of functions:
one that encodes a Lisp object by converting it to a readable string
with WRITE-TO-STRING and then base 64 encoding it and, conversely,
another to decode such a string by base 64 decoding it and passing the
result to READ-FROM-STRING. You'll want to wrap the calls to
WRITE-TO-STRING and READ-FROM-STRING in WITH-STANDARD-IO-SYNTAX to make
sure all the variables that affect the printer and reader are set to
their standard values.  However, because you're going to be reading data
that's coming in from the network, you'll definitely want to turn off
one feature of the reader-the ability to evaluate arbitrary Lisp code
while reading!4 You can define your own macro with-safe-io-syntax, which
wraps its body forms in WITH-STANDARD-IO-SYNTAX wrapped around a LET
that binds *READ-EVAL* to NIL.

   (defmacro with-safe-io-syntax (&body body) '(with-standard-io-syntax
(let ((*read-eval* nil)) ,@body))) Then the encoding and decoding
functions are trivial.

   (defun obj->base64 (obj) (base64-encode (with-safe-io-syntax
(write-to-string obj))))

   (defun base64->obj (string) (ignore-errors (with-safe-io-syntax
(read-from-string (base64-decode string))))) Finally, you can use these
functions to define a method on string->type that defines the conversion
for the query parameter type base64-list.

   (defmethod string->type ((type (eql 'base-64-list)) value) (let ((obj
(base64->obj value))) (if (listp obj) obj nil)))


File: pcl.info,  Node: 29-5,  Next: 29-6,  Prev: 29-4,  Up: Chapter 29

Boilerplate HTML
================

Next you need to define some HTML macros and helper functions to make it
easy to give the different pages in the application a consistent look
and feel.  You can start with an HTML macro that defines the basic
structure of a page in the application.

   (define-html-macro :mp3-browser-page ((&key title (header title))
&body body) '(:html (:head (:title ,title) (:link :rel "stylesheet"
:type "text/css" :href "mp3-browser.css")) (:body (standard-header)
(when ,header (html (:h1 :class "title" ,header))) ,@body
(standard-footer)))) You should define standard-header and
standard-footer as separate functions for two reasons.  First, during
development you can redefine those functions and see the effect
immediately without having to recompile functions that use the
:mp3-browser-page macro.  Second, it turns out that one of the pages
you'll write later won't be defined with :mp3-browser-page but will
still need the standard header and footers.  They look like this:

   (defparameter *r* 25)

   (defun standard-header () (html ((:p :class "toolbar") "[" (:a :href
(link "/browse" :what "genre") "All genres") "] " "[" (:a :href (link
"/browse" :what "genre" :random *r*) "Random genres") "] " "[" (:a :href
(link "/browse" :what "artist") "All artists") "] " "[" (:a :href (link
"/browse" :what "artist" :random *r*) "Random artists") "] " "[" (:a
:href (link "/browse" :what "album") "All albums") "] " "[" (:a :href
(link "/browse" :what "album" :random *r*) "Random albums") "] " "[" (:a
:href (link "/browse" :what "song" :random *r*) "Random songs") "] " "["
(:a :href (link "/playlist") "Playlist") "] " "[" (:a :href (link
"/all-playlists") "All playlists") "]")))

   (defun standard-footer () (html (:hr) ((:p :class "footer") "MP3
Browser v" *major-version* "."  *minor-version*))) A couple of smaller
HTML macros and helper functions automate other common patterns.  The
:table-row HTML macro makes it easier to generate the HTML for a single
row of a table.  It uses a feature of FOO that I'll discuss in Chapter
31, an &attributes parameter, which causes uses of the macro to be
parsed just like normal s-expression HTML forms, with any attributes
gathered into a list that will be bound to the &attributes parameter.
It looks like this:

   (define-html-macro :table-row (&attributes attrs &rest values) '(:tr
,@attrs ,@(loop for v in values collect '(:td ,v)))) And the link
function generates a URL back into the application to be used as the
HREF attribute with an A element, building a query string out of a set
of keyword/value pairs and making sure all special characters are
properly escaped.  For instance, instead of writing this:

   (:a :href "browse?what=artist&genre=Rhythm+%26+Blues" "Artists") you
can write the following:

   (:a :href (link "browse" :what "artist" :genre "Rhythm & Blues")
"Artists") It looks like this:

   (defun link (target &rest attributes) (html (:attribute (:format
"~a~@[?~{~(~a~)=~a~^&~}~]" target (mapcar #'urlencode attributes))))) To
URL encode the keys and values, you use the helper function urlencode,
which is a wrapper around the function encode-form-urlencoded, which is
a nonpublic function from AllegroServe.  This is-on one hand-bad form;
since the name encode-form-urlencoded isn't exported from NET.ASERVE,
it's possible that encode-form-urlencoded may go away or get renamed out
from under you.  On the other hand, using this unexported symbol for the
time being lets you get work done for the moment; by wrapping
encode-form-urlencoded in your own function, you isolate the crufty code
to one function, which you could rewrite if you had to.

   (defun urlencode (string) (net.aserve::encode-form-urlencoded
string)) Finally, you need the CSS style sheet mp3-browser.css used by
:mp3-browser-page.  Since there's nothing dynamic about it, it's
probably easiest to just publish a static file with publish-file.

   (publish-file :path "/mp3-browser.css" :file filename :content-type
"text/css") A sample style sheet is included with the source code for
this chapter on the book's Web site.  You'll define a function, at the
end of this chapter, that starts the MP3 browser application.  It'll
take care of, among other things, publishing this file.


File: pcl.info,  Node: 29-6,  Next: 29-7,  Prev: 29-5,  Up: Chapter 29

The Browse Page
===============

The first URL function will generate a page for browsing the MP3
database.  Its query parameters will tell it what kind of thing the user
is browsing and provide the criteria of what elements of the database
they're interested in.  It'll give them a way to select database entries
that match a specific genre, artist, or album.  In the interest of
serendipity, you can also provide a way to select a random subset of
matching items.  When the user is browsing at the level of individual
songs, the title of the song will be a link that causes that song to be
added to the playlist.  Otherwise, each item will be presented with
links that let the user browse the listed item by some other category.
For example, if the user is browsing genres, the entry "Blues" will
contain links to browse all albums, artists, and songs in the genre
Blues.  Additionally, the browse page will feature an "Add all" button
that adds every song matching the page's criteria to the user's
playlist.  The function looks like this:

   (define-url-function browse (request (what keyword :genre) genre
artist album (random integer))

   (let* ((values (values-for-page what genre artist album random))
(title (browse-page-title what random genre artist album))
(single-column (if (eql what :song) :file what)) (values-string
(values->base-64 single-column values))) (html (:mp3-browser-page
(:title title) ((:form :method "POST" :action "playlist") (:input :name
"values" :type "hidden" :value values-string) (:input :name "what" :type
"hidden" :value single-column) (:input :name "action" :type "hidden"
:value :add-songs) (:input :name "submit" :type "submit" :value "Add
all")) (:ul (do-rows (row values) (list-item-for-page what row)))))))
This function starts by using the function values-for-page to get a
table containing the values it needs to present.  When the user is
browsing by song-when the what parameter is :song-you want to select
complete rows from the database.  But when they're browsing by genre,
artist, or album, you want to select only the distinct values for the
given category.  The database function select does most of the heavy
lifting, with values-for-page mostly responsible for passing the right
arguments depending on the value of what.  This is also where you select
a random subset of the matching rows if necessary.

   (defun values-for-page (what genre artist album random) (let ((values
(select :from *mp3s* :columns (if (eql what :song) t what) :where
(matching *mp3s* :genre genre :artist artist :album album) :distinct
(not (eql what :song)) :order-by (if (eql what :song) '(:album :track)
what)))) (if random (random-selection values random) values))) To
generate the title for the browse page, you pass the browsing criteria
to the following function, browse-page-title:

   (defun browse-page-title (what random genre artist album)
(with-output-to-string (s) (when random (format s "~:(~r~) Random "
random)) (format s "~:(~a~p~)" what random) (when (or genre artist
album) (when (not (eql what :song)) (princ " with songs" s)) (when genre
(format s " in genre ~a" genre)) (when artist (format s " by artist ~a "
artist)) (when album (format s " on album ~a" album))))) Once you have
the values you want to present, you need to do two things with them.
The main task, of course, is to present them, which happens in the
do-rows loop, leaving the rendering of each row to the function
list-item-for-page.  That function renders :song rows one way and all
other kinds another way.

   (defun list-item-for-page (what row) (if (eql what :song)
(with-column-values (song file album artist genre) row (html (:li (:a
:href (link "playlist" :file file :action "add-songs") (:b song)) " from
" (:a :href (link "browse" :what :song :album album) album) " by " (:a
:href (link "browse" :what :song :artist artist) artist) " in genre "
(:a :href (link "browse" :what :song :genre genre) genre)))) (let
((value (column-value row what))) (html (:li value " - " (browse-link
:genre what value) (browse-link :artist what value) (browse-link :album
what value) (browse-link :song what value))))))

   (defun browse-link (new-what what value) (unless (eql new-what what)
(html "[" (:a :href (link "browse" :what new-what what value) (:format
"~(~as~)" new-what)) "] "))) The other thing on the browse page is a
form with several hidden INPUT fields and an "Add all" submit button.
You need to use an HTML form instead of a regular link to keep the
application stateless-to make sure all the information needed to respond
to a request comes in the request itself.  Because the browse page
results can be partially random, you need to submit a fair bit of data
for the server to be able to reconstitute the list of songs to add to
the playlist.  If you didn't allow the browse page to return randomly
generated results, you wouldn't need much data-you could just submit a
request to add songs with whatever search criteria the browse page used.
But if you added songs that way, with criteria that included a random
argument, then you'd end up adding a different set of random songs than
the user was looking at on the page when they hit the "Add all" button.

   The solution you'll use is to send back a form that has enough
information stashed away in a hidden INPUT element to allow the server
to reconstitute the list of songs matching the browse page criteria.
That information is the list of values returned by values-for-page and
the value of the what parameter.  This is where you use the base64-list
parameter type; the function values->base64 extracts the values of a
specified column from the table returned by values-for-page into a list
and then makes a base 64-encoded string out of that list to embed in the
form.

   (defun values->base-64 (column values-table) (flet ((value (r)
(column-value r column))) (obj->base64 (map-rows #'value
values-table)))) When that parameter comes back as the value of the
values query parameter to a URL function that declares values to be of
type base-64-list, it'll be automatically converted back to a list.  As
you'll see in a moment, that list can then be used to construct a query
that'll return the correct list of songs.5 When you're browsing by
:song, you use the values from the :file column since they uniquely
identify the actual songs while the song names may not.


File: pcl.info,  Node: 29-7,  Next: 29-8,  Prev: 29-6,  Up: Chapter 29

The Playlist
============

This brings me to the next URL function, playlist.  This is the most
complex page of the three-it's responsible for displaying the current
contents of the user's playlist as well as for providing the interface
to manipulate the playlist.  But with most of the tedious bookkeeping
handled by define-url-function, it's not too hard to see how playlist
works.  Here's the beginning of the definition, with just the parameter
list:

   (define-url-function playlist (request (playlist-id string
(playlist-id request) :package) (action keyword) ; Playlist manipulation
action (what keyword :file) ; for :add-songs action (values
base-64-list) ; " file ; for :add-songs and :delete-songs actions genre
; for :delete-songs action artist ; " album ; " (order-by keyword) ; for
:sort action (shuffle keyword) ; for :shuffle action (repeat keyword)) ;
for :set-repeat action In addition to the obligatory request parameter,
playlist takes a number of query parameters.  The most important in some
ways is playlist-id, which identifies which playlist object the page
should display and manipulate.  For this parameter, you can take
advantage of define-url-function's "sticky parameter" feature.
Normally, the playlist-id won't be supplied explicitly, defaulting to
the value returned by the playlist-id function, namely, the IP address
of the client machine on which the browser is running.  However, users
can also manipulate their playlists from different machines than the
ones running their MP3 clients by allowing this value to be explicitly
specified.  And if it's specified once, define-url-function will arrange
for it to "stick" by setting a cookie in the browser.  Later you'll
define a URL function that generates a list of all existing playlists,
which users can use to pick a playlist other than the one for the
machines they're browsing from.

   The action parameter specifies some action to take on the user's
playlist object.  The value of this parameter, which will be converted
to a keyword symbol for you, can be :add-songs, :delete-songs, :clear,
:sort, :shuffle, or :set-repeat.  The :add-songs action is used by the
"Add all" button in the browse page and also by the links used to add
individual songs.  The other actions are used by the links on the
playlist page itself.

   The file, what, and values parameters are used with the :add-songs
action.  By declaring values to be of type base-64-list, the
define-url-function infrastructure will take care of decoding the value
submitted by the "Add all" form.  The other parameters are used with
other actions as noted in the comments.

   Now let's look at the body of playlist.  The first thing you need to
do is use the playlist-id to look up the queue object and then acquire
the playlist's lock with the following two lines:

   (let ((playlist (lookup-playlist playlist-id))) (with-playlist-locked
(playlist) Since lookup-playlist will create a new playlist if
necessary, this will always return a playlist object.  Then you take
care of any necessary queue manipulation, dispatching on the value of
the action parameter in order to call one of the playlist functions.

   (case action (:add-songs (add-songs playlist what (or values (list
file)))) (:delete-songs (delete-songs playlist :file file :genre genre
:artist artist :album album)) (:clear (clear-playlist playlist)) (:sort
(sort-playlist playlist order-by)) (:shuffle (shuffle-playlist playlist
shuffle)) (:set-repeat (setf (repeat playlist) repeat))) All that's left
of the playlist function is the actual HTML generation.  Again, you can
use the :mp3-browser-page HTML macro to make sure the basic form of the
page matches the other pages in the application, though this time you
pass NIL to the :header argument in order to leave out the H1 header.
Here's the rest of the function:

   (html (:mp3-browser-page (:title (:format "Playlist - ~a" (id
playlist)) :header nil) (playlist-toolbar playlist) (if (empty-p
playlist) (html (:p (:i "Empty.")))  (html ((:table :class "playlist")
(:table-row "#" "Song" "Album" "Artist" "Genre") (let ((idx 0)
(current-idx (current-idx playlist))) (do-rows (row (songs-table
playlist)) (with-column-values (track file song album artist genre) row
(let ((row-style (if (= idx current-idx) "now-playing" "normal"))) (html
((:table-row :class row-style) track (:progn song (delete-songs-link
:file file)) (:progn album (delete-songs-link :album album)) (:progn
artist (delete-songs-link :artist artist)) (:progn genre
(delete-songs-link :genre genre))))) (incf idx)))))))))))) The function
playlist-toolbar generates a toolbar containing links to playlist to
perform the various :action manipulations.  And delete-songs-link
generates a link to playlist with the :action parameter set to
:delete-songs and the appropriate arguments to delete an individual
file, or all files on an album, by a particular artist or in a specific
genre.

   (defun playlist-toolbar (playlist) (let ((current-repeat (repeat
playlist)) (current-sort (ordering playlist)) (current-shuffle (shuffle
playlist))) (html (:p :class "playlist-toolbar" (:i "Sort by:") " [ "
(sort-playlist-button "genre" current-sort) " | " (sort-playlist-button
"artist" current-sort) " | " (sort-playlist-button "album" current-sort)
" | " (sort-playlist-button "song" current-sort) " ] " (:i "Shuffle
by:") " [ " (playlist-shuffle-button "none" current-shuffle) " | "
(playlist-shuffle-button "song" current-shuffle) " | "
(playlist-shuffle-button "album" current-shuffle) " ] " (:i "Repeat:") "
[ " (playlist-repeat-button "none" current-repeat) " | "
(playlist-repeat-button "song" current-repeat) " | "
(playlist-repeat-button "all" current-repeat) " ] " "[ " (:a :href (link
"playlist" :action "clear") "Clear") " ] "))))

   (defun playlist-button (action argument new-value current-value) (let
((label (string-capitalize new-value))) (if (string-equal new-value
current-value) (html (:b label)) (html (:a :href (link "playlist"
:action action argument new-value) label)))))

   (defun sort-playlist-button (order-by current-sort) (playlist-button
:sort :order-by order-by current-sort))

   (defun playlist-shuffle-button (shuffle current-shuffle)
(playlist-button :shuffle :shuffle shuffle current-shuffle))

   (defun playlist-repeat-button (repeat current-repeat)
(playlist-button :set-repeat :repeat repeat current-repeat))

   (defun delete-songs-link (what value) (html " [" (:a :href (link
"playlist" :action :delete-songs what value) "x") "]"))


File: pcl.info,  Node: 29-8,  Next: 29-9,  Prev: 29-7,  Up: Chapter 29

Finding a Playlist
==================

The last of the three URL functions is the simplest.  It presents a
table listing all the playlists that have been created.  Ordinarily
users won't need to use this page, but during development it gives you a
useful view into the state of the system.  It also provides the
mechanism to choose a different playlist-each playlist ID is a link to
the playlist page with an explicit playlist-id query parameter, which
will then be made sticky by the playlist URL function.  Note that you
need to acquire the *playlists-lock* to make sure the *playlists* hash
table doesn't change out from under you while you're iterating over it.

   (define-url-function all-playlists (request) (:mp3-browser-page
(:title "All Playlists") ((:table :class "all-playlists") (:table-row
"Playlist" "# Songs" "Most recent user agent") (with-process-lock
(*playlists-lock*) (loop for playlist being the hash-values of
*playlists* do (html (:table-row (:a :href (link "playlist" :playlist-id
(id playlist)) (:print (id playlist))) (:print (table-size (songs-table
playlist))) (:print (user-agent playlist)))))))))


File: pcl.info,  Node: 29-9,  Next: Chapter 30,  Prev: 29-8,  Up: Chapter 29

Running the App
===============

And that's it.  To use this app, you just need to load the MP3 database
with the load-database function from Chapter 27, publish the CSS style
sheet, set *song-source-type* to playlist so find-song-source uses
playlists instead of the singleton song source defined in the previous
chapter, and start AllegroServe.  The following function takes care of
all these steps for you, after you fill in appropriate values for the
two parameters *mp3-dir*, which is the root directory of your MP3
collection, and *mp3-css*, the filename of the CSS style sheet:

   (defparameter *mp3-dir* ...)

   (defparameter *mp3-css* ...)

   (defun start-mp3-browser () (load-database *mp3-dir* *mp3s*)
(publish-file :path "/mp3-browser.css" :file *mp3-css* :content-type
"text/css") (setf *song-source-type* 'playlist) (net.aserve::debug-on
:notrap) (net.aserve:start :port 2001)) When you invoke this function,
it will print dots while it loads the ID3 information from your ID3
files.  Then you can point your MP3 client at this URL:

   http://localhost:2001/stream.mp3 and point your browser at some good
starting place, such as this:

   http://localhost:2001/browse which will let you start browsing by the
default category, Genre.  After you've added some songs to the playlist,
you can press Play on the MP3 client, and it should start playing the
first song.

   Obviously, you could improve the user interface in any of a number of
ways-for instance, if you have a lot of MP3s in your library, it might
be useful to be able to browse artists or albums by the first letter of
their names.  Or maybe you could add a "Play whole album" button to the
playlist page that causes the playlist to immediately put all the songs
from the same album as the currently playing song at the top of the
playlist.  Or you could change the playlist class, so instead of playing
silence when there are no songs queued up, it picks a random song from
the database.  But all those ideas fall in the realm of application
design, which isn't really the topic of this book.  Instead, the next
two chapters will drop back to the level of software infrastructure to
cover how the FOO HTML generation library works.


File: pcl.info,  Node: Chapter 30,  Next: Chapter 31,  Prev: Chapter 29,  Up: Top

30. Practical: An HTML Generation Library, the Interpreter
==========================================================

In this chapter and the next you'll take a look under the hood of the
FOO HTML generator that you've been using in the past few chapters.  FOO
is an example of a kind of programming that's quite common in Common
Lisp and relatively uncommon in non-Lisp languages, namely,
language-oriented programming.  Rather than provide an API built
primarily out of functions, classes, and macros, FOO provides language
processors for a domain-specific language that you can embed in your
Common Lisp programs.

   FOO provides two language processors for the same s-expression
language.  One is an interpreter that takes a FOO "program" as data and
interprets it to generate HTML. The other is a compiler that compiles
FOO expressions, possibly with embedded Common Lisp code, into Common
Lisp that generates HTML and runs the embedded code.  The interpreter is
exposed as the function emit-html and the compiler as the macro html,
which you used in previous chapters.

   In this chapter you'll look at some of the infrastructure shared
between the interpreter and the compiler and then at the implementation
of the interpreter.  In the next chapter, I'll show you how the compiler
works.

* Menu:

* 30-1::       Designing a Domain-Specific Language
* 30-2::       The FOO Language
* 30-3::       Character Escaping
* 30-4::       Indenting Printer
* 30-5::       HTML Processor Interface
* 30-6::       The Pretty Printer Backend
* 30-7::       The Basic Evaluation Rule
* 30-8::       What's Next?


File: pcl.info,  Node: 30-1,  Next: 30-2,  Prev: Chapter 30,  Up: Chapter 30

Designing a Domain-Specific Language
====================================

Designing an embedded language requires two steps: first, design the
language that'll allow you to express the things you want to express,
and second, implement a processor, or processors, that accepts a
"program" in that language and either performs the actions indicated by
the program or translates the program into Common Lisp code that'll
perform equivalent behaviors.

   So, step one is to design the HTML-generating language.  The key to
designing a good domain-specific language is to strike the right balance
between expressiveness and concision.  For instance, a highly expressive
but not very concise "language" for generating HTML is the language of
literal HTML strings.  The legal "forms" of this language are strings
containing literal HTML. Language processors for this "language" could
process such forms by simply emitting them as-is.

   (defvar *html-output* *standard-output*)

   (defun emit-html (html) "An interpreter for the literal HTML
language."  (write-sequence html *html-output*))

   (defmacro html (html) "A compiler for the literal HTML language."
'(write-sequence ,html *html-output*)) This "language" is highly
expressive since it can express any HTML you could possibly want to
generate.1 On the other hand, this language doesn't win a lot of points
for its concision because it gives you zero compression-its input is its
output.

   To design a language that gives you some useful compression without
sacrificing too much expressiveness, you need to identify the details of
the output that are either redundant or uninteresting.  You can then
make those aspects of the output implicit in the semantics of the
language.

   For instance, because of the structure of HTML, every opening tag is
paired with a matching closing tag.2 When you write HTML by hand, you
have to write those closing tags, but you can improve the concision of
your HTML-generating language by making the closing tags implicit.

   Another way you can gain concision at a slight cost in expressiveness
is to make the language processors responsible for adding appropriate
whitespace between elements-blank lines and indentation.  When you're
generating HTML programmatically, you typically don't care much about
which elements have line breaks before or after them or about whether
different elements are indented relative to their parent elements.
Letting the language processor insert whitespace according to some rule
means you don't have to worry about it.  As it turns out, FOO actually
supports two modes-one that uses the minimum amount of whitespace, which
allows it to generate extremely efficient code and compact HTML, and
another that generates nicely formatted HTML with different elements
indented and separated from other elements according to their role.

   Another detail that's best moved into the language processor is the
escaping of certain characters that have a special meaning in HTML such
as <, >, and &.  Obviously, if you generate HTML by just printing
strings to a stream, then it's up to you to replace any occurrences of
those characters in the string with the appropriate escape sequences,
&lt;, &gt; and &amp;.  But if the language processor can know which
strings are to be emitted as element data, then it can take care of
automatically escaping those characters for you.


File: pcl.info,  Node: 30-2,  Next: 30-3,  Prev: 30-1,  Up: Chapter 30

The FOO Language
================

So, enough theory.  I'll give you a quick overview of the language
implemented by FOO, and then you'll look at the implementation of the
two FOO language processors-the interpreter, in this chapter, and the
compiler, in the next.

   Like Lisp itself, the basic syntax of the FOO language is defined in
terms of forms made up of Lisp objects.  The language defines how each
legal FOO form is translated into HTML.

   The simplest FOO forms are self-evaluating Lisp objects such as
strings, numbers, and keyword symbols.3 You'll need a function
self-evaluating-p that tests whether a given object is self-evaluating
for FOO's purposes.

   (defun self-evaluating-p (form) (and (atom form) (if (symbolp form)
(keywordp form) t))) Objects that satisfy this predicate will be emitted
by converting them to strings with PRINC-TO-STRING and then escaping any
reserved characters, such as <, >, or &.  When the value is being
emitted as an attribute, the characters ", and ' are also escaped.
Thus, you can invoke the html macro on a self-evaluating object to emit
it to *html-output* (which is initially bound to *STANDARD-OUTPUT*).
Table 30-1 shows how a few different self-evaluating values will be
output.

   Table 30-1.  FOO Output for Self-Evaluating Objects FOO Form
Generated HTML "foo"	foo 10	10 :foo	FOO "foo & bar"	foo &amp; bar Of
course, most HTML consists of tagged elements.  The three pieces of
information that describe each element are the tag, a set of attributes,
and a body containing text and/or more HTML elements.  Thus, you need a
way to represent these three pieces of information as Lisp objects,
preferably ones that the Lisp reader already knows how to read.4 If you
forget about attributes for a moment, there's an obvious mapping between
Lisp lists and HTML elements: any HTML element can be represented by a
list whose FIRST is a symbol where the name is the name of the element's
tag and whose REST is a list of self-evaluating objects or lists
representing other HTML elements.  Thus:

   <p>Foo</p> <==> (:p "Foo")

   <p><i>Now</i> is the time</p> <==> (:p (:i "Now") " is the time") Now
the only problem is where to squeeze in the attributes.  Since most
elements have no attributes, it'd be nice if you could use the preceding
syntax for elements without attributes.  FOO provides two ways to notate
elements with attributes.  The first is to simply include the attributes
in the list immediately following the symbol, alternating keyword
symbols naming the attributes and objects representing the attribute
value forms.  The body of the element starts with the first item in the
list that's in a position to be an attribute name and isn't a keyword
symbol.  Thus:

   HTML> (html (:p "foo")) <p>foo</p> NIL HTML> (html (:p "foo " (:i
"bar") " baz")) <p>foo <i>bar</i> baz</p> NIL HTML> (html (:p :style
"foo" "Foo")) <p style='foo'>Foo</p> NIL HTML> (html (:p :id "x" :style
"foo" "Foo")) <p id='x' style='foo'>Foo</p> NIL For folks who prefer a
bit more obvious delineation between the element's attributes and its
body, FOO supports an alternative syntax: if the first element of a list
is itself a list with a keyword as its first element, then the outer
list represents an HTML element with that keyword indicating the tag,
with the REST of the nested list as the attributes, and with the REST of
the outer list as the body.  Thus, you could write the previous two
expressions like this:

   HTML> (html ((:p :style "foo") "Foo")) <p style='foo'>Foo</p> NIL
HTML> (html ((:p :id "x" :style "foo") "Foo")) <p id='x'
style='foo'>Foo</p> NIL The following function tests whether a given
object matches either of these syntaxes:

   (defun cons-form-p (form &optional (test #'keywordp)) (and (consp
form) (or (funcall test (car form)) (and (consp (car form)) (funcall
test (caar form)))))) You should parameterize the test function because
later you'll need to test the same two syntaxes with a slightly
different predicate on the name.

   To completely abstract the differences between the two syntax
variants, you can define a function, parse-cons-form, that takes a form
and parses it into three elements, the tag, the attributes plist, and
the body list, returning them as multiple values.  The code that
actually evaluates cons forms will use this function and not have to
worry about which syntax was used.

   (defun parse-cons-form (sexp) (if (consp (first sexp))
(parse-explicit-attributes-sexp sexp) (parse-implicit-attributes-sexp
sexp)))

   (defun parse-explicit-attributes-sexp (sexp) (destructuring-bind
((tag &rest attributes) &body body) sexp (values tag attributes body)))

   (defun parse-implicit-attributes-sexp (sexp) (loop with tag = (first
sexp) for rest on (rest sexp) by #'cddr while (and (keywordp (first
rest)) (second rest)) when (second rest) collect (first rest) into
attributes and collect (second rest) into attributes end finally (return
(values tag attributes rest)))) Now that you have the basic language
specified, you can think about how you're actually going to implement
the language processors.  How do you get from a series of FOO forms to
the desired HTML? As I mentioned previously, you'll be implementing two
language processors for FOO: an interpreter that walks a tree of FOO
forms and emits the corresponding HTML directly and a compiler that
walks a tree and translates it into Common Lisp code that'll emit the
same HTML. Both the interpreter and compiler will be built on top of a
common foundation of code, which provides support for things such as
escaping reserved characters and generating nicely indented output, so
it makes sense to start there.


File: pcl.info,  Node: 30-3,  Next: 30-4,  Prev: 30-2,  Up: Chapter 30

Character Escaping
==================

The first bit of the foundation you'll need to lay is the code that
knows how to escape characters with a special meaning in HTML. There are
three such characters, and they must not appear in the text of an
element or in an attribute value; they are <, >, and &.  In element text
or attribute values, these characters must be replaced with the
character reference entities &lt;, &gt;, and &amp;.  Similarly, in
attribute values, the quotation marks used to delimit the value must be
escaped, ' with &apos; and " with &quot;.  Additionally, any character
can be represented by a numeric character reference entity consisting of
an ampersand, followed by a sharp sign, followed by the numeric code as
a base 10 integer, and followed by a semicolon.  These numeric escapes
are sometimes used to embed non-ASCII characters in HTML.

   The following function accepts a single character and returns a
string containing a character reference entity for that character:

   (defun escape-char (char) (case char (#\& "&amp;") (#\< "&lt;") (#\>
"&gt;") (#\' "&apos;") (#\" "&quot;") (t (format nil "&#~d;" (char-code
char))))) You can use this function as the basis for a function, escape,
that takes a string and a sequence of characters and returns a copy of
the first argument with all occurrences of the characters in the second
argument replaced with the corresponding character entity returned by
escape-char.

   (defun escape (in to-escape) (flet ((needs-escape-p (char) (find char
to-escape))) (with-output-to-string (out) (loop for start = 0 then (1+
pos) for pos = (position-if #'needs-escape-p in :start start) do
(write-sequence in out :start start :end pos) when pos do
(write-sequence (escape-char (char in pos)) out) while pos)))) You can
also define two parameters: *element-escapes*, which contains the
characters you need to escape in normal element data, and
*attribute-escapes*, which contains the set of characters to be escaped
in attribute values.

   (defparameter *element-escapes* "<>&") (defparameter
*attribute-escapes* "<>&\"'") Here are some examples:

   HTML> (escape "foo & bar" *element-escapes*) "foo &amp; bar" HTML>
(escape "foo & 'bar'" *element-escapes*) "foo &amp; 'bar'" HTML> (escape
"foo & 'bar'" *attribute-escapes*) "foo &amp; &apos;bar&apos;" Finally,
you'll need a variable, *escapes*, that will be bound to the set of
characters that need to be escaped.  It's initially set to the value of
*element-escapes*, but when generating attributes, it will, as you'll
see, be rebound to the value of *attribute-escapes*.

   (defvar *escapes* *element-escapes*)


File: pcl.info,  Node: 30-4,  Next: 30-5,  Prev: 30-3,  Up: Chapter 30

Indenting Printer
=================

To handle generating nicely indented output, you can define a class
indenting-printer, which wraps around an output stream, and functions
that use an instance of that class to emit strings to the stream while
keeping track of when it's at the beginning of the line.  The class
looks like this:

   (defclass indenting-printer () ((out :accessor out :initarg :out)
(beginning-of-line-p :accessor beginning-of-line-p :initform t)
(indentation :accessor indentation :initform 0) (indenting-p :accessor
indenting-p :initform t))) The main function that operates on
indenting-printers is emit, which takes the printer and a string and
emits the string to the printer's output stream, keeping track of when
it emits a newline so it can reset the beginning-of-line-p slot.

   (defun emit (ip string) (loop for start = 0 then (1+ pos) for pos =
(position #\Newline string :start start) do (emit/no-newlines ip string
:start start :end pos) when pos do (emit-newline ip) while pos)) To
actually emit the string, it uses the function emit/no-newlines, which
emits any needed indentation, via the helper indent-if-necessary, and
then writes the string to the stream.  This function can also be called
directly by other code to emit a string that's known not to contain any
newlines.

   (defun emit/no-newlines (ip string &key (start 0) end)
(indent-if-necessary ip) (write-sequence string (out ip) :start start
:end end) (unless (zerop (- (or end (length string)) start)) (setf
(beginning-of-line-p ip) nil))) The helper indent-if-necessary checks
beginning-of-line-p and indenting-p to determine whether it needs to
emit indentation and, if they're both true, emits as many spaces as
indicated by the value of indentation.  Code that uses the
indenting-printer can control the indentation by manipulating the
indentation and indenting-p slots.  Incrementing and decrementing
indentation changes the number of leading spaces, while setting
indenting-p to NIL can temporarily turn off indentation.

   (defun indent-if-necessary (ip) (when (and (beginning-of-line-p ip)
(indenting-p ip)) (loop repeat (indentation ip) do (write-char #\Space
(out ip))) (setf (beginning-of-line-p ip) nil))) The last two functions
in the indenting-printer API are emit-newline and emit-freshline, which
are both used to emit a newline character, similar to the ~% and ~&
FORMAT directives.  That is, the only difference is that emit-newline
always emits a newline, while emit-freshline does so only if
beginning-of-line-p is false.  Thus, multiple calls to emit-freshline
without any intervening emits won't result in a blank line.  This is
handy when one piece of code wants to generate some output that should
end with a newline while another piece of code wants to generate some
output that should start on a newline but you don't want a blank line
between the two bits of output.

   (defun emit-newline (ip) (write-char #\Newline (out ip)) (setf
(beginning-of-line-p ip) t))

   (defun emit-freshline (ip) (unless (beginning-of-line-p ip)
(emit-newline ip))) With those preliminaries out of the way, you're
ready to get to the guts of the FOO processor.


File: pcl.info,  Node: 30-5,  Next: 30-6,  Prev: 30-4,  Up: Chapter 30

HTML Processor Interface
========================

Now you're ready to define the interface that'll be used by the FOO
language processor to emit HTML. You can define this interface as a set
of generic functions because you'll need two implementations-one that
actually emits HTML and another that the html macro can use to collect a
list of actions that need to be performed, which can then be optimized
and compiled into code that emits the same output in a more efficient
way.  I'll call this set of generic functions the backend interface.  It
consists of the following eight generic functions:

   (defgeneric raw-string (processor string &optional newlines-p))

   (defgeneric newline (processor))

   (defgeneric freshline (processor))

   (defgeneric indent (processor))

   (defgeneric unindent (processor))

   (defgeneric toggle-indenting (processor))

   (defgeneric embed-value (processor value))

   (defgeneric embed-code (processor code)) While several of these
functions have obvious correspondence to indenting-printer functions,
it's important to understand that these generic functions define the
abstract operations that are used by the FOO language processors and
won't always be implemented in terms of calls to the indenting-printer
functions.

   That said, perhaps the easiest way to understand the semantics of
these abstract operations is to look at the concrete implementations of
the methods specialized on html-pretty-printer, the class used to
generate human-readable HTML.


File: pcl.info,  Node: 30-6,  Next: 30-7,  Prev: 30-5,  Up: Chapter 30

The Pretty Printer Backend
==========================

You can start by defining a class with two slots-one to hold an instance
of indenting-printer and one to hold the tab width-the number of spaces
you want to increase the indentation for each level of nesting of HTML
elements.

   (defclass html-pretty-printer () ((printer :accessor printer :initarg
:printer) (tab-width :accessor tab-width :initarg :tab-width :initform
2))) Now you can implement methods specialized on html-pretty-printer on
the eight generic functions that make up the backend interface.

   The FOO processors use the raw-string function to emit strings that
don't need character escaping, either because you actually want to emit
normally reserved characters or because all reserved characters have
already been escaped.  Usually raw-string is invoked with strings that
don't contain newlines, so the default behavior is to use
emit/no-newlines unless the caller specifies a non-NIL newlines-p
argument.

   (defmethod raw-string ((pp html-pretty-printer) string &optional
newlines-p) (if newlines-p (emit (printer pp) string) (emit/no-newlines
(printer pp) string))) The functions newline, freshline, indent,
unindent, and toggle-indenting implement fairly straightforward
manipulations of the underlying indenting-printer.  The only wrinkle is
that the HTML pretty printer generates pretty output only when the
dynamic variable *pretty* is true.  When it's NIL, you should generate
compact HTML with no unnecessary whitespace.  So, these methods, with
the exception of newline, all check *pretty* before doing anything:5

   (defmethod newline ((pp html-pretty-printer)) (emit-newline (printer
pp)))

   (defmethod freshline ((pp html-pretty-printer)) (when *pretty*
(emit-freshline (printer pp))))

   (defmethod indent ((pp html-pretty-printer)) (when *pretty* (incf
(indentation (printer pp)) (tab-width pp))))

   (defmethod unindent ((pp html-pretty-printer)) (when *pretty* (decf
(indentation (printer pp)) (tab-width pp))))

   (defmethod toggle-indenting ((pp html-pretty-printer)) (when *pretty*
(with-slots (indenting-p) (printer pp) (setf indenting-p (not
indenting-p))))) Finally, the functions embed-value and embed-code are
used only by the FOO compiler-embed-value is used to generate code
that'll emit the value of a Common Lisp expression, while embed-code is
used to embed a bit of code to be run and its result discarded.  In the
interpreter, you can't meaningfully evaluate embedded Lisp code, so the
methods on these functions always signal an error.

   (defmethod embed-value ((pp html-pretty-printer) value) (error "Can't
embed values when interpreting.  Value: ~s" value))

   (defmethod embed-code ((pp html-pretty-printer) code) (error "Can't
embed code when interpreting.  Code: ~s" code))


File: pcl.info,  Node: 30-7,  Next: 30-8,  Prev: 30-6,  Up: Chapter 30

The Basic Evaluation Rule
=========================

Now to connect the FOO language to the processor interface, all you need
is a function that takes an object and processes it, invoking the
appropriate processor functions to generate HTML. For instance, when
given a simple form like this:

   (:p "Foo") this function might execute this sequence of calls on the
processor:

   (freshline processor) (raw-string processor "<p" nil) (raw-string
processor ">" nil) (raw-string processor "Foo" nil) (raw-string
processor "</p>" nil) (freshline processor) For now you can define a
simple function that just checks whether a form is, in fact, a legal FOO
form and, if it is, hands it off to the function process-sexp-html for
processing.  In the next chapter, you'll add some bells and whistles to
this function to allow it to handle macros and special operators.  But
for now it looks like this:

   (defun process (processor form) (if (sexp-html-p form)
(process-sexp-html processor form) (error "Malformed FOO form: ~s"
form))) The function sexp-html-p determines whether the given object is
a legal FOO expression, either a self-evaluating form or a properly
formatted cons.

   (defun sexp-html-p (form) (or (self-evaluating-p form) (cons-form-p
form))) Self-evaluating forms are easily handled: just convert to a
string with PRINC-TO-STRING and escape the characters in the variable
*escapes*, which, as you'll recall, is initially bound to the value of
*element-escapes*.  Cons forms you pass off to process-cons-sexp-html.

   (defun process-sexp-html (processor form) (if (self-evaluating-p
form) (raw-string processor (escape (princ-to-string form) *escapes*) t)
(process-cons-sexp-html processor form))) The function
process-cons-sexp-html is then responsible for emitting the opening tag,
any attributes, the body, and the closing tag.  The main complication
here is that to generate pretty HTML, you need to emit fresh lines and
adjust the indentation according to the type of the element being
emitted.  You can categorize all the elements defined in HTML into one
of three categories: block, paragraph, and inline.  Block elements-such
as body and ul-are emitted with fresh lines before and after both their
opening and closing tags and with their contents indented one level.
Paragraph elements-such as p, li, and blockquote-are emitted with a
fresh line before the opening tag and after the closing tag.  Inline
elements are simply emitted in line.  The following three parameters
list the elements of each type:

   (defparameter *block-elements* '(:body :colgroup :dl :fieldset :form
:head :html :map :noscript :object :ol :optgroup :pre :script :select
:style :table :tbody :tfoot :thead :tr :ul))

   (defparameter *paragraph-elements* '(:area :base :blockquote :br
:button :caption :col :dd :div :dt :h1 :h2 :h3 :h4 :h5 :h6 :hr :input
:li :link :meta :option :p :param :td :textarea :th :title))

   (defparameter *inline-elements* '(:a :abbr :acronym :address :b :bdo
:big :cite :code :del :dfn :em :i :img :ins :kbd :label :legend :q :samp
:small :span :strong :sub :sup :tt :var)) The functions block-element-p
and paragraph-element-p test whether a given tag is a member of the
corresponding list.6

   (defun block-element-p (tag) (find tag *block-elements*))

   (defun paragraph-element-p (tag) (find tag *paragraph-elements*)) Two
other categorizations with their own predicates are the elements that
are always empty, such as br and hr, and the three elements, pre, style,
and script, in which whitespace is supposed to be preserved.  The former
are handled specially when generating regular HTML (in other words, not
XHTML) since they're not supposed to have a closing tag.  And when
emitting the three tags in which whitespace is preserved, you can
temporarily turn off indentation so the pretty printer doesn't add any
spaces that aren't part of the element's actual contents.

   (defparameter *empty-elements* '(:area :base :br :col :hr :img :input
:link :meta :param))

   (defparameter *preserve-whitespace-elements* '(:pre :script :style))

   (defun empty-element-p (tag) (find tag *empty-elements*))

   (defun preserve-whitespace-p (tag) (find tag
*preserve-whitespace-elements*)) The last piece of information you need
when generating HTML is whether you're generating XHTML since that
affects how you emit empty elements.

   (defparameter *xhtml* nil) With all that information, you're ready to
process a cons FOO form.  You use parse-cons-form to parse the list into
three parts, the tag symbol, a possibly empty plist of attribute
key/value pairs, and a possibly empty list of body forms.  You then emit
the opening tag, the body, and the closing tag with the helper functions
emit-open-tag, emit-element-body, and emit-close-tag.

   (defun process-cons-sexp-html (processor form) (when (string=
*escapes* *attribute-escapes*) (error "Can't use cons forms in
attributes: ~a" form)) (multiple-value-bind (tag attributes body)
(parse-cons-form form) (emit-open-tag processor tag body attributes)
(emit-element-body processor tag body) (emit-close-tag processor tag
body))) In emit-open-tag you have to call freshline when appropriate and
then emit the attributes with emit-attributes.  You need to pass the
element's body to emit-open-tag so when it's emitting XHTML, it knows
whether to finish the tag with /> or >.

   (defun emit-open-tag (processor tag body-p attributes) (when (or
(paragraph-element-p tag) (block-element-p tag)) (freshline processor))
(raw-string processor (format nil "<~(~a~)" tag)) (emit-attributes
processor attributes) (raw-string processor (if (and *xhtml* (not
body-p)) "/>" ">"))) In emit-attributes the attribute names aren't
evaluated since they must be keyword symbols, but you should invoke the
top-level process function to evaluate the attribute values, binding
*escapes* to *attribute-escapes*.  As a convenience for specifying
boolean attributes, whose value should be the name of the attribute, if
the value is T-not just any true value but actually T-then you replace
the value with the name of the attribute.7

   (defun emit-attributes (processor attributes) (loop for (k v) on
attributes by #'cddr do (raw-string processor (format nil " ~(~a~)='"
k)) (let ((*escapes* *attribute-escapes*)) (process processor (if (eql v
t) (string-downcase k) v))) (raw-string processor "'"))) Emitting the
element's body is similar to emitting the attribute values: you can loop
through the body calling process to evaluate each form.  The rest of the
code is dedicated to emitting fresh lines and adjusting the indentation
as appropriate for the type of element.

   (defun emit-element-body (processor tag body) (when (block-element-p
tag) (freshline processor) (indent processor)) (when
(preserve-whitespace-p tag) (toggle-indenting processor)) (dolist (item
body) (process processor item)) (when (preserve-whitespace-p tag)
(toggle-indenting processor)) (when (block-element-p tag) (unindent
processor) (freshline processor))) Finally, emit-close-tag, as you'd
probably expect, emits the closing tag (unless no closing tag is
necessary, such as when the body is empty and you're either emitting
XHTML or the element is one of the special empty elements).  Regardless
of whether you actually emit a close tag, you need to emit a final fresh
line for block and paragraph elements.

   (defun emit-close-tag (processor tag body-p) (unless (and (or *xhtml*
(empty-element-p tag)) (not body-p)) (raw-string processor (format nil
"</~(~a~)>" tag))) (when (or (paragraph-element-p tag) (block-element-p
tag)) (freshline processor))) The function process is the basic FOO
interpreter.  To make it a bit easier to use, you can define a function,
emit-html, that invokes process, passing it an html-pretty-printer and a
form to evaluate.  You can define and use a helper function,
get-pretty-printer, to get the pretty printer, which returns the current
value of *html-pretty-printer* if it's bound; otherwise, it makes a new
instance of html-pretty-printer with *html-output* as its output stream.

   (defun emit-html (sexp) (process (get-pretty-printer) sexp))

   (defun get-pretty-printer () (or *html-pretty-printer* (make-instance
'html-pretty-printer :printer (make-instance 'indenting-printer :out
*html-output*)))) With this function, you can emit HTML to
*html-output*.  Rather than expose the variable *html-output* as part of
FOO's public API, you should define a macro, with-html-output, that
takes care of binding the stream for you.  It also lets you specify
whether you want pretty HTML output, defaulting to the value of the
variable *pretty*.

   (defmacro with-html-output ((stream &key (pretty *pretty*)) &body
body) '(let* ((*html-output* ,stream) (*pretty* ,pretty)) ,@body))

   So, if you wanted to use emit-html to generate HTML to a file, you
could write the following:

   (with-open-file (out "foo.html" :direction output) (with-html-output
(out :pretty t) (emit-html *some-foo-expression*)))


File: pcl.info,  Node: 30-8,  Next: Chapter 31,  Prev: 30-7,  Up: Chapter 30

What's Next?
============

In the next chapter, you'll look at how to implement a macro that
compiles FOO expressions into Common Lisp so you can embed HTML
generation code directly into your Lisp programs.  You'll also extend
the FOO language to make it a bit more expressive by adding its own
flavor of special operators and macros.


File: pcl.info,  Node: Chapter 31,  Next: Chapter 32,  Prev: Chapter 30,  Up: Top

31. Practical: An HTML Generation Library, the Compiler
=======================================================

Now you're ready to look at how the FOO compiler works.  The main
difference between a compiler and an interpreter is that an interpreter
processes a program and directly generates some behavior-generating HTML
in the case of a FOO interpreter-but a compiler processes the same
program and generates code in some other language that will exhibit the
same behavior.  In FOO, the compiler is a Common Lisp macro that
translates FOO into Common Lisp so it can be embedded in a Common Lisp
program.  Compilers, in general, have the advantage over interpreters
that, because compilation happens in advance, they can spend a bit of
time optimizing the code they generate to make it more efficient.  The
FOO compiler does that, merging literal text as much as possible in
order to emit the same HTML with a smaller number of writes than the
interpreter uses.  When the compiler is a Common Lisp macro, you also
have the advantage that it's easy for the language understood by the
compiler to contain embedded Common Lisp-the compiler just has to
recognize it and embed it in the right place in the generated code.  The
FOO compiler will take advantage of this capability.

* Menu:

* 31-1::       The Compiler
* 31-2::       FOO Special Operators
* 31-3::       FOO Macros
* 31-4::       The Public API
* 31-5::       The End of the Line


File: pcl.info,  Node: 31-1,  Next: 31-2,  Prev: Chapter 31,  Up: Chapter 31

The Compiler
============

The basic architecture of the compiler consists of three layers.  First
you'll implement a class html-compiler that has one slot that holds an
adjustable vector that's used to accumulate ops representing the calls
made to the generic functions in the backend interface during the
execution of process.

   You'll then implement methods on the generic functions in the backend
interface that will store the sequence of actions in the vector.  Each
op is represented by a list consisting of a keyword naming the operation
and the arguments passed to the function that generated the op.  The
function sexp->ops implements the first phase of the compiler, compiling
a list of FOO forms by calling process on each form with an instance of
html-compiler.

   This vector of ops stored by the compiler is then passed to a
function that optimizes it, merging consecutive raw-string ops into a
single op that emits the combined string in one go.  The optimization
function can also, optionally, strip out ops that are needed only for
pretty printing, which is mostly important because it allows you to
merge more raw-string ops.

   Finally, the optimized ops vector is passed to a third function,
generate-code, that returns a list of Common Lisp expressions that will
actually output the HTML. When *pretty* is true, generate-code generates
code that uses the methods specialized on html-pretty-printer to output
pretty HTML. When *pretty* is NIL, it generates code that writes
directly to the stream *html-output*.

   The macro html actually generates a body that contains two
expansions, one generated with *pretty* bound to T and one with *pretty*
bound to NIL. Which expansion is used is determined by the runtime value
of *pretty*.  Thus, every function that contains a call to html will
contain code to generate both pretty and compact output.

   The other significant difference between the compiler and the
interpreter is that the compiler can embed Lisp forms in the code it
generates.  To take advantage of that, you need to modify the process
function so it calls the embed-code and embed-value functions when asked
to process an expression that's not a FOO form.  Since all
self-evaluating objects are valid FOO forms, the only forms that won't
be passed to process-sexp-html are lists that don't match the syntax for
FOO cons forms and non-keyword symbols, the only atoms that aren't
self-evaluating.  You can assume that any non-FOO cons is code to be run
inline and all symbols are variables whose value you should embed.

   (defun process (processor form) (cond ((sexp-html-p form)
(process-sexp-html processor form)) ((consp form) (embed-code processor
form)) (t (embed-value processor form)))) Now let's look at the compiler
code.  First you should define two functions that slightly abstract the
vector you'll use to save ops in the first two phases of compilation.

   (defun make-op-buffer () (make-array 10 :adjustable t :fill-pointer
0))

   (defun push-op (op ops-buffer) (vector-push-extend op ops-buffer))
Next you can define the html-compiler class and the methods specialized
on it to implement the backend interface.

   (defclass html-compiler () ((ops :accessor ops :initform
(make-op-buffer))))

   (defmethod raw-string ((compiler html-compiler) string &optional
newlines-p) (push-op '(:raw-string ,string ,newlines-p) (ops compiler)))

   (defmethod newline ((compiler html-compiler)) (push-op '(:newline)
(ops compiler)))

   (defmethod freshline ((compiler html-compiler)) (push-op
'(:freshline) (ops compiler)))

   (defmethod indent ((compiler html-compiler)) (push-op '(:indent) (ops
compiler)))

   (defmethod unindent ((compiler html-compiler)) (push-op '(:unindent)
(ops compiler)))

   (defmethod toggle-indenting ((compiler html-compiler)) (push-op
'(:toggle-indenting) (ops compiler)))

   (defmethod embed-value ((compiler html-compiler) value) (push-op
'(:embed-value ,value ,*escapes*) (ops compiler)))

   (defmethod embed-code ((compiler html-compiler) code) (push-op
'(:embed-code ,code) (ops compiler))) With those methods defined, you
can implement the first phase of the compiler, sexp->ops.

   (defun sexp->ops (body) (loop with compiler = (make-instance
'html-compiler) for form in body do (process compiler form) finally
(return (ops compiler)))) During this phase you don't need to worry
about the value of *pretty*: just record all the functions called by
process.  Here's what sexp->ops makes of a simple FOO form:

   HTML> (sexp->ops '((:p "Foo"))) #((:FRESHLINE) (:RAW-STRING "<p" NIL)
(:RAW-STRING ">" NIL) (:RAW-STRING "Foo" T) (:RAW-STRING "</p>" NIL)
(:FRESHLINE)) The next phase, optimize-static-output, takes a vector of
ops and returns a new vector containing the optimized version.  The
algorithm is simple-for each :raw-string op, it writes the string to a
temporary string buffer.  Thus, consecutive :raw-string ops will build
up a single string containing the concatenation of the strings that need
to be emitted.  Whenever you encounter an op other than a :raw-string
op, you convert the built-up string into a sequence of alternating
:raw-string and :newline ops with the helper function compile-buffer and
then add the next op.  This function is also where you strip out the
pretty printing ops if *pretty* is NIL.

   (defun optimize-static-output (ops) (let ((new-ops (make-op-buffer)))
(with-output-to-string (buf) (flet ((add-op (op) (compile-buffer buf
new-ops) (push-op op new-ops))) (loop for op across ops do (ecase (first
op) (:raw-string (write-sequence (second op) buf)) ((:newline
:embed-value :embed-code) (add-op op)) ((:indent :unindent :freshline
:toggle-indenting) (when *pretty* (add-op op))))) (compile-buffer buf
new-ops))) new-ops))

   (defun compile-buffer (buf ops) (loop with str =
(get-output-stream-string buf) for start = 0 then (1+ pos) for pos =
(position #\Newline str :start start) when (< start (length str)) do
(push-op '(:raw-string ,(subseq str start pos) nil) ops) when pos do
(push-op '(:newline) ops) while pos)) The last step is to translate the
ops into the corresponding Common Lisp code.  This phase also pays
attention to the value of *pretty*.  When *pretty* is true, it generates
code that invokes the backend generic functions on
*html-pretty-printer*, which will be bound to an instance of
html-pretty-printer.  When *pretty* is NIL, it generates code that
writes directly to *html-output*, the stream to which the pretty printer
would send its output.

   The actual function, generate-code, is trivial.

   (defun generate-code (ops) (loop for op across ops collect (apply
#'op->code op))) All the work is done by methods on the generic function
op->code specializing the op argument with an EQL specializer on the
name of the op.

   (defgeneric op->code (op &rest operands))

   (defmethod op->code ((op (eql :raw-string)) &rest operands)
(destructuring-bind (string check-for-newlines) operands (if *pretty*
'(raw-string *html-pretty-printer* ,string ,check-for-newlines)
'(write-sequence ,string *html-output*))))

   (defmethod op->code ((op (eql :newline)) &rest operands) (if *pretty*
'(newline *html-pretty-printer*) '(write-char #\Newline *html-output*)))

   (defmethod op->code ((op (eql :freshline)) &rest operands) (if
*pretty* '(freshline *html-pretty-printer*) (error "Bad op when not
pretty-printing: ~a" op)))

   (defmethod op->code ((op (eql :indent)) &rest operands) (if *pretty*
'(indent *html-pretty-printer*) (error "Bad op when not pretty-printing:
~a" op)))

   (defmethod op->code ((op (eql :unindent)) &rest operands) (if
*pretty* '(unindent *html-pretty-printer*) (error "Bad op when not
pretty-printing: ~a" op)))

   (defmethod op->code ((op (eql :toggle-indenting)) &rest operands) (if
*pretty* '(toggle-indenting *html-pretty-printer*) (error "Bad op when
not pretty-printing: ~a" op))) The two most interesting op->code methods
are the ones that generate code for the :embed-value and :embed-code
ops.  In the :embed-value method, you can generate slightly different
code depending on the value of the escapes operand since if escapes is
NIL, you don't need to generate a call to escape.  And when both
*pretty* and escapes are NIL, you can generate code that uses PRINC to
emit the value directly to the stream.

   (defmethod op->code ((op (eql :embed-value)) &rest operands)
(destructuring-bind (value escapes) operands (if *pretty* (if escapes
'(raw-string *html-pretty-printer* (escape (princ-to-string ,value)
,escapes) t) '(raw-string *html-pretty-printer* (princ-to-string ,value)
t)) (if escapes '(write-sequence (escape (princ-to-string ,value)
,escapes) *html-output*) '(princ ,value *html-output*))))) Thus,
something like this:

   HTML> (let ((x 10)) (html (:p x))) <p>10</p> NIL works because html
translates (:p x) into something like this:

   (progn (write-sequence "<p>" *html-output*) (write-sequence (escape
(princ-to-string x) "<>&") *html-output*) (write-sequence "</p>"
*html-output*)) When that code replaces the call to html in the context
of the LET, you get the following:

   (let ((x 10)) (progn (write-sequence "<p>" *html-output*)
(write-sequence (escape (princ-to-string x) "<>&") *html-output*)
(write-sequence "</p>" *html-output*))) and the reference to x in the
generated code turns into a reference to the lexical variable from the
LET surrounding the html form.

   The :embed-code method, on the other hand, is interesting because
it's so trivial.  Because process passed the form to embed-code, which
stashed it in the :embed-code op, all you have to do is pull it out and
return it.

   (defmethod op->code ((op (eql :embed-code)) &rest operands) (first
operands)) This allows code like this to work:

   HTML> (html (:ul (dolist (x '(foo bar baz)) (html (:li x))))) <ul>
<li>FOO</li> <li>BAR</li> <li>BAZ</li> </ul> NIL The outer call to html
expands into code that does something like this:

   (progn (write-sequence "<ul>" *html-output*) (dolist (x '(foo bar
baz)) (html (:li x))) (write-sequence "</ul>" *html-output*)))) Then if
you expand the call to html in the body of the DOLIST, you'll get
something like this:

   (progn (write-sequence "<ul>" *html-output*) (dolist (x '(foo bar
baz)) (progn (write-sequence "<li>" *html-output*) (write-sequence
(escape (princ-to-string x) "<>&") *html-output*) (write-sequence
"</li>" *html-output*))) (write-sequence "</ul>" *html-output*)) This
code will, in fact, generate the output you saw.


File: pcl.info,  Node: 31-2,  Next: 31-3,  Prev: 31-1,  Up: Chapter 31

FOO Special Operators
=====================

You could stop there; certainly the FOO language is expressive enough to
generate nearly any HTML you'd care to.  However, you can add two
features to the language, with just a bit more code, that will make it
quite a bit more powerful: special operators and macros.

   Special operators in FOO are analogous to special operators in Common
Lisp.  Special operators provide ways to express things in the language
that can't be expressed in the language supported by the basic
evaluation rule.  Or, another way to look at it is that special
operators provide access to the primitive mechanisms used by the
language evaluator.1

   To take a simple example, in the FOO compiler, the language evaluator
uses the embed-value function to generate code that will embed the value
of a variable in the output HTML. However, because only symbols are
passed to embed-value, there's no way, in the language I've described so
far, to embed the value of an arbitrary Common Lisp expression; the
process function passes cons cells to embed-code rather than
embed-value, so the values returned are ignored.  Typically this is what
you'd want, since the main reason to embed Lisp code in a FOO program is
to use Lisp control constructs.  However, sometimes you'd like to embed
computed values in the generated HTML. For example, you might like this
FOO program to generate a paragraph tag containing a random number:

   (:p (random 10)) But that doesn't work because the code is run and
its value discarded.

   HTML> (html (:p (random 10))) <p></p> NIL In the language, as you've
implemented it so far, you could work around this limitation by
computing the value outside the call to html and then embedding it via a
variable.

   HTML> (let ((x (random 10))) (html (:p x))) <p>1</p> NIL But that's
sort of annoying, particularly when you consider that if you could
arrange for the form (random 10) to be passed to embed-value instead of
embed-code, it'd do exactly what you want.  So, you can define a special
operator, :print, that's processed by the FOO language processor
according to a different rule than a normal FOO expression.  Namely,
instead of generating a <print> element, it passes the form in its body
to embed-value.  Thus, you can generate a paragraph containing a random
number like this:

   HTML> (html (:p (:print (random 10)))) <p>9</p> NIL Obviously, this
special operator is useful only in compiled FOO code since embed-value
doesn't work in the interpreter.  Another special operator that can be
used in both interpreted and compiled FOO code is :format, which lets
you generate output using the FORMAT function.  The arguments to the
:format special operator are a string used as a format control string
and then any arguments to be interpolated.  When all the arguments to
:format are self-evaluating objects, a string is generated by passing
them to FORMAT, and that string is then emitted like any other string.
This allows such :format forms to be used in FOO passed to emit-html.
In compiled FOO, the arguments to :format can be any Lisp expressions.

   Other special operators provide control over what characters are
automatically escaped and to explicitly emit newline characters: the
:noescape special operator causes all the forms in its body to be
evaluated as regular FOO forms but with *escapes* bound to NIL, while
:attribute evaluates the forms in its body with *escapes* bound to
*attribute-escapes*.  And :newline is translated into code to emit an
explicit newline.

   So, how do you define special operators?  There are two aspects to
processing special operators: how does the language processor recognize
forms that use special operators, and how does it know what code to run
to process each special operator?

   You could hack process-sexp-html to recognize each special operator
and handle it in the appropriate manner-special operators are,
logically, part of the implementation of the language, and there aren't
going to be that many of them.  However, it'd be nice to have a slightly
more modular way to add new special operators-not because users of FOO
will be able to but just for your own sanity.

   Define a special form as any list whose CAR is a symbol that's the
name of a special operator.  You can mark the names of special operators
by adding a non-NIL value to the symbol's property list under the key
html-special-operator.  So, you can define a function that tests whether
a given form is a special form like this:

   (defun special-form-p (form) (and (consp form) (symbolp (car form))
(get (car form) 'html-special-operator))) The code that implements each
special operator is responsible for taking apart the rest of the list
however it sees fit and doing whatever the semantics of the special
operator require.  Assuming you'll also define a function
process-special-form, which will take the language processor and a
special form and run the appropriate code to generate a sequence of
calls on the processor object, you can augment the top-level process
function to handle special forms like this:

   (defun process (processor form) (cond ((special-form-p form)
(process-special-form processor form)) ((sexp-html-p form)
(process-sexp-html processor form)) ((consp form) (embed-code processor
form)) (t (embed-value processor form)))) You must add the
special-form-p clause first because special forms can look,
syntactically, like regular FOO expressions just the way Common Lisp's
special forms can look like regular function calls.

   Now you just need to implement process-special-form.  Rather than
define a single monolithic function that implements all the special
operators, you should define a macro that allows you to define special
operators much like regular functions and that also takes care of adding
the html-special-operator entry to the property list of the special
operator's name.  In fact, the value you store in the property list can
be a function that implements the special operator.  Here's the macro:

   (defmacro define-html-special-operator (name (processor &rest
other-parameters) &body body) '(eval-when (:compile-toplevel
:load-toplevel :execute) (setf (get ',name 'html-special-operator)
(lambda (,processor ,@other-parameters) ,@body)))) This is a fairly
advanced type of macro, but if you take it one line at a time, there's
nothing all that tricky about it.  To see how it works, take a simple
use of the macro, the definition of the special operator :noescape, and
look at the macro expansion.  If you write this:

   (define-html-special-operator :noescape (processor &rest body) (let
((*escapes* nil)) (loop for exp in body do (process processor exp))))
it's as if you had written this:

   (eval-when (:compile-toplevel :load-toplevel :execute) (setf (get
':noescape 'html-special-operator) (lambda (processor &rest body) (let
((*escapes* nil)) (loop for exp in body do (process processor exp))))))
The EVAL-WHEN special operator, as I discussed in Chapter 20, ensures
that the effects of code in its body will be made visible during
compilation when you compile with COMPILE-FILE. This matters if you want
to use define-html-special-operator in a file and then use the
just-defined special operator in that same file.

   Then the SETF expression sets the property html-special-operator on
the symbol :noescape to an anonymous function with the same parameter
list as was specified in define-html-special-operator.  By defining
define-html-special-operator to split the parameter list in two parts,
processor and everything else, you ensure that all special operators
accept at least one argument.

   The body of the anonymous function is then the body provided to
define-html-special-operator.  The job of the anonymous function is to
implement the special operator by making the appropriate calls on the
backend interface to generate the correct HTML or the code that will
generate it.  It can also use process to evaluate an expression as a FOO
form.

   The :noescape special operator is particularly simple-all it does is
pass the forms in its body to process with *escapes* bound to NIL. In
other words, this special operator disables the normal character
escaping preformed by process-sexp-html.

   With special operators defined this way, all process-special-form has
to do is look up the anonymous function in the property list of the
special operator's name and APPLY it to the processor and rest of the
form.

   (defun process-special-form (processor form) (apply (get (car form)
'html-special-operator) processor (rest form))) Now you're ready to
define the five remaining FOO special operators.  Similar to :noescape
is :attribute, which evaluates the forms in its body with *escapes*
bound to *attribute-escapes*.  This special operator is useful if you
want to write helper functions that output attribute values.  If you
write a function like this:

   (defun foo-value (something) (html (:print (frob something)))) the
html macro is going to generate code that escapes the characters in
*element-escapes*.  But if you're planning to use foo-value like this:

   (html (:p :style (foo-value 42) "Foo")) then you want it to generate
code that uses *attribute-escapes*.  So, instead, you can write it like
this:2

   (defun foo-value (something) (html (:attribute (:print (frob
something))))) The definition of :attribute looks like this:

   (define-html-special-operator :attribute (processor &rest body) (let
((*escapes* *attribute-escapes*)) (loop for exp in body do (process
processor exp)))) The next two special operators, :print and :format,
are used to output values.  The :print special operator, as I discussed
earlier, is used in compiled FOO programs to embed the value of an
arbitrary Lisp expression.  The :format special operator is more or less
equivalent to generating a string with (format nil ...)  and then
embedding it.  The primary reason to define :format as a special
operator is for convenience.  This:

   (:format "Foo: ~d" x) is nicer than this:

   (:print (format nil "Foo: ~d" x)) It also has the slight advantage
that if you use :format with arguments that are all self-evaluating, FOO
can evaluate the :format at compile time rather than waiting until
runtime.  The definitions of :print and :format are as follows:

   (define-html-special-operator :print (processor form) (cond
((self-evaluating-p form) (warn "Redundant :print of self-evaluating
form ~s" form) (process-sexp-html processor form)) (t (embed-value
processor form))))

   (define-html-special-operator :format (processor &rest args) (if
(every #'self-evaluating-p args) (process-sexp-html processor (apply
#'format nil args)) (embed-value processor '(format nil ,@args)))) The
:newline special operator forces an output of a literal newline, which
is occasionally handy.

   (define-html-special-operator :newline (processor) (newline
processor)) Finally, the :progn special operator is analogous to the
PROGN special operator in Common Lisp.  It simply processes the forms in
its body in sequence.

   (define-html-special-operator :progn (processor &rest body) (loop for
exp in body do (process processor exp))) In other words, the following:

   (html (:p (:progn "Foo " (:i "bar") " baz"))) will generate the same
code as this:

   (html (:p "Foo " (:i "bar") " baz")) This might seem like a strange
thing to need since normal FOO expressions can have any number of forms
in their body.  However, this special operator will come in quite handy
in one situation-when writing FOO macros, which brings you to the last
language feature you need to implement.


File: pcl.info,  Node: 31-3,  Next: 31-4,  Prev: 31-2,  Up: Chapter 31

FOO Macros
==========

FOO macros are similar in spirit to Common Lisp's macros.  A FOO macro
is a bit of code that accepts a FOO expression as an argument and
returns a new FOO expression as the result, which is then evaluated
according to the normal FOO evaluation rules.  The actual implementation
is quite similar to the implementation of special operators.

   As with special operators, you can define a predicate function to
test whether a given form is a macro form.

   (defun macro-form-p (form) (cons-form-p form #'(lambda (x) (and
(symbolp x) (get x 'html-macro))))) You use the previously defined
function cons-form-p because you want to allow macros to be used in
either of the syntaxes of nonmacro FOO cons forms.  However, you need to
pass a different predicate function, one that tests whether the form
name is a symbol with a non-NIL html-macro property.  Also, as in the
implementation of special operators, you'll define a macro for defining
FOO macros, which is responsible for storing a function in the property
list of the macro's name, under the key html-macro.  However, defining a
macro is a bit more complicated because FOO supports two flavors of
macro.  Some macros you'll define will behave much like normal HTML
elements and may want to have easy access to a list of attributes.
Other macros will simply want raw access to the elements of their body.

   You can make the distinction between the two flavors of macros
implicit: when you define a FOO macro, the parameter list can include an
&attributes parameter.  If it does, the macro form will be parsed like a
regular cons form, and the macro function will be passed two values, a
plist of attributes and a list of expressions that make up the body of
the form.  A macro form without an &attributes parameter won't be parsed
for attributes, and the macro function will be invoked with a single
argument, a list containing the body expressions.  The former is useful
for what are essentially HTML templates.  For example:

   (define-html-macro :mytag (&attributes attrs &body body) '((:div
:class "mytag" ,@attrs) ,@body))

   HTML> (html (:mytag "Foo")) <div class='mytag'>Foo</div> NIL HTML>
(html (:mytag :id "bar" "Foo")) <div class='mytag' id='bar'>Foo</div>
NIL HTML> (html ((:mytag :id "bar") "Foo")) <div class='mytag'
id='bar'>Foo</div> NIL The latter kind of macro is more useful for
writing macros that manipulate the forms in their body.  This type of
macro can function as a kind of HTML control construct.  As a trivial
example, consider the following macro that implements an :if construct:

   (define-html-macro :if (test then else) '(if ,test (html ,then) (html
,else))) This macro allows you to write this:

   (:p (:if (zerop (random 2)) "Heads" "Tails")) instead of this
slightly more verbose version:

   (:p (if (zerop (random 2)) (html "Heads") (html "Tails"))) To
determine which kind of macro you should generate, you need a function
that can parse the parameter list given to define-html-macro.  This
function returns two values, the name of the &attributes parameter, or
NIL if there was none, and a list containing all the elements of args
after removing the &attributes marker and the subsequent list element.3

   (defun parse-html-macro-lambda-list (args) (let ((attr-cons (member
'&attributes args))) (values (cadr attr-cons) (nconc (ldiff args
attr-cons) (cddr attr-cons)))))

   HTML> (parse-html-macro-lambda-list '(a b c)) NIL (A B C) HTML>
(parse-html-macro-lambda-list '(&attributes attrs a b c)) ATTRS (A B C)
HTML> (parse-html-macro-lambda-list '(a b c &attributes attrs)) ATTRS (A
B C) The element following &attributes in the parameter list can also be
a destructuring parameter list.

   HTML> (parse-html-macro-lambda-list '(&attributes (&key x y) a b c))
(&KEY X Y) (A B C) Now you're ready to write define-html-macro.
Depending on whether there was an &attributes parameter specified, you
need to generate one form or the other of HTML macro so the main macro
simply determines which kind of HTML macro it's defining and then calls
out to a helper function to generate the right kind of code.

   (defmacro define-html-macro (name (&rest args) &body body)
(multiple-value-bind (attribute-var args) (parse-html-macro-lambda-list
args) (if attribute-var (generate-macro-with-attributes name
attribute-var args body) (generate-macro-no-attributes name args
body)))) The functions that actually generate the expansion look like
this:

   (defun generate-macro-with-attributes (name attribute-args args body)
(with-gensyms (attributes form-body) (if (symbolp attribute-args) (setf
attribute-args '(&rest ,attribute-args))) '(eval-when (:compile-toplevel
:load-toplevel :execute) (setf (get ',name 'html-macro-wants-attributes)
t) (setf (get ',name 'html-macro) (lambda (,attributes ,form-body)
(destructuring-bind (,@attribute-args) ,attributes (destructuring-bind
(,@args) ,form-body ,@body)))))))

   (defun generate-macro-no-attributes (name args body) (with-gensyms
(form-body) '(eval-when (:compile-toplevel :load-toplevel :execute)
(setf (get ',name 'html-macro-wants-attributes) nil) (setf (get ',name
'html-macro) (lambda (,form-body) (destructuring-bind (,@args)
,form-body ,@body))))) The macro functions you'll define accept either
one or two arguments and then use DESTRUCTURING-BIND to take them apart
and bind them to the parameters defined in the call to
define-html-macro.  In both expansions you need to save the macro
function in the name's property list under html-macro and a boolean
indicating whether the macro takes an &attributes parameter under the
property html-macro-wants-attributes.  You use that property in the
following function, expand-macro-form, to determine how the macro
function should be invoked:

   (defun expand-macro-form (form) (if (or (consp (first form)) (get
(first form) 'html-macro-wants-attributes)) (multiple-value-bind (tag
attributes body) (parse-cons-form form) (funcall (get tag 'html-macro)
attributes body)) (destructuring-bind (tag &body body) form (funcall
(get tag 'html-macro) body)))) The last step is to integrate macros by
adding a clause to the dispatching COND in the top-level process
function.

   (defun process (processor form) (cond ((special-form-p form)
(process-special-form processor form)) ((macro-form-p form) (process
processor (expand-macro-form form))) ((sexp-html-p form)
(process-sexp-html processor form)) ((consp form) (embed-code processor
form)) (t (embed-value processor form)))) This is the final version of
process.


File: pcl.info,  Node: 31-4,  Next: 31-5,  Prev: 31-3,  Up: Chapter 31

The Public API
==============

Now, at long last, you're ready to implement the html macro, the main
entry point to the FOO compiler.  The other parts of FOO's public API
are emit-html and with-html-output, which I discussed in the previous
chapter, and define-html-macro, which I discussed in the previous
section.  The define-html-macro macro needs to be part of the public API
because FOO's users will want to write their own HTML macros.  On the
other hand, define-html-special-operator isn't part of the public API
because it requires too much knowledge of FOO's internals to define a
new special operator.  And there should be very little that can't be
done using the existing language and special operators.4

   One last element of the public API, before I get to html, is another
macro, in-html-style.  This macro controls whether FOO generates XHTML
or regular HTML by setting the *xhtml* variable.  The reason this needs
to be a macro is because you'll want to wrap the code that sets *xhtml*
in an EVAL-WHEN so you can set it in a file and have it affect uses of
the html macro later in that same file.

   (defmacro in-html-style (syntax) (eval-when (:compile-toplevel
:load-toplevel :execute) (case syntax (:html (setf *xhtml* nil)) (:xhtml
(setf *xhtml* t))))) Finally let's look at html itself.  The only tricky
bit about implementing html comes from the need to generate code that
can be used to generate both pretty and compact output, depending on the
runtime value of the variable *pretty*.  Thus, html needs to generate an
expansion that contains an IF expression and two versions of the code,
one compiled with *pretty* bound to true and one compiled with it bound
to NIL. To further complicate matters, it's common for one html call to
contain embedded calls to html, like this:

   (html (:ul (dolist (item stuff)) (html (:li item)))) If the outer
html expands into an IF expression with two versions of the code, one
for when *pretty* is true and one for when it's false, it's silly for
nested html forms to expand into two versions too.  In fact, it'll lead
to an exponential explosion of code since the nested html is already
going to be expanded twice-once in the *pretty*-is-true branch and once
in the *pretty*-is-false branch.  If each expansion generates two
versions, then you'll have four total versions.  And if the nested html
form contained another nested html form, you'd end up with eight
versions of that code.  If the compiler is smart, it'll eventually
realize that most of that generated code is dead and will eliminate it,
but even figuring that out can take quite a bit of time, slowing down
compilation of any function that uses nested calls to html.

   Luckily, you can easily avoid this explosion of dead code by
generating an expansion that locally redefines the html macro, using
MACROLET, to generate only the right kind of code.  First you define a
helper function that takes the vector of ops returned by sexp->ops and
runs it through optimize-static-output and generate-code-the two phases
that are affected by the value of *pretty*-with *pretty* bound to a
specified value and that interpolates the resulting code into a PROGN.
(The PROGN returns NIL just to keep things tidy.).

   (defun codegen-html (ops pretty) (let ((*pretty* pretty)) '(progn
,@(generate-code (optimize-static-output ops)) nil))) With that
function, you can then define html like this:

   (defmacro html (&whole whole &body body) (declare (ignore body)) '(if
*pretty* (macrolet ((html (&body body) (codegen-html (sexp->ops body)
t))) (let ((*html-pretty-printer* (get-pretty-printer))) ,whole))
(macrolet ((html (&body body) (codegen-html (sexp->ops body) nil)))
,whole))) The &whole parameter represents the original html form, and
because it's interpolated into the expansion in the bodies of the two
MACROLETs, it will be reprocessed with each of the new definitions of
html, the one that generates pretty-printing code and the other that
generates non-pretty-printing code.  Note that the variable *pretty* is
used both during macro expansion and when the resulting code is run.
It's used at macro expansion time by codegen-html to cause generate-code
to generate one kind of code or the other.  And it's used at runtime, in
the IF generated by the top-level html macro, to determine whether the
pretty-printing or non-pretty-printing code should actually run.


File: pcl.info,  Node: 31-5,  Next: Chapter 32,  Prev: 31-4,  Up: Chapter 31

The End of the Line
===================

As usual, you could keep working with this code to enhance it in various
ways.  One interesting avenue to pursue is to use the underlying output
generation framework to emit other kinds of output.  In the version of
FOO you can download from the book's Web site, you'll find some code
that implements CSS output that can be integrated into HTML output in
both the interpreter and compiler.  That's an interesting case because
CSS's syntax can't be mapped to s-expressions in such a trivial way as
HTML's can.  However, if you look at that code, you'll see it's still
possible to define an s-expression syntax for representing the various
constructs available in CSS.

   A more ambitious undertaking would be to add support for generating
embedded JavaScript.  Done right, adding JavaScript support to FOO could
yield two big wins.  One is that after you define an s-expression syntax
that you can map to JavaScript syntax, then you can start writing
macros, in Common Lisp, to add new constructs to the language you use to
write client-side code, which will then be compiled to JavaScript.  The
other is that, as part of the FOO s-expression JavaScript to regular
JavaScript translation, you could deal with the subtle but annoying
differences between JavaScript implementations in different browsers.
That is, the JavaScript code that FOO generates could either contain the
appropriate conditional code to do one thing in one browser and another
in a different browser or could generate different code depending on
which browser you wanted to support.  Then if you use FOO in dynamically
generated pages, it could use information about the User-Agent making
the request to generate the right flavor of JavaScript for that browser.

   But if that interests you, you'll have to implement it yourself since
this is the end of the last practical chapter of this book.  In the next
chapter I'll wrap things up, discussing briefly some topics that I
haven't touched on elsewhere in the book such as how to find libraries,
how to optimize Common Lisp code, and how to deliver Lisp applications.


File: pcl.info,  Node: Chapter 32,  Prev: Chapter 31,  Up: Top

32. Conclusion: What's Next?
============================

I hope by now you're convinced that the title of this book isn't an
oxymoron.  However, it's quite likely there's some area of programming
that's of great practical importance to you that I haven't discussed at
all.  For instance, I haven't said anything about how to develop
graphical user interfaces (GUIs), how to connect to relational
databases, how to parse XML, or how to write programs that act as
clients for various network protocols.  Similarly, I haven't discussed
two topics that will become important when you write real applications
in Common Lisp: optimizing your Lisp code and packaging your application
for delivery.

   I'm obviously not going to cover all these topics in depth in this
final chapter.  Instead, I'll give you a few pointers you can use to
pursue whichever aspect of Lisp programming interests you most.

* Menu:

* 32-1::        Finding Lisp Libraries
* 32-2::        Interfacing with Other Languages
* 32-3::        Make It Work, Make It Right, Make It Fast
* 32-4::        Delivering Applications
* 32-5::        Where to Go Next


File: pcl.info,  Node: 32-1,  Next: 32-2,  Prev: Chapter 32,  Up: Chapter 32

Finding Lisp Libraries
======================

While the standard library of functions, data types, and macros that
comes with Common Lisp is quite large, it provides only general-purpose
programming constructs.  Specialized tasks such as writing GUIs, talking
to databases, and parsing XML require libraries beyond what are provided
by the ANSI standardized language.

   The easiest way to obtain a library to do something you need may be
simply to check out your Lisp implementation.  Most implementations
provide at least some facilities not specified in the language standard.
The commercial Common Lisp vendors tend to work especially hard at
providing additional libraries for their implementation in order to
justify their prices.  Franz's Allegro Common Lisp, Enterprise Edition,
for instance, comes with libraries for parsing XML, speaking SOAP,
generating HTML, connecting to relational databases, and building
graphical interfaces in various ways, among others.  LispWorks, another
prominent commercial Lisp, provides several similar libraries, including
a well-regarded portable GUI toolkit, CAPI, which can be used to develop
GUI applications that will run on any operating system LispWorks runs
on.

   The free and open-source Common Lisp implementations typically don't
include quite so many bundled libraries, relying instead on portable
free and open-source libraries.  But even those implementations usually
fill in some of the more important areas not addressed by the language
standard such as networking and multithreading.

   The only disadvantage of using implementation-specific libraries is
that they tie you to the implementation that provides them.  If you're
delivering end-user apps or are deploying a server-based application on
a server that you control, that may not matter a lot.  But if you want
to write code to share with other Lispers or if you simply don't want to
be tied to a particular implementation, it's a little more annoying.

   For portable libraries-portable either because they're written
entirely in standard Common Lisp or because they contain appropriate
read-time conditionalization to work on multiple implementations1-your
best bet is to go to the Web.  With the usual caveats about URLs going
stale as soon as they're printed on paper, these are three of the best
current starting points:

   * Common-Lisp.net (http://www.common-lisp.net/) is a site that hosts
     free and open-source Common Lisp projects, providing version
     control, mailing lists, and Web hosting of project pages.  In the
     first year and a half after the site went live, nearly a hundred
     projects were registered.
   * The Common Lisp Open Code Collection (CLOCC)
     (http://clocc.sourceforge.net/) is a slightly older collection of
     free software libraries, which are intended to be portable between
     Common Lisp implementations and self-contained, not relying on any
     libraries not included in CLOCC itself.
   * Cliki (http://www.cliki.net/) is a wiki devoted to free software in
     Common Lisp.  While, like any wiki, it may change at any time,
     typically it has quite a few links to libraries as well to various
     open-source Common Lisp implementations.  The eponymous software it
     runs on is also written in Common Lisp.

   Linux users running the Debian or Gentoo distributions can also
easily install an ever-growing number of Lisp libraries that have been
packaged with those distributions' packing tools, apt-get on Debian and
emerge on Gentoo.

   I won't recommend any specific libraries here since the library
situation is changing every day-after years of envying the library
collections of Perl, Python, and Java, Common Lispers have, in the past
couple of years, begun to take up the challenge of giving Common Lisp
the set of libraries-both open source and commercial-that it deserves.

   One area where there has been a lot of activity recently is on the
GUI front.  Unlike Java and C# but like Perl, Python, and C, there's no
single way to develop GUIs in Common Lisp.  Instead, it depends both on
what Common Lisp implementation you're using and what operating system
or systems you want to support.

   The commercial Common Lisp implementations usually provide some way
to build GUIs for the platforms they run on.  Additionally, LispWorks
provides CAPI, the previously mentioned, portable GUI API.

   On the open-source side, you have a number of options.  On Unix, you
can write low-level X Windows GUIs using CLX, a pure-Common Lisp
implementation of the X Windows protocol, roughly akin to xlib in C. Or
you can use various bindings to higher-level APIs and toolkits such as
GTK and Tk, much the way you might in Perl or Python.

   Or, if you're looking for something completely different, you can
check out Common Lisp Interface Manager (CLIM). A descendant of the
Symbolics Lisp Machines GUI framework, CLIM is powerful but complex.
Although many commercial Common Lisp implementations actually support
it, it doesn't seem to have seen a lot of use.  But in the past couple
years, an open-source implementation of CLIM, McCLIM-now hosted at
Common-Lisp.net-has been picking up steam lately, so we may be on the
verge of a CLIM renaissance.


File: pcl.info,  Node: 32-2,  Next: 32-3,  Prev: 32-1,  Up: Chapter 32

Interfacing with Other Languages
================================

While many useful libraries can be written in "pure" Common Lisp using
only the features specified in the language standard, and many more can
be written in Lisp using nonstandard facilities provided by a given
implementation, occasionally it's more straightforward to use an
existing library written in another language, such as C.

   The language standard doesn't specify a mechanism for Lisp code to
call code written in another language or even require that
implementations provide such a mechanism.  But these days, almost all
Common Lisp implementations support what's called a Foreign Function
Interface, or FFI for short.2 The basic job of an FFI is to allow you to
give Lisp enough information to be able to link in the foreign code.
Thus, if you're going to call a function from a C library, you need to
tell Lisp about how to translate the Lisp objects passed to the function
into C types and the value returned by the function back into a Lisp
object.  However, each implementation provides its own FFI, each with
slightly varying capabilities and syntax.  Some FFIs allow callbacks
from C to Lisp, and others don't.  The Universal Foreign Function
Interface (UFFI) project provides a portability layer over the FFIs of
more than a half dozen different Common Lisp implementations.  It works
by defining its own macros that expand into appropriate FFI code for the
implementation it's running in.  The UFFI takes a lowest common
denominator approach, which means it can't take advantage of all the
features of different implementations' FFIs, but it does provide a good
way to build a simple Lisp wrapper around a basic C API.3


File: pcl.info,  Node: 32-3,  Next: 32-4,  Prev: 32-2,  Up: Chapter 32

Make It Work, Make It Right, Make It Fast
=========================================

As has been said many times, and variously attributed to Donald Knuth,
C.A.R. Hoare, and Edsger Dijkstra, premature optimization is the root of
all evil.4 Common Lisp is an excellent language to program in if you
want to heed this wisdom yet still need high performance.  This may come
as a surprise if you've heard the conventional wisdom that Lisp is slow.
In Lisp's earliest days, when computers were programmed with punch
cards, Lisp's high-level features may have doomed it to be slower than
the competition, namely, assembly and FORTRAN. But that was a long time
ago.  In the meantime, Lisp has been used for everything from creating
complex AI systems to writing operating systems, and a lot of work has
gone into figuring out how to compile Lisp into efficient code.  In this
section I'll talk about some of the reasons why Common Lisp is an
excellent language for writing high-performance code and some of the
techniques for doing so.

   The first reason that Lisp is an excellent language for writing
high-performance code is, ironically enough, the dynamic nature of Lisp
programming-the very thing that originally made it hard to bring Lisp's
performance up to the levels achieved by FORTRAN compilers.  The reason
Common Lisp's dynamic features make it easier to write high-performance
code is that the first step to writing efficient code is to find the
right algorithms and data structures.

   Common Lisp's dynamic features keep code flexible, which makes it
easier to try different approaches.  Given a finite amount of time to
write a program, you're much more likely to end up with a
high-performance version if you don't spend a lot of time getting into
and out of dead ends.  In Common Lisp, you can try an idea, see it's
going nowhere, and move on without having spent a ton of time convincing
the compiler your code is worthy of being run and then waiting for it to
finish compiling.  You can write a straightforward but inefficient
version of a function-a code sketch-to determine whether your basic
approach is sound and then replace that function with a more complex but
more efficient implementation if you determine that it is.  And if the
overall approach turns out to be flawed, then you haven't wasted a bunch
of time tuning a function that's no longer needed, which means you have
more time to find a better approach.

   The next reason Common Lisp is a good language for developing
high-performance software is that most Common Lisp implementations come
with mature compilers that generate quite efficient machine code.  I'll
talk in a moment about how to help these compilers generate code that
will be competitive with code generated by C compilers, but these
implementations already are quite a bit faster than those of languages
whose implementations are less mature and use simpler compilers or
interpreters.  Also, since the Lisp compiler is available at runtime,
the Lisp programmer has some possibilities that would be hard to emulate
in other languages-your programs can generate Lisp code at runtime
that's then compiled into machine code and run.  If the generated code
is going to run enough times, this can be a big win.  Or, even without
using the compiler at runtime, closures give you another way to meld
machine code with runtime data.  For instance, the CL-PPCRE regular
expression library, running in CMUCL, is faster than Perl's regular
expression engine on some benchmarks, even though Perl's engine is
written in highly tuned C. This is presumably because in Perl a regular
expression is translated into what are essentially bytecodes that are
then interpreted by the regex engine, while CL-PPCRE translates a
regular expression into a tree of compiled closures that invoke each
other via the normal function-calling machinery.5

   However, even with the right algorithm and a high-quality compiler,
you may not get the raw speed you need.  Then it's time to think about
profiling and tuning.  The key, in Lisp as in any language, is to
profile first to find the spots where your program is actually spending
its time and then worry about speeding up those parts.6

   You have a number of different ways to approach profiling.  The
language standard provides a few rudimentary tools for measuring how
long certain forms take to execute.  In particular, the TIME macro can
be wrapped around any form and will return whatever values the form
returns after printing a message to *TRACE-OUTPUT* about how long it
took to run and how much memory it used.  The exact form of the message
is implementation defined.

   You can use TIME for a bit of quick-and-dirty profiling to narrow
your search for bottlenecks.  For instance, suppose you have a function
that's taking a long time to run and that calls two other
functions-something like this:

     (defun foo ()
       (bar)
       (baz))

   If you want to see whether bar or baz is taking more time, you can
change the definition of foo to this:

     (defun foo ()
       (time (bar))
       (time (baz)))

   Now you can call foo, and Lisp will print two reports, one for bar
and one for baz.  The form is implementation dependent; here's what it
looks like in Allegro Common Lisp:

     CL-USER> (foo)
     ; cpu time (non-gc) 60 msec user, 0 msec system
     ; cpu time (gc)     0 msec user, 0 msec system
     ; cpu time (total)  60 msec user, 0 msec system
     ; real time  105 msec
     ; space allocation:
     ;  24,172 cons cells, 1,696 other bytes, 0 static bytes
     ; cpu time (non-gc) 540 msec user, 10 msec system
     ; cpu time (gc)     170 msec user, 0 msec system
     ; cpu time (total)  710 msec user, 10 msec system
     ; real time  1,046 msec
     ; space allocation:
     ;  270,172 cons cells, 1,696 other bytes, 0 static bytes

   Of course, that'd be a bit easier to read if the output included a
label.  If you use this technique a lot, it might be worth defining your
own macro like this:

     (defmacro labeled-time (form)
       `(progn
         (format *trace-output* "~2&~a" ',form)
         (time ,form)))

   If you replace TIME with labeled-time in foo, you'll get this output:

     CL-USER> (foo)

     (BAR)
     ; cpu time (non-gc) 60 msec user, 0 msec system
     ; cpu time (gc)     0 msec user, 0 msec system
     ; cpu time (total)  60 msec user, 0 msec system
     ; real time  131 msec
     ; space allocation:
     ;  24,172 cons cells, 1,696 other bytes, 0 static bytes

     (BAZ)
     ; cpu time (non-gc) 490 msec user, 0 msec system
     ; cpu time (gc)     190 msec user, 10 msec system
     ; cpu time (total)  680 msec user, 10 msec system
     ; real time  1,088 msec
     ; space allocation:
     ;  270,172 cons cells, 1,696 other bytes, 0 static bytes

   From this output, it's clear that most of the time in foo is spent in
baz.

   Of course, the output from TIME gets a bit unwieldy if the form you
want to profile is called repeatedly.  You can build your own
measurement tools using the functions GET-INTERNAL-REAL-TIME and
GET-INTERNAL-RUN-TIME, which return a number that increases by the value
of the constant INTERNAL-TIME-UNITS-PER-SECOND each second.
GET-INTERNAL-REAL-TIME measures wall time, the actual amount of time
elapsed, while GET-INTERNAL-RUN-TIME measures some
implementation-defined value such as the amount of time Lisp was
actually executing or the time Lisp was executing user code and not
internal bookkeeping such as the garbage collector.  Here's a trivial
but useful profiling tool built with a few macros and
GET-INTERNAL-RUN-TIME:

     (defparameter *timing-data* ())

     (defmacro with-timing (label &body body)
       (with-gensyms (start)
         `(let ((,start (get-internal-run-time)))
           (unwind-protect (progn ,@body)
             (push (list ',label ,start (get-internal-run-time)) *timing-data*)))))

     (defun clear-timing-data ()
       (setf *timing-data* ()))

     (defun show-timing-data ()
       (loop for (label time count time-per %-of-total) in (compile-timing-data) do
            (format t "~3d% ~a: ~d ticks over ~d calls for ~d per.~%"
                    %-of-total label time count time-per)))

     (defun compile-timing-data ()
       (loop with timing-table = (make-hash-table)
          with count-table = (make-hash-table)
          for (label start end) in *timing-data*
          for time = (- end start)
          summing time into total
          do
            (incf (gethash label timing-table 0) time)
            (incf (gethash label count-table 0))
          finally
            (return
              (sort
               (loop for label being the hash-keys in timing-table collect
                    (let  ((time (gethash label timing-table))
                           (count (gethash label count-table)))
                      (list label time count (round (/ time count)) (round (* 100 (/ time total))))))
               #'> :key #'fifth))))

   This profiler lets you wrap a with-timing around any form; each time
the form is executed, the time it starts and the time it ends are
recorded, associating with a label you provide.  The function
show-timing-data dumps out a table showing how much time was spent in
different labeled sections of code like this:

     CL-USER> (show-timing-data)
      84% BAR: 650 ticks over 2 calls for 325 per.
      16% FOO: 120 ticks over 5 calls for 24 per.
     NIL

   You could obviously make this profiling code more sophisticated in
many ways.  Alternatively, your Lisp implementation most likely provides
its own profiling tools, which, since they have access to the internals
of the implementation, can get at information not necessarily available
to user-level code.

   Once you've found the bottleneck in your code, you can start tuning.
The first thing you should try, of course, is to find a more efficient
basic algorithm-that's where the big gains are to be had.  But assuming
you're already using an appropriate algorithm, then it's down to code
bumming-locally optimizing the code so it does absolutely no more work
than necessary.

   The main tools for code bumming in Common Lisp are its optional
declarations.  The basic idea behind declarations in Common Lisp is that
they're used to give the compiler information it can use in a variety of
ways to generate better code.

   For a simple example, consider this Common Lisp function:

     (defun add (x y) (+ x y))

   I mentioned in Chapter 10 (*Note Chapter 10::.)  that if you compare
the performance of this function Lisp to the seemingly equivalent C
function:

     int add (int x, int y) { return x + y; }

   you'll likely find the Common Lisp version to be quite a bit slower,
even if your Common Lisp implementation features a high-quality native
compiler.

   That's because the Common Lisp version is doing a lot more-the Common
Lisp compiler doesn't even know that the values of a and b are numbers
and so has to generate code to check at runtime.  And once it determines
they are numbers, it has to determine what types of numbers-integers,
rationals, floating point, or complex-and dispatch to the appropriate
addition routine for the actual types.  And even if a and b are
integers-the case you care about-then the addition routine has to
account for the possibility that the result may be too large to
represent as a fixnum, a number that can be represented in a single
machine word, and thus it may have to allocate a bignum object.

   In C, on the other hand, because the type of all variables are
declared, the compiler knows exactly what kind of values a and b will
hold.  And because C's arithmetic simply overflows when the result of an
addition is too large to represent in whatever type is being returned,
there's no checking for overflow and no allocation of a bignum object to
represent the result when the mathematical sum is too large to fit in a
machine word.

   Thus, while the behavior of the Common Lisp code is much more likely
to be mathematically correct, the C version can probably be compiled
down to one or two machine instructions.  But if you're willing to give
the Common Lisp compiler the same information the C compiler has about
the types of arguments and return values and to accept certain C-like
compromises in terms of generality and error checking, the Common Lisp
function can also be compiled down to an instruction or two.

   That's what declarations are for.  The main use of declarations is to
tell the compiler about the types of variables and other expressions.
For instance, you could tell the compiler that the arguments to add are
both fixnums by writing the function like this:

     (defun add (x y)
       (declare (fixnum x y))
       (+ x y))

   The DECLARE expression isn't a Lisp form; rather, it's part of the
syntax of the DEFUN and must appear before any other code in the
function body.7 This declaration declares that the arguments passed for
the parameters x and y will always be fixnums.  In other words, it's a
promise to the compiler, and the compiler is allowed to generate code on
the assumption that whatever you tell it is true.

   To declare the type of the value returned, you can wrap the form (+ x
y) in the THE special operator.  This operator takes a type specifier,
such as FIXNUM, and a form and tells the compiler the form will evaluate
to the given type.  Thus, to give the Common Lisp compiler all the
information about add that the C compiler gets, you can write it like
this:

     (defun add (x y)
       (declare (fixnum x y))
       (the fixnum (+ x y)))

   However, even this version needs one more declaration to give the
Common Lisp compiler the same license as the C compiler to generate fast
but dangerous code.  The OPTIMIZE declaration is used to tell the
compiler how to balance five qualities: the speed of the code generated;
the amount of runtime error checking; the memory usage of the code, both
in terms of code size and runtime memory usage; the amount of debugging
information kept with the code; and the speed of the compilation
process.  An OPTIMIZE declaration consists of one or more lists, each
containing one of the symbols SPEED, SAFETY, SPACE, DEBUG, and
COMPILATION-SPEED, and a number from zero to three, inclusive.  The
number specifies the relative weighting the compiler should give to the
corresponding quality, with 3 being the most important and 0 meaning not
important at all.  Thus, to make Common Lisp compile add more or less
like a C compiler would, you can write it like this:

     (defun add (x y)
       (declare (optimize (speed 3) (safety 0)))
       (declare (fixnum x y))
       (the fixnum (+ x y)))

   Of course, now the Lisp version suffers from many of the same
liabilities as the C version-if the arguments passed aren't fixnums or
if the addition overflows, the result will be mathematically incorrect
or worse.  Also, if someone calls add with a wrong number of arguments,
it may not be pretty.  Thus, you should use these kinds of declarations
only after your program is working correctly.  And you should add them
only where profiling shows they'll make a difference.  If you're getting
reasonable performance without them, leave them out.  But when profiling
shows you a real hot spot in your code and you need to tune it up, go
ahead.  Because you can use declarations this way, it's rarely necessary
to rewrite code in C just for performance reasons; FFIs are used to
access existing C code, but declarations are used when C-like
performance is needed.  Of course, how close you can get the performance
of a given piece of Common Lisp code to C and C++ depends mostly on how
much like C you're willing to make it.

   Another code-tuning tool built into Lisp is the function DISASSEMBLE.
The exact behavior of this function is implementation dependent because
it depends on how the implementation compiles code-whether to machine
code, bytecodes, or some other form.  But the basic idea is that it
shows you the code generated by the compiler when it compiled a specific
function.

   Thus, you can use DISASSEMBLE to see whether your declarations are
having any effect on the code generated.  And if your Lisp
implementation uses a native compiler and you know your platform's
assembly language, you can get a pretty good sense of what's actually
going on when you call one of your functions.  For instance, you could
use DISASSEMBLE to get a sense of the difference between the first
version of add, with no declarations, and the final version.  First,
define and compile the original version.

     (defun add (x y) (+ x y))

   Then, at the REPL, call DISASSEMBLE with the name of the function.
In Allegro, it shows the following assembly-language-like dump of the
code generated by the compiler:

     CL-USER> (disassemble 'add)
     ;; disassembly of #<Function ADD>
     ;; formals: X Y

     ;; code start: #x737496f4:
        0: 55         pushl	ebp
        1: 8b ec    movl	ebp,esp
        3: 56         pushl	esi
        4: 83 ec 24 subl	esp,$36
        7: 83 f9 02 cmpl	ecx,$2
       10: 74 02    jz	14
       12: cd 61    int	$97   ; SYS::TRAP-ARGERR
       14: 80 7f cb 00 cmpb	[edi-53],$0        ; SYS::C_INTERRUPT-PENDING
       18: 74 02    jz	22
       20: cd 64    int	$100  ; SYS::TRAP-SIGNAL-HIT
       22: 8b d8    movl	ebx,eax
       24: 0b da    orl	ebx,edx
       26: f6 c3 03 testb	bl,$3
       29: 75 0e    jnz	45
       31: 8b d8    movl	ebx,eax
       33: 03 da    addl	ebx,edx
       35: 70 08    jo	45
       37: 8b c3    movl	eax,ebx
       39: f8         clc
       40: c9         leave
       41: 8b 75 fc movl	esi,[ebp-4]
       44: c3         ret
       45: 8b 5f 8f movl	ebx,[edi-113]    ; EXCL::+_2OP
       48: ff 57 27 call	*[edi+39]   ; SYS::TRAMP-TWO
       51: eb f3    jmp	40
       53: 90         nop
     ; No value

   Clearly, there's a bunch of stuff going on here.  If you're familiar
with x86 assembly language, you can probably tell what.  Now compile
this version of add with all the declarations.

     (defun add (x y)
       (declare (optimize (speed 3) (safety 0)))
       (declare (fixnum x y))
       (the fixnum (+ x y)))

   Now disassemble add again, and see if the declarations had any
effect.

     CL-USER> (disassemble 'add)
     ;; disassembly of #<Function ADD>
     ;; formals: X Y

     ;; code start: #x7374dc34:
        0: 03 c2    addl	eax,edx
        2: f8         clc
        3: 8b 75 fc movl	esi,[ebp-4]
        6: c3         ret
        7: 90         nop
     ; No value

   Looks like they did.


File: pcl.info,  Node: 32-4,  Next: 32-5,  Prev: 32-3,  Up: Chapter 32

Delivering Applications
=======================

Another topic of practical importance, which I didn't talk about
elsewhere in the book, is how to deliver software written in Lisp.  The
main reason I neglected this topic is because there are many different
ways to do it, and which one is best for you depends on what kind of
software you need to deliver to what kind of user with what Common Lisp
implementation.  In this section I'll give an overview of some of the
different options.

   If you've written code you want to share with fellow Lisp
programmers, the most straightforward way to distribute it is as source
code.8 You can distribute a simple library as a single source file,
which programmers can LOAD into their Lisp image, possibly after
compiling it with COMPILE-FILE.

   More complex libraries or applications, broken up across multiple
source files, pose an additional challenge-in order to load and compile
the code, the files need to be loaded and compiled in the correct order.
For instance, a file containing macro definitions must be loaded before
you can compile files that use those macros.  And a file containing
DEFPACKAGE forms must be loaded before any files that use those packages
can even be READ. Lispers call this the system definition problem and
typically handle it with tools called system definition facilities or
system definition utilities, which are somewhat analogous to build tools
such as make or ant.  As with make and ant, system definition tools
allow you to specify the dependencies between different files and then
take care of loading and compiling the files in the correct order while
trying to do only work that's necessary-recompiling only files that have
changed, for example.

   These days the most widely used system definition tool is ASDF, which
stands for Another System Definition Facility.9 The basic idea behind
ASDF is that you define systems in ASD files, and ASDF provides a number
of operations on systems such as loading them or compiling them.  A
system can also be defined to depend on other systems, which will be
loaded as necessary.  For instance, the following shows the contents of
html.asd, the ASD file for the FOO library from Chapters 31 and 32:

     (defpackage :com.gigamonkeys.html-system (:use :asdf :cl))
     (in-package :com.gigamonkeys.html-system)

     (defsystem html
       :name "html"
       :author "Peter Seibel <peter@gigamonkeys.com>"
       :version "0.1"
       :maintainer "Peter Seibel <peter@gigamonkeys.com>"
       :license "BSD"
       :description "HTML and CSS generation from sexps."
       :long-description ""
       :components
       ((:file "packages")
        (:file "html" :depends-on ("packages"))
        (:file "css" :depends-on ("packages" "html")))
       :depends-on (:macro-utilities))

   If you add a symbolic link to this file from a directory listed in
asdf:*central-registry*,10 then you can type this:

     (asdf:operate 'asdf:load-op :html)

   to compile and load the files packages.lisp, html.lisp, and
html-macros.lisp in the correct order after first making sure the
:macro-utilities system has been compiled and loaded.  For other
examples of ASD files, you can look at this book's source code-the code
from each practical chapter is defined as a system with appropriate
intersystem dependencies expressed in the ASD files.

   Most free and open-source Common Lisp libraries you'll find will come
with an ASD file.  Some will use other system definition tools such as
the slightly older MK:DEFSYSTEM or even utilities devised by the
library's author, but the tide seems to be turning in the direction of
ASDF.11

   Of course, while ASDF makes it easy for Lispers to install Lisp
libraries, it's not much help if you want to package an application for
an end user who doesn't know or care about Lisp.  If you're delivering a
pure end-user application, presumably you want to provide something the
user can download, install, and run without having to know anything
about Lisp.  You can't expect them to separately download and install a
Lisp implementation.  And you want them to be able to run your
application just like any other application-by double-clicking an icon
on Windows or OS X or by typing the name of the program at the command
line on Unix.

   However, unlike C programs, which can typically rely on certain
shared libraries (DLLs on Windows) that make up the C "runtime" being
present as part of the operating system, Lisp programs must include a
Lisp runtime, that is, the same program you run when you start Lisp
though perhaps with certain functionality not needed to run the
application excised.

   To further complicate matters, program isn't really well defined in
Lisp.  As you've seen throughout this book, the process of developing
software in Lisp is an incremental process that involves making changes
to the set of definitions and data living in your Lisp image.  The
"program" is just a particular state of the image arrived at by loading
the .lisp or .fasl files that contain code that creates the appropriate
definitions and data.  You could, then, distribute a Lisp application as
a Lisp runtime plus a bunch of FASL files and an executable that starts
the runtime, loads the FASLs, and somehow invokes the appropriate
starting function.  However, since actually loading the FASLs can take
some time, especially if they have to do any computation to set up the
state of the world, most Common Lisp implementations provide a way to
dump an image-to save the state of a running Lisp to a file called an
image file or sometimes a core.  When a Lisp runtime starts, the first
thing it does is load an image file, which it can do in much less time
than it'd take to re-create the state by loading FASL files.

   Normally the image file is a default image containing only the
standard packages defined by the language and any extras provided by the
implementation.  But with most implementations, you have a way to
specify a different image file.  Thus, instead of packaging an app as a
Lisp runtime plus a bunch of FASLs, you can package it as a Lisp runtime
plus a single image file containing all the definitions and data that
make up your application.  Then all you need is a program that launches
the Lisp runtime with the appropriate image file and invokes whatever
function serves as the entry point to the application.

   This is where things get implementation and operating-system
dependent.  Some Common Lisp implementations, in particular the
commercial ones such as Allegro and LispWorks, provide tools for
building such an executable.  For instance, Allegro's Enterprise Edition
provides a function excl:generate-application that creates a directory
containing the Lisp runtime as a shared library, an image file, and an
executable that starts the runtime with the given image.  Similarly, the
LispWorks Professional Edition "delivery" mechanism allows you to build
single-file executables of your programs.  On Unix, with the various
free and open-source implementations, you can do essentially the same
thing except it's probably easier to use a shell script to start
everything.

   And on OS X things are even better-since all applications on OS X are
packaged as .app bundles, which are essentially directories with a
certain structure, it's not all that difficult to package all the parts
of a Lisp application as a double-clickable .app bundle.  Mikel Evins's
Bosco tool makes it easy to create .app bundles for applications running
on OpenMCL.

   Of course, another popular way to deliver applications these days is
as server-side applications.  This is a niche where Common Lisp can
really excel-you can pick a combination of operating system and Common
Lisp implementation that works well for you, and you don't have to worry
about packaging the application to be installed by an end user.  And
Common Lisp's interactive debugging and development features make it
possible to debug and upgrade a live server in ways that either just
aren't possible in a less dynamic language or would require you to build
a lot of specific infrastructure.


File: pcl.info,  Node: 32-5,  Next: Top,  Prev: 32-4,  Up: Chapter 32

Where to Go Next
================

So, that's it.  Welcome to the wonderful world of Lisp.  The best thing
you can do now-if you haven't already-is to start writing your own Lisp
code.  Pick a project that interests you, and do it in Common Lisp.
Then do another.  Lather, rinse, repeat.

   However, if you need some further pointers, this section offers some
places to go.  For starters, check out the Practical Common Lisp Web
site at http://www.gigamonkeys.com/book/, where you can find the source
code from the practical chapters, errata, and links to other Lisp
resources on the Web.

   In addition to the sites I mentioned in the "Finding Lisp Libraries"
section, you may also want explore the Common Lisp HyperSpec (a.k.a.
the HyperSpec or CLHS), an HTML version of the ANSI language standard
prepared by Kent Pitman and made available by LispWorks at
http://www.lispworks.com/documentation/HyperSpec/index.html.  The
HyperSpec is by no means a tutorial, but it's as authoritative a guide
to the language as you can get without buying a printed copy of the
standard from ANSI and much more convenient for day-to-day use.12

   If you want to get in touch with other Lispers, comp.lang.lisp on
Usenet and the #lisp IRC channel or the Freenode network
(http://www.freenode.net) are two of the main online hang- outs.  There
are also a number of Lisp-related blogs, most of which are aggregated on
Planet Lisp at http://planet.lisp.org/.

   And keep your eyes peeled in all those forums for announcements of
local Lisp users get-togethers in your area-in the past few years,
Lispnik gatherings have popped up in cities around the world, from New
York to Oakland, from Cologne to Munich, and from Geneva to Helsinki.

   If you want to stick to books, here are a few suggestions.  For a
nice thick reference book to stick on your desk, grab The ANSI Common
Lisp Reference Book edited by David Margolies (Apress, 2005).13

   For more on Common Lisp's object system, you can start with
Object-Oriented Programming in Common Lisp: A Programmer's Guide to CLOS
by Sonya E. Keene (Addison-Wesley, 1989).  Then if you really want to
become an object wizard or just to stretch your mind in interesting
ways, read The Art of the Metaobject Protocol by Gregor Kiczales, Jim
des Rivires, and Daniel G. Bobrow (MIT Press, 1991).  This book, also
known as AMOP, is both an explanation of what a metaobject protocol is
and why you want one and the de facto standard for the metaobject
protocol supported by many Common Lisp implementations.

   Two books that cover general Common Lisp technique are Paradigms of
Artificial Intelligence Programming: Case Studies in Common Lisp by
Peter Norvig (Morgan Kaufmann, 1992) and On Lisp: Advanced Techniques
for Common Lisp by Paul Graham (Prentice Hall, 1994).  The former
provides a solid introduction to artificial intelligence techniques
while teaching quite a bit about how to write good Common Lisp code, and
the latter is especially good in its treatment of macros.

   If you're the kind of person who likes to know how things work down
to the bits, Lisp in Small Pieces by Christian Queinnec (Cambridge
University Press, 1996) provides a nice blend of programming language
theory and practical Lisp implementation techniques.  While it's
primarily focused on Scheme rather than Common Lisp, the same principles
apply.

   For folks who want a little more theoretical look at things-or who
just want to know what it's like to be a freshman comp sci student at
M.I.T.-Structure and Interpretation of Computer Programs, Second
Edition, by Harold Abelson, Gerald Jay Sussman, and Julie Sussman
(M.I.T. Press, 1996) is a classic computer science text that uses Scheme
to teach important programming concepts.  Any programmer can learn a lot
from this book-just remember that there are important differences
between Scheme and Common Lisp.

   Once you've wrapped your mind around Lisp, you may want to place it
in a bit of context.  Since no one can claim to really understand object
orientation who doesn't know something about Smalltalk, you might want
to start with Smalltalk-80: The Language by Adele Goldberg and David
Robson (Addison Wesley, 1989), the standard introduction to the core of
Smalltalk.  After that, Smalltalk Best Practice Patterns by Kent Beck
(Prentice Hall, 1997) is full of good advice aimed at Smalltalkers, much
of which is applicable to any object-oriented language.

   And at the other end of the spectrum, Object-Oriented Software
Construction by Bertrand Meyer (Prentice Hall, 1997) is an excellent
exposition of the static language mind-set from the inventor of Eiffel,
an oft-overlooked descendant of Simula and Algol.  It contains much food
for thought, even for programmers working with dynamic languages such as
Common Lisp.  In particular, Meyer's ideas about Design By Contract can
shed a lot of light on how one ought to use Common Lisp's condition
system.

   Though not about computers per se, The Wisdom of Crowds: Why the Many
Are Smarter Than the Few and How Collective Wisdom Shapes Business,
Economies, Societies, and Nations by James Surowiecki (Doubleday, 2004)
contains an excellent answer to the question, "If Lisp's so great how
come everybody isn't using it?"  See the section on "Plank-Road Fever"
starting on page 53.

   And finally, for some fun, and to learn about the influence Lisp and
Lispers have had on hacker culture, dip into (or read from cover to
cover) The New Hacker's Dictionary, Third Edition, compiled by Eric S.
Raymond (MIT Press, 1996) and based on the original The Hacker's
Dictionary edited by Guy Steele (Harper & Row, 1983).

   But don't let all these suggestions interfere with your
programming-the only way to really learn a language is to use it.  If
you've made it this far, you're certainly ready to do that.  Happy
hacking!
