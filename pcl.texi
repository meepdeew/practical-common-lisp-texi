@node Top, Preface, (dir), (dir)

@ifinfo

@heading Practical Common Lisp

@noindent
`that book is dead sexy` —Xach on #lisp@*
@copyright{} 2003-2009, Peter Seibel

@noindent
Unofficial Texinfo Format

@end ifinfo

@menu
* Preface::     Preface
* Letter::      Letter to the Reader
* Blurbs::      Blurbs
* Chapter 1::   Introduction: Why Lisp?
* Chapter 2::   Lather, Rinse, Repeat: A Tour of the REPL
* Chapter 3::   Practical: A Simple Database
* Chapter 4::   Syntax and Semantics
* Chapter 5::   Functions
* Chapter 6::   Variables
* Chapter 7::   Macros: Standard Control Constructs
* Chapter 8::   Macros: Defining Your Own
* Chapter 9::   Practical: Building a Unit Test Framework
* Chapter 10::  Numbers, Characters, and Strings
* Chapter 11::  Collections
* Chapter 12::  They Called It LISP for a Reason: List Processing
* Chapter 13::  Beyond Lists: Other Uses for Cons Cells
* Chapter 14::  Files and File I/O
* Chapter 15::  Practical: A Portable Pathname Library
* Chapter 16::  Object Reorientation: Generic Functions
* Chapter 17::  Object Reorientation: Classes
* Chapter 18::  A Few FORMAT Recipes
* Chapter 19::  Beyond Exception Handling: Conditions and Restarts
* Chapter 20::  The Special Operators
* Chapter 21::  Programming in the Large: Packages and Symbols
* Chapter 22::  LOOP for Black Belts
* Chapter 23::  Practical: A Spam Filter
* Chapter 24::  Practical: Parsing Binary Files
* Chapter 25::  Practical: An ID3 Parser
* Chapter 26::  Practical: Web Programming with AllegroServe
* Chapter 27::  Practical: An MP3 Database
* Chapter 28::  Practical: A Shoutcast Server
* Chapter 29::  Practical: An MP3 Browser
* Chapter 30::  Practical: An HTML Generation Library, the Interpreter
* Chapter 31::  Practical: An HTML Generation Library, the Compiler
* Chapter 32::  Conclusion: What's Next?

@detailmenu
 --- The Detailed Node Listing ---

1. Introduction: Why Lisp?

* 1-1::              Why Lisp?
* 1-2::              Where It Began
* 1-3::              Who This Book Is For

2. Lather, Rinse, Repeat: A Tour of the REPL

* 2-1::              Choosing a Lisp Implementation
* 2-2::              Getting Up and Running with Lisp in a Box
* 2-3::              Free Your Mind: Interactive Programming
* 2-4::              Experimenting in the REPL
* 2-5::              "Hello, World," Lisp Style
* 2-6::              Saving Your Work

3. Practical: A Simple Database

* 3-1::              CDs and Records
* 3-2::              Filing CDs
* 3-3::              Looking at the Database Contents
* 3-4::              Improving the User Interaction
* 3-5::              Saving and Loading the Database
* 3-6::              Querying the Database
* 3-7::              Updating Existing Records--Another Use for WHERE
* 3-8::              Removing Duplication and Winning Big
* 3-9::              Wrapping Up

4. Syntax and Semantics

* 4-1::              What's with All the Parentheses?
* 4-2::              Breaking Open the Black Box
* 4-3::              S-expressions
* 4-4::              S-expressions As Lisp Forms
* 4-5::              Function Calls
* 4-6::              Special Operators
* 4-7::              Macros
* 4-8::              Truth, Falsehood, and Equality
* 4-9::              Formatting Lisp Code

5. Functions

* 5-1::              Defining New Functions
* 5-2::              Function Parameter Lists
* 5-3::              Optional Parameters
* 5-4::              Rest Parameters
* 5-5::              Keyword Parameters
* 5-6::              Mixing Different Parameter Types
* 5-7::              Function Return Values
* 5-8::              Functions As Data, a.k.a. Higher-Order Functions
* 5-9::              Anonymous Functions

6. Variables

* 6-1::              Variable Basics
* 6-2::              Lexical Variables and Closures
* 6-3::              Dynamic, a.k.a. Special, Variables
* 6-4::              Constants
* 6-5::              Assignment
* 6-6::              Generalized Assignment
* 6-7::              Other Ways to Modify Places

7. Macros: Standard Control Constructs

* 7-1::              WHEN and UNLESS
* 7-2::              COND
* 7-3::              AND, OR, and NOT
* 7-4::              Looping
* 7-5::              DOLIST and DOTIMES
* 7-6::              DO
* 7-7::              The Mighty LOOP

8. Macros: Defining Your Own

* 8-1::                  The Story of Mac: A Just-So Story
* 8-2::                  Macro Expansion Time vs. Runtime
* 8-3::                  DEF MACRO
* 8-4::                  A Sample Macro: do-primes
* 8-5::                  Macro Parameters
* 8-6::                  Generating the Expansion
* 8-7::                  Plugging the Leaks
* 8-8::                  Macro-Writing Macros
* 8-9::                  Beyond Simple Macros

9. Practical: Building a Unit Test Framework

* 9-1::                  Two First Tries
* 9-2::                  Refactoring
* 9-3::                  Fixing the Return Value
* 9-4::                  Better Result Reporting
* 9-5::                  An Abstraction Emerges
* 9-6::                  A Hierarchy of Tests
* 9-7::                  Wrapping Up

10. Numbers, Characters, and Strings

* 10-1::                 Numbers
* 10-2::                 Numeric Literals
* 10-3::                 Basic Math
* 10-4::                 Numeric Comparisons
* 10-5::                 Higher Math
* 10-6::                 Characters
* 10-7::                 Character Comparisons
* 10-8::                 Strings
* 10-9::                 String Comparisons

11. Collections

* 11-1::                            Vectors
* 11-2::                            Subtypes of Vector
* 11-3::                            Vectors As Sequences
* 11-4::                            Sequence Iterating Functions
* 11-5::                            Higher-Order Function Variants
* 11-6::                            Whole Sequence Manipulations
* 11-7::                            Sorting and Merging
* 11-8::                            Subsequence Manipulations
* 11-9::                            Sequence Predicates
* 11-10::                           Sequence Mapping Functions
* 11-11::                           Hash Tables
* 11-12::                           Hash Table Iteration

12. They Called It LISP for a Reason: List Processing

* 12-1::             "There Is No List"
* 12-2::             Functional Programming and Lists
* 12-3::             "Destructive" Operations
* 12-4::             Combining Recycling with Shared Structure
* 12-5::             List-Manipulation Functions
* 12-6::             Mapping
* 12-7::             Other Structures

13. Beyond Lists: Other Uses for Cons Cells

* 13-1::                Trees
* 13-2::                Sets
* 13-3::                Lookup Tables: Alists and Plists
* 13-4::                DESTRUCTURING-BIND

14. Files and File I/O

* 14-1::      Reading File Data
* 14-2::      Reading Binary Data
* 14-3::      Bulk Reads
* 14-4::      File Output
* 14-5::      Closing Files
* 14-6::      Filenames
* 14-7::      How Pathnames Represent Filenames
* 14-8::      Constructing New Pathnames
* 14-9::      Two Representations of Directory Names
* 14-10::     Interacting with the File System
* 14-11::     Other Kinds of I/O

15. Practical: A Portable Pathname Library

* 15-1::       The API
* 15-2::       *FEATURES* and Read-Time Conditionalization
* 15-3::       Listing a Directory
* 15-4::       Testing a File's Existence
* 15-5::       Walking a Directory Tree

16. Object Reorientation: Generic Functions

* 16-1::   Generic Functions and Classes
* 16-2::   Generic Functions and Methods
* 16-3::   DEFGENERIC
* 16-4::   DEFMETHOD
* 16-5::   Method Combination
* 16-6::   The Standard Method Combination
* 16-7::   Other Method Combinations
* 16-8::   Multimethods
* 16-9::   To Be Continued . . .

17. Object Reorientation: Classes

* 17-1::   DEFCLASS
* 17-2::   Slot Specifiers
* 17-3::   Object Initialization
* 17-4::   Accessor Functions
* 17-5::   WITH-SLOTS and WITH-ACCESSORS
* 17-6::   Class-Allocated Slots
* 17-7::   Slots and Inheritance
* 17-8::   Multiple Inheritance
* 17-9::   Good Object-Oriented Design

18. A Few FORMAT Recipes

* 18-1::         The FORMAT Function
* 18-2::         FORMAT Directives
* 18-3::         Basic Formatting
* 18-4::         Character and Integer Directives
* 18-5::         Floating-Point Directives
* 18-6::         English-Language Directives
* 18-7::         Conditional Formatting
* 18-8::         Iteration
* 18-9::         Hop, Skip, Jump
* 18-10::        And More . . .

19. Beyond Exception Handling: Conditions and Restarts

* 19-1::             The Lisp Way
* 19-2::             Conditions
* 19-3::             Condition Handlers
* 19-4::             Restarts
* 19-5::             Providing Multiple Restarts
* 19-6::             Other Uses for Conditions

20. The Special Operators

* 20-1::        Controlling Evaluation
* 20-2::        Manipulating the Lexical Environment
* 20-3::        Local Flow of Control
* 20-4::        Unwinding the Stack
* 20-5::        Multiple Values
* 20-6::        EVAL-WHEN
* 20-7::        Other Special Operators

21. Programming in the Large: Packages and Symbols

* 21-1::        How the Reader Uses Packages
* 21-2::        A Bit of Package and Symbol Vocabulary
* 21-3::        Three Standard Packages
* 21-4::        Defining Your Own Packages
* 21-5::        Packaging Reusable Libraries
* 21-6::        Importing Individual Names
* 21-7::        Packaging Mechanics
* 21-8::        Package Gotchas

22. LOOP for Black Belts

* 22-1::     The Parts of a LOOP
* 22-2::     Iteration Control
* 22-3::     Counting Loops
* 22-4::     Looping Over Collections and Packages
* 22-5::     Equals-Then Iteration
* 22-6::     Local Variables
* 22-7::     Destructuring Variables
* 22-8::     Value Accumulation
* 22-9::     Unconditional Execution
* 22-10::    Conditional Execution
* 22-11::    Setting Up and Tearing Down
* 22-12::    Termination Tests
* 22-13::    Putting It All Together

23. Practical: A Spam Filter

* 23-1::       The Heart of a Spam Filter
* 23-2::       Training the Filter
* 23-3::       Per-Word Statistics
* 23-4::       Combining Probabilities
* 23-5::       Inverse Chi Square
* 23-6::       Training the Filter
* 23-7::       Testing the Filter
* 23-8::       A Couple of Utility Functions
* 23-9::       Analyzing the Results
* 23-10::      What's Next

24. Practical: Parsing Binary Files

* 24-1::       Binary Files
* 24-2::       Binary Format Basics
* 24-3::       Strings in Binary Files
* 24-4::       Composite Structures
* 24-5::       Designing the Macros
* 24-6::       Making the Dream a Reality
* 24-7::       Reading Binary Objects
* 24-8::       Writing Binary Objects
* 24-9::       Adding Inheritance and Tagged Structures
* 24-10::      Keeping Track of Inherited Slots
* 24-11::      Tagged Structures
* 24-12::      Primitive Binary Types
* 24-13::      The Current Object Stack

25. Practical: An ID3 Parser

* 25-1::       Structure of an ID3v2 Tag
* 25-2::       Defining a Package
* 25-3::       Integer Types
* 25-4::       String Types
* 25-5::       ID3 Tag Header
* 25-6::       ID3 Frames
* 25-7::       Detecting Tag Padding
* 25-8::       Supporting Multiple Versions of ID3
* 25-9::       Versioned Frame Base Classes
* 25-10::      Versioned Concrete Frame Classes
* 25-11::      What Frames Do You Actually Need?
* 25-12::      Text Information Frames
* 25-13::      Comment Frames
* 25-14::      Extracting Information from an ID3 Tag

26. Practical: Web Programming with AllegroServe

* 26-1::       A 30-Second Intro to Server-Side Web Programming
* 26-2::       AllegroServe
* 26-3::       Generating Dynamic Content with AllegroServe
* 26-4::       Generating HTML
* 26-5::       HTML Macros
* 26-6::       Query Parameters
* 26-7::       Cookies
* 26-8::       A Small Application Framework
* 26-9::       The Implementation

27. Practical: An MP3 Database

* 27-1::       The Database
* 27-2::       Defining a Schema
* 27-3::       Inserting Values
* 27-4::       Querying the Database
* 27-5::       Matching Functions
* 27-6::       Getting at the Results
* 27-7::       Other Database Operations

28. Practical: A Shoutcast Server

* 28-1::       The Shoutcast Protocol
* 28-2::       Song Sources
* 28-3::       Implementing Shoutcast

29. Practical: An MP3 Browser

* 29-1::       Playlists
* 29-2::       Playlists As Song Sources
* 29-3::       Manipulating the Playlist
* 29-4::       Query Parameter Types
* 29-5::       Boilerplate HTML
* 29-6::       The Browse Page
* 29-7::       The Playlist
* 29-8::       Finding a Playlist
* 29-9::       Running the App

30. Practical: An HTML Generation Library, the Interpreter

* 30-1::       Designing a Domain-Specific Language
* 30-2::       The FOO Language
* 30-3::       Character Escaping
* 30-4::       Indenting Printer
* 30-5::       HTML Processor Interface
* 30-6::       The Pretty Printer Backend
* 30-7::       The Basic Evaluation Rule
* 30-8::       What's Next?

31. Practical: An HTML Generation Library, the Compiler

* 31-1::       The Compiler
* 31-2::       FOO Special Operators
* 31-3::       FOO Macros
* 31-4::       The Public API
* 31-5::       The End of the Line

32. Conclusion: What's Next?

* 32-1::        Finding Lisp Libraries
* 32-2::        Interfacing with Other Languages
* 32-3::        Make It Work, Make It Right, Make It Fast
* 32-4::        Delivering Applications
* 32-5::        Where to Go Next


@end detailmenu
@end menu

@node    Preface, Letter, Top, Top
@unnumbered Preface

This page, and the pages it links to, contain text of the Common Lisp book Practical Common Lisp published by Apress. These pages now contain the final text as it appears in the book. If you find errors in these pages, please send email to @email{book@@gigamonkeys.com}. These pages will remain online in perpetuity—I hope they will serve as a useful introduction to Common Lisp for folks who are curious about Lisp but maybe not yet curious enough to shell out big bucks for a dead-tree book and a good Common Lisp tutorial for folks who want to get down to real coding right away. However, don't let that stop you from buying the printed version available from Apress at your favorite local or online bookseller. For the complete bookstore browsing experience, you can read the letter to the reader that appears on the back cover of the treeware edition of the book.

@node    Letter, Blurbs, Preface, Top
@unnumbered Letter to the Reader

Dear Reader,

Practical Common Lisp ... isn't that an oxymoron? If you're like most programmers, you probably know something about Lisp—from a comp sci course in college or from learning enough Elisp to customize Emacs a bit. Or maybe you just know someone who won't shut up about Lisp, the greatest language ever. But you probably never figured you'd see practical and Lisp in the same book title.

Yet, you're reading this; you must want to know more. Maybe you believe learning Lisp will make you a better programmer in any language. Or maybe you just want to know what those Lisp fanatics are yammering about all the time. Or maybe you have learned some Lisp but haven't quite made the leap to using it to write interesting software.

If any of those is true, this book is for you. Using Common Lisp, an ANSI standardized, industrial-strength dialect of Lisp, I show you how to write software that goes well beyond silly academic exercises or trivial editor customizations. And I show you how Lisp—even with many of its features adopted by other languages—still has a few tricks up its sleeve.

But unlike many Lisp books, this one doesn't just touch on a few of Lisp's greatest features and then leave you on your own to actually use them. I cover all the language features you'll need to write real programs and devote well over a third of the book to developing nontrivial software—a statistical spam filter, a library for parsing binary files, and a server for streaming MP3s over a network complete with an online MP3 database and Web interface.

So turn the book over, open it up, and see for yourself how eminently practical using the greatest language ever invented can be.

Sincerely,

Peter Seibel

@node    Blurbs, Chapter 1, Letter, Top

@quotation
“I have been complimented many times and they always embarrass me; I always feel that they have not said enough.”
—Mark Twain
@end quotation

@unnumbered Blurbs

@quotation
“Peter Seibel offers a fresh view of Lisp and its possibilities for elegantly solving problems. In Practical Common Lisp, he gives enough basic information to let you quickly see the power of the functional language paradigm. He then dazzles you with examples that seem almost magical in their simplicity and power. This read is pure fun from start to finish.”
-—Gary Pollice, from @uref{http://www.drdobbs.com/joltawards/2006-jolt-awards/187900423?pgno=4, Dr. Dobb's Portal, May 17, 2006 article on the 2006 Jolt Awards}
@end quotation

“Peter Seibel's Practical Common Lisp is just what the title implies: an excellent introduction to Common Lisp for someone who wants to dive in and start using the language for real work. The book is very well written and is fun to read—at least for those of us whose idea of fun extends to learning new programming languages.

Rather than spending a lot of time on abstract discussion of Lisp's place in the universe of programming lnaguages, Seibel dives right in, guiding the reader through a series of programming examples of increasing complexity. This approach places the most emphasis on those parts of Common Lisp that skilled programmers use the most, without getting bogged down in the odd corners of Common Lisp that even the experts must look up in the manual. The result of Seibel's example-driven approach is to give the reader an excellent appreciation of the power of Common Lisp in building complex, evolving software systems with a minimum of effort.

There are already many good books on Common Lisp that offer a more abstract and comparative approach, but a good ‘Here's how you do it—and why’ book, aimed at the working programmer, is a valuable contribution, both to current Common Lisp users and those who should be.” —Scott E. Fahlman, Research Professor of Computer Science, Carnegie Mellon University

“This book shows the power of Lisp not only in the areas that it has traditionally been noted for—such as developing a complete unit test framework in only 26 lines of code—but also in new areas such as parsing binary MP3 files, building a web application for browsing a collection of songs, and streaming audio over the web. Many readers will be surprised that Lisp allows you to do all this with conciseness similar to scripting languages such as Python, efficiency similar to C++, and unparalleled flexibility in designing your own language extensions.” —Peter Norvig, Director of Search Quality, Google Inc; author of Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp

“I wish this book had already existed when I started learning Lisp. It's not that there aren't other good books about (Common) Lisp out there, but none of them has such a pragmatic, up-to-date approach. And let's not forget that Peter covers topics like pathnames or conditions and restarts which are completely ignored in the rest of the Lisp literature.

If you're new to Lisp and want to dive right in don't hesitate to buy this book. Once you've read it and worked with it you can continue with the ‘classics’ like Graham, Norvig, Keene, or Steele.” —Edi Weitz, maintainer of the Common Lisp Cookbook and author of CL-PPCRE regular expression library.

“Two prehensile toes up!” —Kenny Tilton, comp.lang.lisp demon, reporting on behalf of his development team.

“Experienced programmers learn best from examples and it is delightful to see that Lisp is finally being served with Seibel's example-rich tutorial text. Especially delightful is the fact that this book includes so many examples that fall within the realm of problems today's programmers might be called upon to tackle, such as Web development and streaming media.—Philip Greenspun, author of Software Engineering for Internet Applications, MIT Department of Electrical Engineering and Computer Science

“Practical Common Lisp is an excellent book that covers the breadth of the Common Lisp language and also demonstrates the unique features of Common Lisp with real-world applications that the reader can run and extend. This book not only shows what Common Lisp is but also why every programmer should be familiar with Lisp.” —John Foderaro, Senior Scientist, Franz Inc.

“The Maxima Project frequently gets queries from potential new contributors who would like to learn Common Lisp. I am pleased to finally have a book that I can recommend to them without reservation. Peter Seibel's clear, direct style allows the reader to quickly appreciate the power of Common Lisp. His many included examples, which focus on contemporary programming problems, demonstrate that Lisp is much more than an academic programming language. Practical Common Lisp is a welcome addition to the literature.” —James Amundson, Maxima Project Leader

“I like the interspersed Practical chapters on 'real' and useful programs. We need books of this kind telling the world that crunching strings and numbers into trees or graphs is easily done in Lisp.—Professor Christian Queinnec, Universite Paris 6 (Pierre et Marie Curie)

“One of the most important parts of learning a programming language is learning its proper programming style. This is hard to teach, but it can be painlessly absorbed from Practical Common Lisp. Just reading the practical examples made me a better programmer in any language.” —Peter Scott, Lisp programmer

“Finally, a Lisp book for the rest of us. If you want to learn how to write a factorial function, this is not your book. Seibel writes for the practical programmer, emphasizing the engineer/artist over the scientist, subtly and gracefully implying the power of the language while solving understandable real-world problems.

In most chapters, the reading of the chapter feels just like the experience of writing a program, starting with a little understanding, then having that understanding grow, like building the shoulders upon which you can then stand. When Seibel introduced macros as an aside while building a test framework, I was shocked at how such a simple example made me really 'get' them. Narrative context is extremely powerful and the technical books that use it are a cut above. Congrats!” —Keith Irwin, Lisp Programmer

“While learning Lisp, one is often refered to the CL HyperSpec if they do not know what a particular function does, however, I found that I often did not 'get it' just reading the HyperSpec. When I had a problem of this manner, I turned to Practical Common Lisp every single time—it is by far the most readable source on the subject that shows you how to program, not just tell you.” —Philip Haddad, Lisp Programmer

“With the IT world evolving at an ever increasing pace, professionals need the most powerful tools available. This is why Common Lisp—the most powerful, flexible, and stable programming language ever—is seeing such a rise in popularity. Practical Common Lisp is the long-awaited book that will help you harness the power of Common Lisp to tackle today's complex real world problems.” —Marc Battyani, author of CL-PDF, CL-TYPESETTING, and mod_lisp.

“Please don't assume Common Lisp is only useful for Databases, Unit Test Frameworks, Spam Filters, ID3 Parsers, Web Programming, Shoutcast Servers, HTML Generation Interpreters, and HTML Generation Compilers just because these are the only things happened to be implemented in the book Practical Common Lisp.—Tobias C. Rittweiler, Lisp Programmer

“When I met Peter, who just started writing this book, I asked to myself (not to him, of course) ‘why yet another book on Common Lisp, when there are many nice introductory books?’ One year later, I found a draft of the new book and recognized I was wrong. This book is not ‘yet another’ one. The author focuses on practical aspects rather than on technical details of the language. When I first studied Lisp by reading an introductory book, I felt I understood the language, but I also had an impression ‘so what?’, meaning I had no idea about how to use it. In contrast, this book leaps into a ‘PRACTICAL’ chapter after the first few chapters that explain the very basic notions of the language. Then the readers are expected to learn more about the language while they are following the PRACTICAL projects, which are combined together to form a product of a significant size. After reading this book, the readers will feel themselves expert programmers on Common Lisp since they have ‘finished’ a big project already. I think Lisp is the only language that allows this type of practical introduction. Peter makes use of this feature of the language in building up a fancy introduction on Common Lisp.” —Taiichi Yuasa, Professor, Department of Communications and Computer Engineering, Kyoto University

Have something to say about this book? Something nice? Want to see it here? Send it along to @email{book@@gigamonkeys.com}.

@include chapter01.texi
@include chapter02.texi
@include chapter03.texi
@include chapter04.texi
@include chapter05.texi
@include chapter06.texi
@include chapter07.texi
@include chapter08.texi
@include chapter09.texi
@include chapter10.texi
@include chapter11.texi
@include chapter12.texi
@include chapter13.texi
@include chapter14.texi
@include chapter15.texi
@include chapter16.texi
@include chapter17.texi
@include chapter18.texi
@include chapter19.texi

@node    Chapter 20, Chapter 21, Chapter 19, Top
@section 20. The Special Operators

content 20-intro

@menu
* 20-1::        Controlling Evaluation
* 20-2::        Manipulating the Lexical Environment
* 20-3::        Local Flow of Control
* 20-4::        Unwinding the Stack
* 20-5::        Multiple Values
* 20-6::        EVAL-WHEN
* 20-7::        Other Special Operators
@end menu

@node	20-1, 20-2, Chapter 20, Chapter 20
@section Controlling Evaluation

content 20-1

@node	20-2, 20-3, 20-1, Chapter 20
@section Manipulating the Lexical Environment

content 20-2

@node	20-3, 20-4, 20-2, Chapter 20
@section Local Flow of Control

content 20-3

@node	20-4, 20-5, 20-3, Chapter 20
@section Unwinding the Stack

content 20-4

@node	20-5, 20-6, 20-4, Chapter 20
@section Multiple Values

content 20-5

@node	20-6, 20-7, 20-5, Chapter 20
@section EVAL-WHEN

content 20-6

@node	20-7, Chapter 21, 20-6, Chapter 20
@section Other Special Operators

content 20-7

@node    Chapter 21, Chapter 22, Chapter 20, Top
@section 21. Programming in the Large: Packages and Symbols

content 21-intro

@menu
* 21-1::        How the Reader Uses Packages
* 21-2::        A Bit of Package and Symbol Vocabulary
* 21-3::        Three Standard Packages
* 21-4::        Defining Your Own Packages
* 21-5::        Packaging Reusable Libraries
* 21-6::        Importing Individual Names
* 21-7::        Packaging Mechanics
* 21-8::        Package Gotchas
@end menu

@node	21-1, 21-2, Chapter 21, Chapter 21
@section How the Reader Uses Packages

content 21-1

@node	21-2, 21-3, 21-1, Chapter 21
@section A Bit of Package and Symbol Vocabulary

content 21-2

@node	21-3, 21-4, 21-2, Chapter 21
@section Three Standard Packages

content 21-3

@node	21-4, 21-5, 21-3, Chapter 21
@section Defining Your Own Packages

content 21-4

@node	21-5, 21-6, 21-4, Chapter 21
@section Packaging Reusable Libraries

content 21-5

@node	21-6, 21-7, 21-5, Chapter 21
@section Importing Individual Names

content 21-6

@node	21-7, 21-8, 21-6, Chapter 21
@section Packaging Mechanics

content 21-7

@node	21-8, Chapter 22, 21-7, Chapter 21
@section Package Gotchas

content 21-8

@node    Chapter 22, Chapter 23, Chapter 21, Top
@section 22. LOOP for Black Belts

content 22-intro

@menu
* 22-1::     The Parts of a LOOP
* 22-2::     Iteration Control
* 22-3::     Counting Loops
* 22-4::     Looping Over Collections and Packages
* 22-5::     Equals-Then Iteration
* 22-6::     Local Variables
* 22-7::     Destructuring Variables
* 22-8::     Value Accumulation
* 22-9::     Unconditional Execution
* 22-10::    Conditional Execution
* 22-11::    Setting Up and Tearing Down
* 22-12::    Termination Tests
* 22-13::    Putting It All Together
@end menu

@node	22-1, 22-2, Chapter 22, Chapter 22
@section The Parts of a LOOP

content 22-1

@node	22-2, 22-3, 22-1, Chapter 22
@section Iteration Control

content 22-2

@node	22-3, 22-4, 22-2, Chapter 22
@section Counting Loops

content 22-3

@node	22-4, 22-5, 22-3, Chapter 22
@section Looping Over Collections and Packages

content 22-4

@node	22-5, 22-6, 22-4, Chapter 22
@section Equals-Then Iteration

content 22-5

@node	22-6, 22-7, 22-5, Chapter 22
@section Local Variables

content 22-6

@node	22-7, 22-8, 22-6, Chapter 22
@section Destructuring Variables

content 22-7

@node	22-8, 22-9, 22-7, Chapter 22
@section Value Accumulation

content 22-8

@node	22-9, 22-10, 22-8, Chapter 22
@section Unconditional Execution

content 22-9

@node	22-10, 22-11, 22-9, Chapter 22
@section Conditional Execution

content 22-10

@node	22-11, 22-12, 22-10, Chapter 22
@section Setting Up and Tearing Down

content 22-11

@node	22-12, 22-13, 22-11, Chapter 22
@section Termination Tests

content 22-12

@node	22-13, Chapter 23, 22-12, Chapter 22
@section Putting It All Together

content 22-13

@node    Chapter 23, Chapter 24, Chapter 22, Top
@section 23. Practical: A Spam Filter

content 23-intro

@menu
* 23-1::       The Heart of a Spam Filter
* 23-2::       Training the Filter
* 23-3::       Per-Word Statistics
* 23-4::       Combining Probabilities
* 23-5::       Inverse Chi Square
* 23-6::       Training the Filter
* 23-7::       Testing the Filter
* 23-8::       A Couple of Utility Functions
* 23-9::       Analyzing the Results
* 23-10::      What's Next
@end menu

@node	23-1, 23-2, Chapter 23, Chapter 23
@section The Heart of a Spam Filter

content 23-1

@node	23-2, 23-3, 23-1, Chapter 23
@section Training the Filter

content 23-2

@node	23-3, 23-4, 23-2, Chapter 23
@section Per-Word Statistics

content 23-3

@node	23-4, 23-5, 23-3, Chapter 23
@section Combining Probabilities

content 23-4

@node	23-5, 23-6, 23-4, Chapter 23
@section Inverse Chi Square

content 23-5

@node	23-6, 23-7, 23-5, Chapter 23
@section Training the Filter

content 23-6

@node	23-7, 23-8, 23-6, Chapter 23
@section Testing the Filter

content 23-7

@node	23-8, 23-9, 23-7, Chapter 23
@section A Couple of Utility Functions

content 23-8

@node	23-9, 23-10, 23-8, Chapter 23
@section Analyzing the Results

content 23-9

@node	23-10, Chapter 24, 23-9, Chapter 23
@section What's Next

content 23-10

@node    Chapter 24, Chapter 25, Chapter 23, Top
@section 24. Practical: Parsing Binary Files

content 24-intro

@menu
* 24-1::       Binary Files
* 24-2::       Binary Format Basics
* 24-3::       Strings in Binary Files
* 24-4::       Composite Structures
* 24-5::       Designing the Macros
* 24-6::       Making the Dream a Reality
* 24-7::       Reading Binary Objects
* 24-8::       Writing Binary Objects
* 24-9::       Adding Inheritance and Tagged Structures
* 24-10::      Keeping Track of Inherited Slots
* 24-11::      Tagged Structures
* 24-12::      Primitive Binary Types
* 24-13::      The Current Object Stack
@end menu

@node	24-1, 24-2, Chapter 24, Chapter 24
@section Binary Files

content 24-1

@node	24-2, 24-3, 24-1, Chapter 24
@section Binary Format Basics

content 24-2

@node	24-3, 24-4, 24-2, Chapter 24
@section Strings in Binary Files

content 24-3

@node	24-4, 24-5, 24-3, Chapter 24
@section Composite Structures

content 24-4

@node	24-5, 24-6, 24-4, Chapter 24
@section Designing the Macros

content 24-5

@node	24-6, 24-7, 24-5, Chapter 24
@section Making the Dream a Reality

content 24-6

@node	24-7, 24-8, 24-6, Chapter 24
@section Reading Binary Objects

content 24-7

@node	24-8, 24-9, 24-7, Chapter 24
@section Writing Binary Objects

content 24-8

@node	24-9, 24-10, 24-8, Chapter 24
@section Adding Inheritance and Tagged Structures

content 24-9

@node	24-10, 24-11, 24-9, Chapter 24
@section Keeping Track of Inherited Slots

content 24-10

@node	24-11, 24-12, 24-10, Chapter 24
@section Tagged Structures

content 24-11

@node	24-12, 24-13, 24-11, Chapter 24
@section Primitive Binary Types

content 24-12

@node	24-13, Chapter 25, 24-12, Chapter 24
@section The Current Object Stack

content 24-13

@node    Chapter 25, Chapter 26, Chapter 24, Top
@section 25. Practical: An ID3 Parser

content 25-intro

@menu
* 25-1::       Structure of an ID3v2 Tag
* 25-2::       Defining a Package
* 25-3::       Integer Types
* 25-4::       String Types
* 25-5::       ID3 Tag Header
* 25-6::       ID3 Frames
* 25-7::       Detecting Tag Padding
* 25-8::       Supporting Multiple Versions of ID3
* 25-9::       Versioned Frame Base Classes
* 25-10::      Versioned Concrete Frame Classes
* 25-11::      What Frames Do You Actually Need?
* 25-12::      Text Information Frames
* 25-13::      Comment Frames
* 25-14::      Extracting Information from an ID3 Tag
@end menu

@node	25-1, 25-2, Chapter 25, Chapter 25
@section Structure of an ID3v2 Tag

content 25-1

@node	25-2, 25-3, 25-1, Chapter 25
@section Defining a Package

content 25-2

@node	25-3, 25-4, 25-2, Chapter 25
@section Integer Types

content 25-3

@node	25-4, 25-5, 25-3, Chapter 25
@section String Types

content 25-4

@node	25-5, 25-6, 25-4, Chapter 25
@section ID3 Tag Header

content 25-5

@node	25-6, 25-7, 25-5, Chapter 25
@section ID3 Frames

content 25-6

@node	25-7, 25-8, 25-6, Chapter 25
@section Detecting Tag Padding

content 25-7

@node	25-8, 25-9, 25-7, Chapter 25
@section Supporting Multiple Versions of ID3

content 25-8

@node	25-9, 25-10, 25-8, Chapter 25
@section Versioned Frame Base Classes

content 25-9

@node	25-10, 25-11, 25-9, Chapter 25
@section Versioned Concrete Frame Classes

content 25-10

@node	25-11, 25-12, 25-10, Chapter 25
@section What Frames Do You Actually Need?

content 25-11

@node	25-12, 25-13, 25-11, Chapter 25
@section Text Information Frames

content 25-12

@node	25-13, 25-14, 25-12, Chapter 25
@section Comment Frames

content 25-13

@node	25-14, Chapter 26, 25-13, Chapter 25
@section Extracting Information from an ID3 Tag

content 25-14

@node    Chapter 26, Chapter 27, Chapter 25, Top
@section 26. Practical: Web Programming with AllegroServe

content 26-intro

@menu
* 26-1::       A 30-Second Intro to Server-Side Web Programming
* 26-2::       AllegroServe
* 26-3::       Generating Dynamic Content with AllegroServe
* 26-4::       Generating HTML
* 26-5::       HTML Macros
* 26-6::       Query Parameters
* 26-7::       Cookies
* 26-8::       A Small Application Framework
* 26-9::       The Implementation
@end menu

@node	26-1, 26-2, Chapter 26, Chapter 26
@section A 30-Second Intro to Server-Side Web Programming

content 26-1

@node	26-2, 26-3, 26-1, Chapter 26
@section AllegroServe

content 26-2

@node	26-3, 26-4, 26-2, Chapter 26
@section Generating Dynamic Content with AllegroServe

content 26-3

@node	26-4, 26-5, 26-3, Chapter 26
@section Generating HTML

content 26-4

@node	26-5, 26-6, 26-4, Chapter 26
@section HTML Macros

content 26-5

@node	26-6, 26-7, 26-5, Chapter 26
@section Query Parameters

content 26-6

@node	26-7, 26-8, 26-6, Chapter 26
@section Cookies

content 26-7

@node	26-8, 26-9, 26-7, Chapter 26
@section A Small Application Framework

content 26-8

@node	26-9, Chapter 27, 26-8, Chapter 26
@section The Implementation

content 26-9

@node    Chapter 27, Chapter 28, Chapter 26, Top
@section 27. Practical: An MP3 Database

content 27-intro

@menu
* 27-1::       The Database
* 27-2::       Defining a Schema
* 27-3::       Inserting Values
* 27-4::       Querying the Database
* 27-5::       Matching Functions
* 27-6::       Getting at the Results
* 27-7::       Other Database Operations
@end menu

@node	27-1, 27-2, Chapter 27, Chapter 27
@section The Database

content 27-1

@node	27-2, 27-3, 27-1, Chapter 27
@section Defining a Schema

content 27-2

@node	27-3, 27-4, 27-2, Chapter 27
@section Inserting Values

content 27-3

@node	27-4, 27-5, 27-3, Chapter 27
@section Querying the Database

content 27-4

@node	27-5, 27-6, 27-4, Chapter 27
@section Matching Functions

content 27-5

@node	27-6, 27-7, 27-5, Chapter 27
@section Getting at the Results

content 27-6

@node	27-7, Chapter 28, 27-6, Chapter 27
@section Other Database Operations

content 27-7

@node    Chapter 28, Chapter 29, Chapter 27, Top
@section 28. Practical: A Shoutcast Server

content 28-intro

@menu
* 28-1::       The Shoutcast Protocol
* 28-2::       Song Sources
* 28-3::       Implementing Shoutcast
@end menu

@node	28-1, 28-2, Chapter 28, Chapter 28
@section The Shoutcast Protocol

content 28-1

@node	28-2, 28-3, 28-1, Chapter 28
@section Song Sources

content 28-2

@node	28-3, Chapter 29, 28-2, Chapter 28
@section Implementing Shoutcast

content 28-3

@node    Chapter 29, Chapter 30, Chapter 28, Top
@section 29. Practical: An MP3 Browser

content 29-intro

@menu
* 29-1::       Playlists
* 29-2::       Playlists As Song Sources
* 29-3::       Manipulating the Playlist
* 29-4::       Query Parameter Types
* 29-5::       Boilerplate HTML
* 29-6::       The Browse Page
* 29-7::       The Playlist
* 29-8::       Finding a Playlist
* 29-9::       Running the App
@end menu

@node	29-1, 29-2, Chapter 29, Chapter 29
@section Playlists

content 29-1

@node	29-2, 29-3, 29-1, Chapter 29
@section Playlists As Song Sources

content 29-2

@node	29-3, 29-4, 29-2, Chapter 29
@section Manipulating the Playlist

content 29-3

@node	29-4, 29-5, 29-3, Chapter 29
@section Query Parameter Types

content 29-4

@node	29-5, 29-6, 29-4, Chapter 29
@section Boilerplate HTML

content 29-5

@node	29-6, 29-7, 29-5, Chapter 29
@section The Browse Page

content 29-6

@node	29-7, 29-8, 29-6, Chapter 29
@section The Playlist

content 29-7

@node	29-8, 29-9, 29-7, Chapter 29
@section Finding a Playlist

content 29-8

@node	29-9, Chapter 30, 29-8, Chapter 29
@section Running the App

content 29-9

@node    Chapter 30, Chapter 31, Chapter 29, Top
@section 30. Practical: An HTML Generation Library, the Interpreter

content 30-intro

@menu
* 30-1::       Designing a Domain-Specific Language
* 30-2::       The FOO Language
* 30-3::       Character Escaping
* 30-4::       Indenting Printer
* 30-5::       HTML Processor Interface
* 30-6::       The Pretty Printer Backend
* 30-7::       The Basic Evaluation Rule
* 30-8::       What's Next?
@end menu

@node	30-1, 30-2, Chapter 30, Chapter 30
@section Designing a Domain-Specific Language

content 30-1

@node	30-2, 30-3, 30-1, Chapter 30
@section The FOO Language

content 30-2

@node	30-3, 30-4, 30-2, Chapter 30
@section Character Escaping

content 30-3

@node	30-4, 30-5, 30-3, Chapter 30
@section Indenting Printer

content 30-4

@node	30-5, 30-6, 30-4, Chapter 30
@section HTML Processor Interface

content 30-5

@node	30-6, 30-7, 30-5, Chapter 30
@section The Pretty Printer Backend

content 30-6

@node	30-7, 30-8, 30-6, Chapter 30
@section The Basic Evaluation Rule

content 30-7

@node	30-8, Chapter 31, 30-7, Chapter 30
@section What's Next?

content 30-8

@node    Chapter 31, Chapter 32, Chapter 30, Top
@section 31. Practical: An HTML Generation Library, the Compiler

content 31-intro

@menu
* 31-1::       The Compiler
* 31-2::       FOO Special Operators
* 31-3::       FOO Macros
* 31-4::       The Public API
* 31-5::       The End of the Line
@end menu

@node	31-1, 31-2, Chapter 31, Chapter 31
@section The Compiler

content 31-1

@node	31-2, 31-3, 31-1, Chapter 31
@section FOO Special Operators

content 31-2

@node	31-3, 31-4, 31-2, Chapter 31
@section FOO Macros

content 31-3

@node	31-4, 31-5, 31-3, Chapter 31
@section The Public API

content 31-4

@node	31-5, Chapter 32, 31-4, Chapter 31
@section The End of the Line

content 31-5

@node    Chapter 32, , Chapter 31, Top
@section 32. Conclusion: What's Next?

content 32-intro

@menu
* 32-1::        Finding Lisp Libraries
* 32-2::        Interfacing with Other Languages
* 32-3::        Make It Work, Make It Right, Make It Fast
* 32-4::        Delivering Applications
* 32-5::        Where to Go Next
@end menu

@node	32-1, 32-2, Chapter 32, Chapter 32
@section Finding Lisp Libraries

content 32-1

@node	32-2, 32-3, 32-1, Chapter 32
@section Interfacing with Other Languages

content 32-2

@node	32-3, 32-4, 32-2, Chapter 32
@section Make It Work, Make It Right, Make It Fast

content 32-3

@node	32-4, 32-5, 32-3, Chapter 32
@section Delivering Applications

content 32-4

@node	32-5, Top, 32-4, Chapter 32
@section Where to Go Next

content 32-5
