@node Top, Preface, (dir), (dir)

@ifinfo

@heading Practical Common Lisp

@noindent
`that book is dead sexy` —Xach on #lisp@*
@copyright{} 2003-2009, Peter Seibel

@noindent
Unofficial Texinfo Format

@end ifinfo

@menu
* Preface::     Preface
* Letter::      Letter to the Reader
* Blurbs::      Blurbs
* Chapter 1::   Introduction: Why Lisp?
* Chapter 2::   Lather, Rinse, Repeat: A Tour of the REPL
* Chapter 3::   Practical: A Simple Database
* Chapter 4::   Syntax and Semantics
* Chapter 5::   Functions
* Chapter 6::   Variables
* Chapter 7::   Macros: Standard Control Constructs
* Chapter 8::   Macros: Defining Your Own
* Chapter 9::   Practical: Building a Unit Test Framework
* Chapter 10::  Numbers, Characters, and Strings
* Chapter 11::  Collections
* Chapter 12::  They Called It LISP for a Reason: List Processing
* Chapter 13::  Beyond Lists: Other Uses for Cons Cells
* Chapter 14::  Files and File I/O
* Chapter 15::  Practical: A Portable Pathname Library
* Chapter 16::  Object Reorientation: Generic Functions
* Chapter 17::  Object Reorientation: Classes
* Chapter 18::  A Few FORMAT Recipes
* Chapter 19::  Beyond Exception Handling: Conditions and Restarts
* Chapter 20::  The Special Operators
* Chapter 21::  Programming in the Large: Packages and Symbols
* Chapter 22::  LOOP for Black Belts
* Chapter 23::  Practical: A Spam Filter
* Chapter 24::  Practical: Parsing Binary Files
* Chapter 25::  Practical: An ID3 Parser
* Chapter 26::  Practical: Web Programming with AllegroServe
* Chapter 27::  Practical: An MP3 Database
* Chapter 28::  Practical: A Shoutcast Server
* Chapter 29::  Practical: An MP3 Browser
* Chapter 30::  Practical: An HTML Generation Library, the Interpreter
* Chapter 31::  Practical: An HTML Generation Library, the Compiler
* Chapter 32::  Conclusion: What's Next?

@detailmenu
 --- The Detailed Node Listing ---

1. Introduction: Why Lisp?

* 1-1::              Why Lisp?
* 1-2::              Where It Began
* 1-3::              Who This Book Is For

2. Lather, Rinse, Repeat: A Tour of the REPL

* 2-1::              Choosing a Lisp Implementation
* 2-2::              Getting Up and Running with Lisp in a Box
* 2-3::              Free Your Mind: Interactive Programming
* 2-4::              Experimenting in the REPL
* 2-5::              "Hello, World," Lisp Style
* 2-6::              Saving Your Work

3. Practical: A Simple Database

* 3-1::              CDs and Records
* 3-2::              Filing CDs
* 3-3::              Looking at the Database Contents
* 3-4::              Improving the User Interaction
* 3-5::              Saving and Loading the Database
* 3-6::              Querying the Database
* 3-7::              Updating Existing Records--Another Use for WHERE
* 3-8::              Removing Duplication and Winning Big
* 3-9::              Wrapping Up

4. Syntax and Semantics

* 4-1::              What's with All the Parentheses?
* 4-2::              Breaking Open the Black Box
* 4-3::              S-expressions
* 4-4::              S-expressions As Lisp Forms
* 4-5::              Function Calls
* 4-6::              Special Operators
* 4-7::              Macros
* 4-8::              Truth, Falsehood, and Equality
* 4-9::              Formatting Lisp Code

5. Functions

* 5-1::              Defining New Functions
* 5-2::              Function Parameter Lists
* 5-3::              Optional Parameters
* 5-4::              Rest Parameters
* 5-5::              Keyword Parameters
* 5-6::              Mixing Different Parameter Types
* 5-7::              Function Return Values
* 5-8::              Functions As Data, a.k.a. Higher-Order Functions
* 5-9::              Anonymous Functions

6. Variables

* 6-1::              Variable Basics
* 6-2::              Lexical Variables and Closures
* 6-3::              Dynamic, a.k.a. Special, Variables
* 6-4::              Constants
* 6-5::              Assignment
* 6-6::              Generalized Assignment

7. Macros: Standard Control Constructs

* 7-1::              WHEN and UNLESS
* 7-2::              COND
* 7-3::              AND, OR, and NOT
* 7-4::              Looping
* 7-5::              DOLIST and DOTIMES
* 7-6::              DO
* 7-7::              The Mighty LOOP

8. Macros: Defining Your Own

* 8-1::                  The Story of Mac: A Just-So Story
* 8-2::                  Macro Expansion Time vs. Runtime
* 8-3::                  DEF MACRO
* 8-4::                  A Sample Macro: do-primes
* 8-5::                  Macro Parameters
* 8-6::                  Generating the Expansion
* 8-7::                  Plugging the Leaks
* 8-8::                  Macro-Writing Macros
* 8-9::                  Beyond Simple Macros

9. Practical: Building a Unit Test Framework

* 9-1::                  Two First Tries
* 9-2::                  Refactoring
* 9-3::                  Fixing the Return Value
* 9-4::                  Better Result Reporting
* 9-5::                  An Abstraction Emerges
* 9-6::                  A Hierarchy of Tests
* 9-7::                  Wrapping Up

10. Numbers, Characters, and Strings

* 10-1::                 Numbers
* 10-2::                 Numeric Literals
* 10-3::                 Basic Math
* 10-4::                 Numeric Comparisons
* 10-5::                 Higher Math
* 10-6::                 Characters
* 10-7::                 Character Comparisons
* 10-8::                 Strings
* 10-9::                 String Comparisons

11. Collections

* 11-1::                            Vectors
* 11-2::                            Subtypes of Vector
* 11-3::                            Vectors As Sequences
* 11-4::                            Sequence Iterating Functions
* 11-5::                            Higher-Order Function Variants
* 11-6::                            Whole Sequence Manipulations
* 11-7::                            Sorting and Merging
* 11-8::                            Subsequence Manipulations
* 11-9::                            Sequence Predicates
* 11-10::                           Sequence Mapping Functions
* 11-11::                           Hash Tables
* 11-12::                           Hash Table Iteration

12. They Called It LISP for a Reason: List Processing

* 12-1::             "There Is No List"
* 12-2::             Functional Programming and Lists
* 12-3::             "Destructive" Operations
* 12-4::             Combining Recycling with Shared Structure
* 12-5::             List-Manipulation Functions
* 12-6::             Mapping
* 12-7::             Other Structures

13. Beyond Lists: Other Uses for Cons Cells

* 13-1::                Trees
* 13-2::                Sets
* 13-3::                Lookup Tables: Alists and Plists
* 13-4::                DESTRUCTURING-BIND

14. Files and File I/O

* 14-1::      Reading File Data
* 14-2::      Reading Binary Data
* 14-3::      Bulk Reads
* 14-4::      File Output
* 14-5::      Closing Files
* 14-6::      Filenames
* 14-7::      How Pathnames Represent Filenames
* 14-8::      Constructing New Pathnames
* 14-9::      Two Representations of Directory Names
* 14-10::     Interacting with the File System
* 14-11::     Other Kinds of I/O

15. Practical: A Portable Pathname Library

* 15-1::       The API
* 15-2::       *FEATURES* and Read-Time Conditionalization
* 15-3::       Listing a Directory
* 15-4::       Testing a File's Existence
* 15-5::       Walking a Directory Tree

16. Object Reorientation: Generic Functions

* 16-1::   Generic Functions and Classes
* 16-2::   Generic Functions and Methods
* 16-3::   DEFGENERIC
* 16-4::   DEFMETHOD
* 16-5::   Method Combination
* 16-6::   The Standard Method Combination
* 16-7::   Other Method Combinations
* 16-8::   Multimethods
* 16-9::   To Be Continued . . .

17. Object Reorientation: Classes

* 17-1::   DEFCLASS
* 17-2::   Slot Specifiers
* 17-3::   Object Initialization
* 17-4::   Accessor Functions
* 17-5::   WITH-SLOTS and WITH-ACCESSORS
* 17-6::   Class-Allocated Slots
* 17-7::   Slots and Inheritance
* 17-8::   Multiple Inheritance
* 17-9::   Good Object-Oriented Design

18. A Few FORMAT Recipes

* 18-1::         The FORMAT Function
* 18-2::         FORMAT Directives
* 18-3::         Basic Formatting
* 18-4::         Character and Integer Directives
* 18-5::         Floating-Point Directives
* 18-6::         English-Language Directives
* 18-7::         Conditional Formatting
* 18-8::         Iteration
* 18-9::         Hop, Skip, Jump
* 18-10::        And More . . .

19. Beyond Exception Handling: Conditions and Restarts

* 19-1::             The Lisp Way
* 19-2::             Conditions
* 19-3::             Condition Handlers
* 19-4::             Restarts
* 19-5::             Providing Multiple Restarts
* 19-6::             Other Uses for Conditions

20. The Special Operators

* 20-1::        Controlling Evaluation
* 20-2::        Manipulating the Lexical Environment
* 20-3::        Local Flow of Control
* 20-4::        Unwinding the Stack
* 20-5::        Multiple Values
* 20-6::        EVAL-WHEN
* 20-7::        Other Special Operators

21. Programming in the Large: Packages and Symbols

* 21-1::        How the Reader Uses Packages
* 21-2::        A Bit of Package and Symbol Vocabulary
* 21-3::        Three Standard Packages
* 21-4::        Defining Your Own Packages
* 21-5::        Packaging Reusable Libraries
* 21-6::        Importing Individual Names
* 21-7::        Packaging Mechanics
* 21-8::        Package Gotchas

22. LOOP for Black Belts

* 22-1::     The Parts of a LOOP
* 22-2::     Iteration Control
* 22-3::     Counting Loops
* 22-4::     Looping Over Collections and Packages
* 22-5::     Equals-Then Iteration
* 22-6::     Local Variables
* 22-7::     Destructuring Variables
* 22-8::     Value Accumulation
* 22-9::     Unconditional Execution
* 22-10::    Conditional Execution
* 22-11::    Setting Up and Tearing Down
* 22-12::    Termination Tests
* 22-13::    Putting It All Together

23. Practical: A Spam Filter

* 23-1::       The Heart of a Spam Filter
* 23-2::       Training the Filter
* 23-3::       Per-Word Statistics
* 23-4::       Combining Probabilities
* 23-5::       Inverse Chi Square
* 23-6::       Training the Filter
* 23-7::       Testing the Filter
* 23-8::       A Couple of Utility Functions
* 23-9::       Analyzing the Results
* 23-10::      What's Next

24. Practical: Parsing Binary Files

* 24-1::       Binary Files
* 24-2::       Binary Format Basics
* 24-3::       Strings in Binary Files
* 24-4::       Composite Structures
* 24-5::       Designing the Macros
* 24-6::       Making the Dream a Reality
* 24-7::       Reading Binary Objects
* 24-8::       Writing Binary Objects
* 24-9::       Adding Inheritance and Tagged Structures
* 24-10::      Keeping Track of Inherited Slots
* 24-11::      Tagged Structures
* 24-12::      Primitive Binary Types
* 24-13::      The Current Object Stack

25. Practical: An ID3 Parser

* 25-1::       Structure of an ID3v2 Tag
* 25-2::       Defining a Package
* 25-3::       Integer Types
* 25-4::       String Types
* 25-5::       ID3 Tag Header
* 25-6::       ID3 Frames
* 25-7::       Detecting Tag Padding
* 25-8::       Supporting Multiple Versions of ID3
* 25-9::       Versioned Frame Base Classes
* 25-10::      Versioned Concrete Frame Classes
* 25-11::      What Frames Do You Actually Need?
* 25-12::      Text Information Frames
* 25-13::      Comment Frames
* 25-14::      Extracting Information from an ID3 Tag

26. Practical: Web Programming with AllegroServe

* 26-1::       A 30-Second Intro to Server-Side Web Programming
* 26-2::       AllegroServe
* 26-3::       Generating Dynamic Content with AllegroServe
* 26-4::       Generating HTML
* 26-5::       HTML Macros
* 26-6::       Query Parameters
* 26-7::       Cookies
* 26-8::       A Small Application Framework
* 26-9::       The Implementation

27. Practical: An MP3 Database

* 27-1::       The Database
* 27-2::       Defining a Schema
* 27-3::       Inserting Values
* 27-4::       Querying the Database
* 27-5::       Matching Functions
* 27-6::       Getting at the Results
* 27-7::       Other Database Operations

28. Practical: A Shoutcast Server

* 28-1::       The Shoutcast Protocol
* 28-2::       Song Sources
* 28-3::       Implementing Shoutcast

29. Practical: An MP3 Browser

* 29-1::       Playlists
* 29-2::       Playlists As Song Sources
* 29-3::       Manipulating the Playlist
* 29-4::       Query Parameter Types
* 29-5::       Boilerplate HTML
* 29-6::       The Browse Page
* 29-7::       The Playlist
* 29-8::       Finding a Playlist
* 29-9::       Running the App

30. Practical: An HTML Generation Library, the Interpreter

* 30-1::       Designing a Domain-Specific Language
* 30-2::       The FOO Language
* 30-3::       Character Escaping
* 30-4::       Indenting Printer
* 30-5::       HTML Processor Interface
* 30-6::       The Pretty Printer Backend
* 30-7::       The Basic Evaluation Rule
* 30-8::       What's Next?

31. Practical: An HTML Generation Library, the Compiler

* 31-1::       The Compiler
* 31-2::       FOO Special Operators
* 31-3::       FOO Macros
* 31-4::       The Public API
* 31-5::       The End of the Line

32. Conclusion: What's Next?

* 32-1::        Finding Lisp Libraries
* 32-2::        Interfacing with Other Languages
* 32-3::        Make It Work, Make It Right, Make It Fast
* 32-4::        Delivering Applications
* 32-5::        Where to Go Next


@end detailmenu
@end menu

@node    Preface, Letter, Top, Top
@unnumbered Preface

This page, and the pages it links to, contain text of the Common Lisp book Practical Common Lisp published by Apress. These pages now contain the final text as it appears in the book. If you find errors in these pages, please send email to @email{book@@gigamonkeys.com}. These pages will remain online in perpetuity—I hope they will serve as a useful introduction to Common Lisp for folks who are curious about Lisp but maybe not yet curious enough to shell out big bucks for a dead-tree book and a good Common Lisp tutorial for folks who want to get down to real coding right away. However, don't let that stop you from buying the printed version available from Apress at your favorite local or online bookseller. For the complete bookstore browsing experience, you can read the letter to the reader that appears on the back cover of the treeware edition of the book.

@node    Letter, Blurbs, Preface, Top
@unnumbered Letter to the Reader

Dear Reader,

Practical Common Lisp ... isn't that an oxymoron? If you're like most programmers, you probably know something about Lisp—from a comp sci course in college or from learning enough Elisp to customize Emacs a bit. Or maybe you just know someone who won't shut up about Lisp, the greatest language ever. But you probably never figured you'd see practical and Lisp in the same book title.

Yet, you're reading this; you must want to know more. Maybe you believe learning Lisp will make you a better programmer in any language. Or maybe you just want to know what those Lisp fanatics are yammering about all the time. Or maybe you have learned some Lisp but haven't quite made the leap to using it to write interesting software.

If any of those is true, this book is for you. Using Common Lisp, an ANSI standardized, industrial-strength dialect of Lisp, I show you how to write software that goes well beyond silly academic exercises or trivial editor customizations. And I show you how Lisp—even with many of its features adopted by other languages—still has a few tricks up its sleeve.

But unlike many Lisp books, this one doesn't just touch on a few of Lisp's greatest features and then leave you on your own to actually use them. I cover all the language features you'll need to write real programs and devote well over a third of the book to developing nontrivial software—a statistical spam filter, a library for parsing binary files, and a server for streaming MP3s over a network complete with an online MP3 database and Web interface.

So turn the book over, open it up, and see for yourself how eminently practical using the greatest language ever invented can be.

Sincerely,

Peter Seibel

@node    Blurbs, Chapter 1, Letter, Top

@quotation
“I have been complimented many times and they always embarrass me; I always feel that they have not said enough.”
—Mark Twain
@end quotation

@unnumbered Blurbs

@quotation
“Peter Seibel offers a fresh view of Lisp and its possibilities for elegantly solving problems. In Practical Common Lisp, he gives enough basic information to let you quickly see the power of the functional language paradigm. He then dazzles you with examples that seem almost magical in their simplicity and power. This read is pure fun from start to finish.”
-—Gary Pollice, from @uref{http://www.drdobbs.com/joltawards/2006-jolt-awards/187900423?pgno=4, Dr. Dobb's Portal, May 17, 2006 article on the 2006 Jolt Awards}
@end quotation

“Peter Seibel's Practical Common Lisp is just what the title implies: an excellent introduction to Common Lisp for someone who wants to dive in and start using the language for real work. The book is very well written and is fun to read—at least for those of us whose idea of fun extends to learning new programming languages.

Rather than spending a lot of time on abstract discussion of Lisp's place in the universe of programming lnaguages, Seibel dives right in, guiding the reader through a series of programming examples of increasing complexity. This approach places the most emphasis on those parts of Common Lisp that skilled programmers use the most, without getting bogged down in the odd corners of Common Lisp that even the experts must look up in the manual. The result of Seibel's example-driven approach is to give the reader an excellent appreciation of the power of Common Lisp in building complex, evolving software systems with a minimum of effort.

There are already many good books on Common Lisp that offer a more abstract and comparative approach, but a good ‘Here's how you do it—and why’ book, aimed at the working programmer, is a valuable contribution, both to current Common Lisp users and those who should be.” —Scott E. Fahlman, Research Professor of Computer Science, Carnegie Mellon University

“This book shows the power of Lisp not only in the areas that it has traditionally been noted for—such as developing a complete unit test framework in only 26 lines of code—but also in new areas such as parsing binary MP3 files, building a web application for browsing a collection of songs, and streaming audio over the web. Many readers will be surprised that Lisp allows you to do all this with conciseness similar to scripting languages such as Python, efficiency similar to C++, and unparalleled flexibility in designing your own language extensions.” —Peter Norvig, Director of Search Quality, Google Inc; author of Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp

“I wish this book had already existed when I started learning Lisp. It's not that there aren't other good books about (Common) Lisp out there, but none of them has such a pragmatic, up-to-date approach. And let's not forget that Peter covers topics like pathnames or conditions and restarts which are completely ignored in the rest of the Lisp literature.

If you're new to Lisp and want to dive right in don't hesitate to buy this book. Once you've read it and worked with it you can continue with the ‘classics’ like Graham, Norvig, Keene, or Steele.” —Edi Weitz, maintainer of the Common Lisp Cookbook and author of CL-PPCRE regular expression library.

“Two prehensile toes up!” —Kenny Tilton, comp.lang.lisp demon, reporting on behalf of his development team.

“Experienced programmers learn best from examples and it is delightful to see that Lisp is finally being served with Seibel's example-rich tutorial text. Especially delightful is the fact that this book includes so many examples that fall within the realm of problems today's programmers might be called upon to tackle, such as Web development and streaming media.—Philip Greenspun, author of Software Engineering for Internet Applications, MIT Department of Electrical Engineering and Computer Science

“Practical Common Lisp is an excellent book that covers the breadth of the Common Lisp language and also demonstrates the unique features of Common Lisp with real-world applications that the reader can run and extend. This book not only shows what Common Lisp is but also why every programmer should be familiar with Lisp.” —John Foderaro, Senior Scientist, Franz Inc.

“The Maxima Project frequently gets queries from potential new contributors who would like to learn Common Lisp. I am pleased to finally have a book that I can recommend to them without reservation. Peter Seibel's clear, direct style allows the reader to quickly appreciate the power of Common Lisp. His many included examples, which focus on contemporary programming problems, demonstrate that Lisp is much more than an academic programming language. Practical Common Lisp is a welcome addition to the literature.” —James Amundson, Maxima Project Leader

“I like the interspersed Practical chapters on 'real' and useful programs. We need books of this kind telling the world that crunching strings and numbers into trees or graphs is easily done in Lisp.—Professor Christian Queinnec, Universite Paris 6 (Pierre et Marie Curie)

“One of the most important parts of learning a programming language is learning its proper programming style. This is hard to teach, but it can be painlessly absorbed from Practical Common Lisp. Just reading the practical examples made me a better programmer in any language.” —Peter Scott, Lisp programmer

“Finally, a Lisp book for the rest of us. If you want to learn how to write a factorial function, this is not your book. Seibel writes for the practical programmer, emphasizing the engineer/artist over the scientist, subtly and gracefully implying the power of the language while solving understandable real-world problems.

In most chapters, the reading of the chapter feels just like the experience of writing a program, starting with a little understanding, then having that understanding grow, like building the shoulders upon which you can then stand. When Seibel introduced macros as an aside while building a test framework, I was shocked at how such a simple example made me really 'get' them. Narrative context is extremely powerful and the technical books that use it are a cut above. Congrats!” —Keith Irwin, Lisp Programmer

“While learning Lisp, one is often refered to the CL HyperSpec if they do not know what a particular function does, however, I found that I often did not 'get it' just reading the HyperSpec. When I had a problem of this manner, I turned to Practical Common Lisp every single time—it is by far the most readable source on the subject that shows you how to program, not just tell you.” —Philip Haddad, Lisp Programmer

“With the IT world evolving at an ever increasing pace, professionals need the most powerful tools available. This is why Common Lisp—the most powerful, flexible, and stable programming language ever—is seeing such a rise in popularity. Practical Common Lisp is the long-awaited book that will help you harness the power of Common Lisp to tackle today's complex real world problems.” —Marc Battyani, author of CL-PDF, CL-TYPESETTING, and mod_lisp.

“Please don't assume Common Lisp is only useful for Databases, Unit Test Frameworks, Spam Filters, ID3 Parsers, Web Programming, Shoutcast Servers, HTML Generation Interpreters, and HTML Generation Compilers just because these are the only things happened to be implemented in the book Practical Common Lisp.—Tobias C. Rittweiler, Lisp Programmer

“When I met Peter, who just started writing this book, I asked to myself (not to him, of course) ‘why yet another book on Common Lisp, when there are many nice introductory books?’ One year later, I found a draft of the new book and recognized I was wrong. This book is not ‘yet another’ one. The author focuses on practical aspects rather than on technical details of the language. When I first studied Lisp by reading an introductory book, I felt I understood the language, but I also had an impression ‘so what?’, meaning I had no idea about how to use it. In contrast, this book leaps into a ‘PRACTICAL’ chapter after the first few chapters that explain the very basic notions of the language. Then the readers are expected to learn more about the language while they are following the PRACTICAL projects, which are combined together to form a product of a significant size. After reading this book, the readers will feel themselves expert programmers on Common Lisp since they have ‘finished’ a big project already. I think Lisp is the only language that allows this type of practical introduction. Peter makes use of this feature of the language in building up a fancy introduction on Common Lisp.” —Taiichi Yuasa, Professor, Department of Communications and Computer Engineering, Kyoto University

Have something to say about this book? Something nice? Want to see it here? Send it along to @email{book@@gigamonkeys.com}.

@node    Chapter 1, Chapter 2, Blurbs, Top
@section 1. Introduction: Why Lisp?

If you think the greatest pleasure in programming comes from getting a lot done with code that simply and clearly expresses your intention, then programming in Common Lisp is likely to be about the most fun you can have with a computer. You'll get more done, faster, using it than you would using pretty much any other language.

That's a bold claim. Can I justify it? Not in a just a few pages in this chapter--you're going to have to learn some Lisp and see for yourself--thus the rest of this book. For now, let me start with some anecdotal evidence, the story of my own road to Lisp. Then, in the next section, I'll explain the payoff I think you'll get from learning Common Lisp.

I'm one of what must be a fairly small number of second-generation Lisp hackers. My father got his start in computers writing an operating system in assembly for the machine he used to gather data for his doctoral dissertation in physics. After running computer systems at various physics labs, by the 1980s he had left physics altogether and was working at a large pharmaceutical company. That company had a project under way to develop software to model production processes in its chemical plants--if you increase the size of this vessel, how does it affect annual production? The original team, writing in FORTRAN, had burned through half the money and almost all the time allotted to the project with nothing to show for their efforts. This being the 1980s and the middle of the artificial intelligence (AI) boom, Lisp was in the air. So my dad--at that point not a Lisper--went to Carnegie Mellon University (CMU) to talk to some of the folks working on what was to become Common Lisp about whether Lisp might be a good language for this project.

The CMU folks showed him some demos of stuff they were working on, and he was convinced. He in turn convinced his bosses to let his team take over the failing project and do it in Lisp. A year later, and using only what was left of the original budget, his team delivered a working application with features that the original team had given up any hope of delivering. My dad credits his team's success to their decision to use Lisp.

Now, that's just one anecdote. And maybe my dad is wrong about why they succeeded. Or maybe Lisp was better only in comparison to other languages of the day. These days we have lots of fancy new languages, many of which have incorporated features from Lisp. Am I really saying Lisp can offer you the same benefits today as it offered my dad in the 1980s? Read on.

Despite my father's best efforts, I didn't learn any Lisp in high school. After a college career that didn't involve much programming in any language, I was seduced by the Web and back into computers. I worked first in Perl, learning enough to be dangerous while building an online discussion forum for Mother Jones magazine's Web site and then moving to a Web shop, Organic Online, where I worked on big--for the time--Web sites such as the one Nike put up during the 1996 Olympics. Later I moved onto Java as an early developer at WebLogic, now part of BEA. After WebLogic, I joined another startup where I was the lead programmer on a team building a transactional messaging system in Java. Along the way, my general interest in programming languages led me to explore such mainstream languages as C, C++, and Python, as well as less well-known ones such as Smalltalk, Eiffel, and Beta.

So I knew two languages inside and out and was familiar with another half dozen. Eventually, however, I realized my interest in programming languages was really rooted in the idea planted by my father's tales of Lisp--that different languages really are different, and that, despite the formal Turing equivalence of all programming languages, you really can get more done more quickly in some languages than others and have more fun doing it. Yet, ironically, I had never spent that much time with Lisp itself. So, I started doing some Lisp hacking in my free time. And whenever I did, it was exhilarating how quickly I was able to go from idea to working code.

For example, one vacation, having a week or so to hack Lisp, I decided to try writing a version of a program--a system for breeding genetic algorithms to play the game of Go--that I had written early in my career as a Java programmer. Even handicapped by my then rudimentary knowledge of Common Lisp and having to look up even basic functions, it still felt more productive than it would have been to rewrite the same program in Java, even with several extra years of Java experience acquired since writing the first version.

A similar experiment led to the library I'll discuss in Chapter 24. Early in my time at WebLogic I had written a library, in Java, for taking apart Java class files. It worked, but the code was a bit of a mess and hard to modify or extend. I had tried several times, over the years, to rewrite that library, thinking that with my ever-improving Java chops I'd find some way to do it that didn't bog down in piles of duplicated code. I never found a way. But when I tried to do it in Common Lisp, it took me only two days, and I ended up not only with a Java class file parser but with a general-purpose library for taking apart any kind of binary file. You'll see how that library works in Chapter 24 and use it in Chapter 25 to write a parser for the ID3 tags embedded in MP3 files.

@menu
* 1-1::              Why Lisp?
* 1-2::              Where It Began
* 1-3::              Who This Book Is For
@end menu

@node	1-1, 1-2, Chapter 1, Chapter 1
@section Why Lisp?

It's hard, in only a few pages of an introductory chapter, to explain why users of a language like it, and it's even harder to make the case for why you should invest your time in learning a certain language. Personal history only gets us so far. Perhaps I like Lisp because of some quirk in the way my brain is wired. It could even be genetic, since my dad has it too. So before you dive into learning Lisp, it's reasonable to want to know what the payoff is going to be.

For some languages, the payoff is relatively obvious. For instance, if you want to write low-level code on Unix, you should learn C. Or if you want to write certain kinds of cross-platform applications, you should learn Java. And any of a number companies still use a lot of C++, so if you want to get a job at one of them, you should learn C++.

For most languages, however, the payoff isn't so easily categorized; it has to do with subjective criteria such as how it feels to use the language. Perl advocates like to say that Perl "makes easy things easy and hard things possible" and revel in the fact that, as the Perl motto has it, "There's more than one way to do it." @footnote{Perl is also worth learning as "the duct tape of the Internet."} Python's fans, on the other hand, think Python is clean and simple and think Python code is easier to understand because, as @emph{their} motto says, "There's only one way to do it."

So, why Common Lisp? There's no immediately obvious payoff for adopting Common Lisp the way there is for C, Java, and C++ (unless, of course, you happen to own a Lisp Machine). The benefits of using Lisp have much more to do with the experience of using it. I'll spend the rest of this book showing you the specific features of Common Lisp and how to use them so you can see for yourself what it's like. For now I'll try to give you a sense of Lisp's philosophy.

The nearest thing Common Lisp has to a motto is the koan-like description, "the programmable programming language." While cryptic, that description gets at the root of the biggest advantage Common Lisp still has over other languages. More than any other language, Common Lisp follows the philosophy that what's good for the language's designer is good for the language's users. Thus, when you're programming in Common Lisp, you almost never find yourself wishing the language supported some feature that would make your program easier to write, because, as you'll see throughout this book, you can just add the feature yourself.

Consequently, a Common Lisp program tends to provide a much clearer mapping between your ideas about how the program works and the code you actually write. Your ideas aren't obscured by boilerplate code and endlessly repeated idioms. This makes your code easier to maintain because you don't have to wade through reams of code every time you need to make a change. Even systemic changes to a program's behavior can often be achieved with relatively small changes to the actual code. This also means you'll develop code more quickly; there's less code to write, and you don't waste time thrashing around trying to find a clean way to express yourself within the limitations of the language. @footnote{Unfortunately, there's little actual research on the productivity of different languages. One report that shows Lisp coming out well compared to C++ and Java in the combination of programmer and program efficiency is discussed at http://www.norvig.com/java-lisp.html.}

Common Lisp is also an excellent language for exploratory programming--if you don't know exactly how your program is going to work when you first sit down to write it, Common Lisp provides several features to help you develop your code incrementally and interactively.

For starters, the interactive read-eval-print loop, which I'll introduce in the next chapter, lets you continually interact with your program as you develop it. Write a new function. Test it. Change it. Try a different approach. You never have to stop for a lengthy compilation cycle. @footnote{Psychologists have identified a state of mind called flow in which we're capable of incredible concentration and productivity. The importance of flow to programming has been recognized for nearly two decades since it was discussed in the classic book about human factors in programming Peopleware: Productive Projects and Teams by Tom DeMarco and Timothy Lister (Dorset House, 1987). The two key facts about flow are that it takes around 15 minutes to get into a state of flow and that even brief interruptions can break you right out of it, requiring another 15-minute immersion to reenter. DeMarco and Lister, like most subsequent authors, concerned themselves mostly with flow-destroying interruptions such as ringing telephones and inopportune visits from the boss. Less frequently considered but probably just as important to programmers are the interruptions caused by our tools. Languages that require, for instance, a lengthy compilation before you can try your latest code can be just as inimical to flow as a noisy phone or a nosy boss. So, one way to look at Lisp is as a language designed to keep you in a state of flow.}

Other features that support a flowing, interactive programming style are Lisp's dynamic typing and the Common Lisp condition system. Because of the former, you spend less time convincing the compiler you should be allowed to run your code and more time actually running it and working on it, @footnote{This point is bound to be somewhat controversial, at least with some folks. Static versus dynamic typing is one of the classic religious wars in programming. If you're coming from C++ and Java (or from statically typed functional languages such as Haskel and ML) and refuse to consider living without static type checks, you might as well put this book down now. However, before you do, you might first want to check out what self-described "statically typed bigot" Robert Martin (author of Designing Object Oriented C++ Applications Using the Booch Method [Prentice Hall, 1995]) and C++ and Java author Bruce Eckel (author of Thinking in C++ [Prentice Hall, 1995] and Thinking in Java [Prentice Hall, 1998]) have had to say about dynamic typing on their weblogs (http://www.artima.com/weblogs/viewpost.jsp?thread=4639 and http://www.mindview.net/WebLog/log-0025). On the other hand, folks coming from Smalltalk, Python, Perl, or Ruby should feel right at home with this aspect of Common Lisp.} and the latter lets you develop even your error handling code interactively.

Another consequence of being "a programmable programming language" is that Common Lisp, in addition to incorporating small changes that make particular programs easier to write, can easily adopt big new ideas about how programming languages should work. For instance, the original implementation of the Common Lisp Object System (CLOS), Common Lisp's powerful object system, was as a library written in portable Common Lisp. This allowed Lisp programmers to gain actual experience with the facilities it provided before it was officially incorporated into the language.

Whatever new paradigm comes down the pike next, it's extremely likely that Common Lisp will be able to absorb it without requiring any changes to the core language. For example, a Lisper has recently written a library, AspectL, that adds support for aspect-oriented programming (AOP) to Common Lisp. @footnote{AspectL is an interesting project insofar as AspectJ, its Java-based predecessor, was written by Gregor Kiczales, one of the designers of Common Lisp's object and metaobject systems. To many Lispers, AspectJ seems like Kiczales's attempt to backport his ideas from Common Lisp into Java. However, Pascal Costanza, the author of AspectL, thinks there are interesting ideas in AOP that could be useful in Common Lisp. Of course, the reason he's able to implement AspectL as a library is because of the incredible flexibility of the Common Lisp Meta Object Protocol Kiczales designed. To implement AspectJ, Kiczales had to write what was essentially a separate compiler that compiles a new language into Java source code. The AspectL project page is at http://common-lisp.net/ project/aspectl/.} If AOP turns out to be the next big thing, Common Lisp will be able to support it without any changes to the base language and without extra preprocessors and extra compilers. @footnote{Or to look at it another, more technically accurate, way, Common Lisp comes with a built-in facility for integrating compilers for embedded languages.}

@node	1-2, 1-3, 1-1, Chapter 1
@section Where It Began

Common Lisp is the modern descendant of the Lisp language first conceived by John McCarthy in 1956. Lisp circa 1956 was designed for "symbolic data processing" @footnote{Lisp 1.5 Programmer's Manual (M.I.T. Press, 1962)} and derived its name from one of the things it was quite good at: LISt Processing. We've come a long way since then: Common Lisp sports as fine an array of modern data types as you can ask for: a condition system that, as you'll see in Chapter 19, provides a whole level of flexibility missing from the exception systems of languages such as Java, Python, and C++; powerful facilities for doing object-oriented programming; and several language facilities that just don't exist in other programming languages. How is this possible? What on Earth would provoke the evolution of such a well-equipped language?

Well, McCarthy was (and still is) an artificial intelligence (AI) researcher, and many of the features he built into his initial version of the language made it an excellent language for AI programming. During the AI boom of the 1980s, Lisp remained a favorite tool for programmers writing software to solve hard problems such as automated theorem proving, planning and scheduling, and computer vision. These were problems that required a lot of hard-to-write software; to make a dent in them, AI programmers needed a powerful language, and they grew Lisp into the language they needed. And the Cold War helped--as the Pentagon poured money into the Defense Advanced Research Projects Agency (DARPA), a lot of it went to folks working on problems such as large-scale battlefield simulations, automated planning, and natural language interfaces. These folks also used Lisp and continued pushing it to do what they needed.

The same forces that drove Lisp's feature evolution also pushed the envelope along other dimensions--big AI problems eat up a lot of computing resources however you code them, and if you run Moore's law in reverse for 20 years, you can imagine how scarce computing resources were on circa-80s hardware. The Lisp guys had to find all kinds of ways to squeeze performance out of their implementations. Modern Common Lisp implementations are the heirs to those early efforts and often include quite sophisticated, native machine code-generating compilers. While today, thanks to Moore's law, it's possible to get usable performance from a purely interpreted language, that's no longer an issue for Common Lisp. As I'll show in Chapter 32, with proper (optional) declarations, a good Lisp compiler can generate machine code quite similar to what might be generated by a C compiler.

The 1980s were also the era of the Lisp Machines, with several companies, most famously Symbolics, producing computers that ran Lisp natively from the chips up. Thus, Lisp became a systems programming language, used for writing the operating system, editors, compilers, and pretty much everything else that ran on the Lisp Machines.

In fact, by the early 1980s, with various AI labs and the Lisp machine vendors all providing their own Lisp implementations, there was such a proliferation of Lisp systems and dialects that the folks at DARPA began to express concern about the Lisp community splintering. To address this concern, a grassroots group of Lisp hackers got together in 1981 and began the process of standardizing a new language called Common Lisp that combined the best features from the existing Lisp dialects. Their work was documented in the book Common Lisp the Language by Guy Steele (Digital Press, 1984)--CLtL to the Lisp-cognoscenti.

By 1986 the first Common Lisp implementations were available, and the writing was on the wall for the dialects it was intended to replace. In 1996, the American National Standards Institute (ANSI) released a standard for Common Lisp that built on and extended the language specified in CLtL, adding some major new features such as the CLOS and the condition system. And even that wasn't the last word: like CLtL before it, the ANSI standard intentionally leaves room for implementers to experiment with the best way to do things: a full Lisp implementation provides a rich runtime environment with access to GUI widgets, multiple threads of control, TCP/IP sockets, and more. These days Common Lisp is evolving much like other open-source languages--the folks who use it write the libraries they need and often make them available to others. In the last few years, in particular, there has been a spurt of activity in open-source Lisp libraries.

So, on one hand, Lisp is one of computer science's "classical" languages, based on ideas that have stood the test of time. @footnote{Ideas first introduced in Lisp include the if/then/else construct, recursive function calls, dynamic memory allocation, garbage collection, first-class functions, lexical closures, interactive programming, incremental compilation, and dynamic typing.} On the other, it's a thoroughly modern, general-purpose language whose design reflects a deeply pragmatic approach to solving real problems as efficiently and robustly as possible. The only downside of Lisp's "classical" heritage is that lots of folks are still walking around with ideas about Lisp based on some particular flavor of Lisp they were exposed to at some particular time in the nearly half century since McCarthy invented Lisp. If someone tells you Lisp is only interpreted, that it's slow, or that you have to use recursion for everything, ask them what dialect of Lisp they're talking about and whether people were wearing bell-bottoms when they learned it. @footnote{One of the most commonly repeated myths about Lisp is that it's "dead." While it's true that Common Lisp isn't as widely used as, say, Visual Basic or Java, it seems strange to describe a language that continues to be used for new development and that continues to attract new users as "dead." Some recent Lisp success stories include Paul Graham's Viaweb, which became Yahoo Store when Yahoo bought his company; ITA Software's airfare pricing and shopping system, QPX, used by the online ticket seller Orbitz and others; Naughty Dog's game for the PlayStation 2, Jak and Daxter, which is largely written in a domain-specific Lisp dialect Naughty Dog invented called GOAL, whose compiler is itself written in Common Lisp; and the Roomba, the autonomous robotic vacuum cleaner, whose software is written in L, a downwardly compatible subset of Common Lisp. Perhaps even more telling is the growth of the Common-Lisp.net Web site, which hosts open-source Common Lisp projects, and the number of local Lisp user groups that have sprung up in the past couple of years.}

@node	1-3,  , 1-2, Chapter 1
@section Who This Book Is For

This book is for you if you're curious about Common Lisp, regardless of whether you're already convinced you want to use it or if you just want to know what all the fuss is about.

If you've learned some Lisp already but have had trouble making the leap from academic exercises to real programs, this book should get you on your way. On the other hand, you don't have to be already convinced that you want to use Lisp to get something out of this book.

If you're a hard-nosed pragmatist who wants to know what advantages Common Lisp has over languages such as Perl, Python, Java, C, or C#, this book should give you some ideas. Or maybe you don't even care about using Lisp--maybe you're already sure Lisp isn't really any better than other languages you know but are annoyed by some Lisper telling you that's because you just don't "get it." If so, this book will give you a straight-to-the-point introduction to Common Lisp. If, after reading this book, you still think Common Lisp is no better than your current favorite languages, you'll be in an excellent position to explain exactly why.

I cover not only the syntax and semantics of the language but also how you can use it to write software that does useful stuff. In the first part of the book, I'll cover the language itself, mixing in a few "practical" chapters, where I'll show you how to write real code. Then, after I've covered most of the language, including several parts that other books leave for you to figure out on your own, the remainder of the book consists of nine more practical chapters where I'll help you write several medium-sized programs that actually do things you might find useful: filter spam, parse binary files, catalog MP3s, stream MP3s over a network, and provide a Web interface for the MP3 catalog and server.

After you finish this book, you'll be familiar with all the most important features of the language and how they fit together, you'll have used Common Lisp to write several nontrivial programs, and you'll be well prepared to continue exploring the language on your own. While everyone's road to Lisp is different, I hope this book will help smooth the way for you. So, let's begin.

@lisp
(define (cube x) (* x x x))
@end lisp

@node    Chapter 2, , Chapter 1, Top
@section 2. Lather, Rinse, Repeat: A Tour of the REPL

In this chapter you'll set up your programming environment and write your first Common Lisp programs. We'll use the easy-to-install Lisp in a Box developed by Matthew Danish and Mikel Evins, which packages a Common Lisp implementation with Emacs, a powerful Lisp-aware text editor, and SLIME,1 a Common Lisp development environment built on top of Emacs.

This combo provides a state-of-the-art Common Lisp development environment that supports the incremental, interactive development style that characterizes Lisp programming. The SLIME environment has the added advantage of providing a fairly uniform user interface regardless of the operating system and Common Lisp implementation you choose. I'll use the Lisp in a Box environment in order to have a specific development environment to talk about; folks who want to explore other development environments such as the graphical integrated development environments (IDEs) provided by some of the commercial Lisp vendors or environments based on other editors shouldn't have too much trouble translating the basics.2

@menu
* 2-1::              Choosing a Lisp Implementation
* 2-2::              Getting Up and Running with Lisp in a Box
* 2-3::              Free Your Mind: Interactive Programming
* 2-4::              Experimenting in the REPL
* 2-5::              "Hello, World," Lisp Style
* 2-6::              Saving Your Work

@end menu

@node	2-1, 2-2, Chapter 2, Chapter 2
@section Choosing a Lisp Implementation

The first thing you have to do is to choose a Lisp implementation. This may seem like a strange thing to have to do for folks used to languages such as Perl, Python, Visual Basic (VB), C#, and Java. The difference between Common Lisp and these languages is that Common Lisp is defined by its standard--there is neither a single implementation controlled by a benevolent dictator, as with Perl and Python, nor a canonical implementation controlled by a single company, as with VB, C#, and Java. Anyone who wants to read the standard and implement the language is free to do so. Furthermore, changes to the standard have to be made in accordance with a process controlled by the standards body American National Standards Institute (ANSI). That process is designed to keep any one entity, such as a single vendor, from being able to arbitrarily change the standard.3 Thus, the Common Lisp standard is a contract between any Common Lisp vendor and Common Lisp programmers. The contract tells you that if you write a program that uses the features of the language the way they're described in the standard, you can count on your program behaving the same in any conforming implementation.

On the other hand, the standard may not cover everything you may want to do in your programs--some things were intentionally left unspecified in order to allow continuing experimentation by implementers in areas where there wasn't consensus about the best way for the language to support certain features. So every implementation offers some features above and beyond what's specified in the standard. Depending on what kind of programming you're going to be doing, it may make sense to just pick one implementation that has the extra features you need and use that. On the other hand, if we're delivering Lisp source to be used by others, such as libraries, you'll want--as far as possible--to write portable Common Lisp. For writing code that should be mostly portable but that needs facilities not defined by the standard, Common Lisp provides a flexible way to write code "conditionalized" on the features available in a particular implementation. You'll see an example of this kind of code in Chapter 15 when we develop a simple library that smoothes over some differences between how different Lisp implementations deal with filenames.

For the moment, however, the most important characteristic of an implementation is whether it runs on our favorite operating system. The folks at Franz, makers of Allegro Common Lisp, are making available a trial version of their product for use with this book that runs on Linux, Windows, and OS X. Folks looking for an open-source implementation have several options. SBCL4 is a high-quality open-source implementation that compiles to native code and runs on a wide variety of Unixes, including Linux and OS X. SBCL is derived from CMUCL,5 which is a Common Lisp developed at Carnegie Mellon University, and, like CMUCL, is largely in the public domain, except a few sections licensed under Berkeley Software Distribution (BSD) style licenses. CMUCL itself is another fine choice, though SBCL tends to be easier to install and now supports 21-bit Unicode.6 For OS X users, OpenMCL is an excellent choice--it compiles to machine code, supports threads, and has quite good integration with OS X's Carbon and Cocoa toolkits. Other open-source and commercial implementations are available. See Chapter 32 for resources from which you can get more information.

All the Lisp code in this book should work in any conforming Common Lisp implementation unless otherwise noted, and SLIME will smooth out some of the differences between implementations by providing us with a common interface for interacting with Lisp. The output shown in this book is from Allegro running on GNU/Linux; in some cases, other Lisp's may generate slightly different error messages or debugger output.

@node	2-2, 2-3, 2-1, Chapter 2
@section Getting Up and Running with Lisp in a Box

Since the Lisp in a Box packaging is designed to get new Lispers up and running in a first-rate Lisp development environment with minimum hassle, all you need to do to get it running is to grab the appropriate package for your operating system and the preferred Lisp from the Lisp in a Box Web site listed in Chapter 32 and then follow the installation instructions.

Since Lisp in a Box uses Emacs as its editor, you'll need to know at least a bit about how to use it. Perhaps the best way to get started with Emacs is to work through its built-in tutorial. To start the tutorial, select the first item of the Help menu, Emacs tutorial. Or press the Ctrl key, type h, release the Ctrl key, and then press t. Most Emacs commands are accessible via such key combinations; because key combinations are so common, Emacs users have a notation for describing key combinations that avoids having to constantly write out combinations such as "Press the Ctrl key, type h, release the Ctrl key, and then press t." Keys to be pressed together--a so-called key chord--are written together and separated by a hyphen. Keys, or key chords, to be pressed in sequence are separated by spaces. In a key chord, C represents the Ctrl key and M represents the Meta key (also known as Alt). Thus, we could write the key combination we just described that starts the tutorial like so: C-h t.

The tutorial describes other useful commands and the key combinations that invoke them. Emacs also comes with extensive online documentation using its own built-in hypertext documentation browser, Info. To read the manual, type C-h i. The Info system comes with its own tutorial, accessible simply by pressing h while reading the manual. Finally, Emacs provides quite a few ways to get help, all bound to key combos starting with C-h. Typing C-h ? brings up a complete list. Two of the most useful, besides the tutorial, are C-h k, which lets us type any key combo and tells us what command it invokes, and C-h w, which lets us enter the name of a command and tells us what key combination invokes it.

The other crucial bit of Emacs terminology, for folks who refuse to work through the tutorial, is the notion of a buffer. While working in Emacs, each file you edit will be represented by a different buffer, only one of which is "current" at any given time. The current buffer receives all input--whatever you type and any commands you invoke. Buffers are also used to represent interactions with programs such as Common Lisp. Thus, one common action you'll take is to "switch buffers," which means to make a different buffer the current buffer so you can edit a particular file or interact with a particular program. The command switch-to-buffer, bound to the key combination C-x b, prompts for the name of a buffer in the area at the bottom of the Emacs frame. When entering a buffer name, hitting Tab will complete the name based on the characters typed so far or will show a list of possible completions. The prompt also suggests a default buffer, which you can accept just by hitting Return. You can also switch buffers by selecting a buffer from the Buffers menu.

In certain contexts, other key combinations may be available for switching to certain buffers. For instance, when editing Lisp source files, the key combo C-c C-z switches to the buffer where you interact with Lisp.

@node	2-3, 2-4, 2-2, Chapter 2
@section Free Your Mind: Interactive Programming

When you start Lisp in a Box, you should see a buffer containing a prompt that looks like this:

CL-USER>
This is the Lisp prompt. Like a Unix or DOS shell prompt, the Lisp prompt is a place where you can type expressions that will cause things to happen. However, instead of reading and interpreting a line of shell commands, Lisp reads Lisp expressions, evaluates them according to the rules of Lisp, and prints the result. Then it does it again with the next expression you type. That endless cycle of reading, evaluating, and printing is why it's called the read-eval-print loop, or REPL for short. It's also referred to as the top-level, the top-level listener, or the Lisp listener.

From within the environment provided by the REPL, you can define and redefine program elements such as variables, functions, classes, and methods; evaluate any Lisp expression; load files containing Lisp source code or compiled code; compile whole files or individual functions; enter the debugger; step through code; and inspect the state of individual Lisp objects.

All those facilities are built into the language, accessible via functions defined in the language standard. If you had to, you could build a pretty reasonable programming environment out of just the REPL and any text editor that knows how to properly indent Lisp code. But for the true Lisp programming experience, you need an environment, such as SLIME, that lets you interact with Lisp both via the REPL and while editing source files. For instance, you don't want to have to cut and paste a function definition from a source file to the REPL or have to load a whole file just because you changed one function; your Lisp environment should let us evaluate or compile both individual expressions and whole files directly from your editor.

@node	2-4,  2-5, 2-3, Chapter 2
@section Experimenting in the REPL

To try the REPL, you need a Lisp expression that can be read, evaluated, and printed. One of the simplest kinds of Lisp expressions is a number. At the Lisp prompt, you can type 10 followed by Return and should see something like this:

CL-USER> 10
10
The first 10 is the one you typed. The Lisp reader, the R in REPL, reads the text "10" and creates a Lisp object representing the number 10. This object is a self-evaluating object, which means that when given to the evaluator, the E in REPL, it evaluates to itself. This value is then given to the printer, which prints the 10 on the line by itself. While that may seem like a lot of work just to get back to where you started, things get a bit more interesting when you give Lisp something meatier to chew on. For instance, you can type (+ 2 3) at the Lisp prompt.

CL-USER> (+ 2 3)
5
Anything in parentheses is a list, in this case a list of three elements, the symbol +, and the numbers 2 and 3. Lisp, in general, evaluates lists by treating the first element as the name of a function and the rest of the elements as expressions to be evaluated to yield the arguments to the function. In this case, the symbol + names a function that performs addition. 2 and 3 evaluate to themselves and are then passed to the addition function, which returns 5. The value 5 is passed to the printer, which prints it. Lisp can evaluate a list expression in other ways, but we needn't get into them right away. First we have to write. . .

@node	2-5,  2-6, 2-4, Chapter 2
@section "Hello, World," Lisp Style

No programming book is complete without a "hello, world"7 program. As it turns out, it's trivially easy to get the REPL to print "hello, world."

CL-USER> "hello, world"
"hello, world"
This works because strings, like numbers, have a literal syntax that's understood by the Lisp reader and are self-evaluating objects: Lisp reads the double-quoted string and instantiates a string object in memory that, when evaluated, evaluates to itself and is then printed in the same literal syntax. The quotation marks aren't part of the string object in memory--they're just the syntax that tells the reader to read a string. The printer puts them back on when it prints the string because it tries to print objects in the same syntax the reader understands.

However, this may not really qualify as a "hello, world" program. It's more like the "hello, world" value.

You can take a step toward a real program by writing some code that as a side effect prints the string "hello, world" to standard output. Common Lisp provides a couple ways to emit output, but the most flexible is the FORMAT function. FORMAT takes a variable number of arguments, but the only two required arguments are the place to send the output and a string. You'll see in the next chapter how the string can contain embedded directives that allow you to interpolate subsequent arguments into the string, à la printf or Python's string-%. As long as the string doesn't contain an ~, it will be emitted as-is. If you pass t as its first argument, it sends its output to standard output. So a FORMAT expression that will print "hello, world" looks like this:8

CL-USER> (format t "hello, world")
hello, world
NIL
One thing to note about the result of the FORMAT expression is the NIL on the line after the "hello, world" output. That NIL is the result of evaluating the FORMAT expression, printed by the REPL. (NIL is Lisp's version of false and/or null. More on that in Chapter 4.) Unlike the other expressions we've seen so far, a FORMAT expression is more interesting for its side effect--printing to standard output in this case--than for its return value. But every expression in Lisp evaluates to some result.9

However, it's still arguable whether you've yet written a true "program." But you're getting there. And you're seeing the bottom-up style of programming supported by the REPL: you can experiment with different approaches and build a solution from parts you've already tested. Now that you have a simple expression that does what you want, you just need to package it in a function. Functions are one of the basic program building blocks in Lisp and can be defined with a DEFUN expression such as this:

CL-USER> (defun hello-world () (format t "hello, world"))
HELLO-WORLD
The hello-world after the DEFUN is the name of the function. In Chapter 4 we'll look at exactly what characters can be used in a name, but for now suffice it to say that lots of characters, such as -, that are illegal in names in other languages are legal in Common Lisp. It's standard Lisp style--not to mention more in line with normal English typography--to form compound names with hyphens, such as hello-world, rather than with underscores, as in hello_world, or with inner caps such as helloWorld. The ()s after the name delimit the parameter list, which is empty in this case because the function takes no arguments. The rest is the body of the function.

At one level, this expression, like all the others you've seen, is just another expression to be read, evaluated, and printed by the REPL. The return value in this case is the name of the function you just defined.10 But like the FORMAT expression, this expression is more interesting for the side effects it has than for its return value. Unlike the FORMAT expression, however, the side effects are invisible: when this expression is evaluated, a new function that takes no arguments and with the body (format t "hello, world") is created and given the name HELLO-WORLD.

Once you've defined the function, you can call it like this:

CL-USER> (hello-world)
hello, world
NIL
You can see that the output is just the same as when you evaluated the FORMAT expression directly, including the NIL value printed by the REPL. Functions in Common Lisp automatically return the value of the last expression evaluated.

@node	2-6,  Chapter 3, 2-5, Chapter 2
@section Saving Your Work

You could argue that this is a complete "hello, world" program of sorts. However, it still has a problem. If you exit Lisp and restart, the function definition will be gone. Having written such a fine function, you'll want to save your work.

Easy enough. You just need to create a file in which to save the definition. In Emacs you can create a new file by typing C-x C-f and then, when Emacs prompts you, entering the name of the file you want to create. It doesn't matter particularly where you put the file. It's customary to name Common Lisp source files with a .lisp extension, though some folks use .cl instead.

Once you've created the file, you can type the definition you previously entered at the REPL. Some things to note are that after you type the opening parenthesis and the word DEFUN, at the bottom of the Emacs window, SLIME will tell you the arguments expected. The exact form will depend somewhat on what Common Lisp implementation you're using, but it'll probably look something like this:

(defun name varlist &rest body)
The message will disappear as you start to type each new element but will reappear each time you enter a space. When you're entering the definition in the file, you might choose to break the definition across two lines after the parameter list. If you hit Return and then Tab, SLIME will automatically indent the second line appropriately, like this:11

(defun hello-world ()
  (format t "hello, world"))
SLIME will also help match up the parentheses--as you type a closing parenthesis, it will flash the corresponding opening parenthesis. Or you can just type C-c C-q to invoke the command slime-close-parens-at-point, which will insert as many closing parentheses as necessary to match all the currently open parentheses.

Now you can get this definition into your Lisp environment in several ways. The easiest is to type C-c C-c with the cursor anywhere in or immediately after the DEFUN form, which runs the command slime-compile-defun, which in turn sends the definition to Lisp to be evaluated and compiled. To make sure this is working, you can make some change to hello-world, recompile it, and then go back to the REPL, using C-c C-z or C-x b, and call it again. For instance, you could make it a bit more grammatical.

(defun hello-world ()
  (format t "Hello, world!"))
Next, recompile with C-c C-c and then type C-c C-z to switch to the REPL to try the new version.

CL-USER> (hello-world)
Hello, world!
NIL
You'll also probably want to save the file you've been working on; in the hello.lisp buffer, type C-x C-s to invoke the Emacs command save-buffer.

Now to try reloading this function from the source file, you'll need to quit Lisp and restart. To quit you can use a SLIME shortcut: at the REPL, type a comma. At the bottom of the Emacs window, you will be prompted for a command. Type quit (or sayoonara), and then hit Enter. This will quit Lisp and close all the buffers created by SLIME such as the REPL buffer.12 Now restart SLIME by typing M-x slime.

Just for grins, you can try to invoke hello-world.

CL-USER> (hello-world)
At that point SLIME will pop up a new buffer that starts with something that looks like this:

attempt to call `HELLO-WORLD' which is an undefined function.
   [Condition of type UNDEFINED-FUNCTION]

Restarts:
  0: [TRY-AGAIN] Try calling HELLO-WORLD again.
  1: [RETURN-VALUE] Return a value instead of calling HELLO-WORLD.
  2: [USE-VALUE] Try calling a function other than HELLO-WORLD.
  3: [STORE-VALUE] Setf the symbol-function of HELLO-WORLD and call it again.
  4: [ABORT] Abort handling SLIME request.
  5: [ABORT] Abort entirely from this process.

Backtrace:
  0: (SWANK::DEBUG-IN-EMACS #<UNDEFINED-FUNCTION @ #x716b082a>)
  1: ((FLET SWANK:SWANK-DEBUGGER-HOOK SWANK::DEBUG-IT))
  2: (SWANK:SWANK-DEBUGGER-HOOK #<UNDEFINED-FUNCTION @ #x716b082a> #<Function SWANK-DEBUGGER-HOOK>)
  3: (ERROR #<UNDEFINED-FUNCTION @ #x716b082a>)
  4: (EVAL (HELLO-WORLD))
  5: (SWANK::EVAL-REGION "(hello-world)
" T)
Blammo! What happened? Well, you tried to invoke a function that doesn't exist. But despite the burst of output, Lisp is actually handling this situation gracefully. Unlike Java or Python, Common Lisp doesn't just bail--throwing an exception and unwinding the stack. And it definitely doesn't dump core just because you tried to invoke a missing function. Instead Lisp drops you into the debugger.

While you're in the debugger you still have full access to Lisp, so you can evaluate expressions to examine the state of our program and maybe even fix things. For now don't worry about that; just type q to exit the debugger and get back to the REPL. The debugger buffer will go away, and the REPL will show this:

CL-USER> (hello-world)
; Evaluation aborted
CL-USER>
There's obviously more that can be done from within the debugger than just abort--we'll see, for instance, in Chapter 19 how the debugger integrates with the error handling system. For now, however, the important thing to know is that you can always get out of it, and back to the REPL, by typing q.

Back at the REPL you can try again. Things blew up because Lisp didn't know the definition of hello-world. So you need to let Lisp know about the definition we saved in the file hello.lisp. You have several ways you could do this. You could switch back to the buffer containing the file (type C-x b and then enter hello.lisp when prompted) and recompile the definition as you did before with C-c C-c. Or you can load the whole file, which would be a more convenient approach if the file contained a bunch of definitions, using the LOAD function at the REPL like this:

CL-USER> (load "hello.lisp")
; Loading /home/peter/my-lisp-programs/hello.lisp
T
The T means everything loaded correctly.13 Loading a file with LOAD is essentially equivalent to typing each of the expressions in the file at the REPL in the order they appear in the file, so after the call to LOAD, hello-world should be defined:

CL-USER> (hello-world)
Hello, world!
NIL
Another way to load a file's worth of definitions is to compile the file first with COMPILE-FILE and then LOAD the resulting compiled file, called a FASL file, which is short for fast-load file. COMPILE-FILE returns the name of the FASL file, so we can compile and load from the REPL like this:

CL-USER> (load (compile-file "hello.lisp"))
;;; Compiling file hello.lisp
;;; Writing fasl file hello.fasl
;;; Fasl write complete
v; Fast loading /home/peter/my-lisp-programs/hello.fasl
T
SLIME also provides support for loading and compiling files without using the REPL. When you're in a source code buffer, you can use C-c C-l to load the file with slime-load-file. Emacs will prompt for the name of a file to load with the name of the current file already filled in; you can just hit Enter. Or you can type C-c C-k to compile and load the file represented by the current buffer. In some Common Lisp implementations, compiling code this way will make it quite a bit faster; in others, it won't, typically because they always compile everything.

This should be enough to give you a flavor of how Lisp programming works. Of course I haven't covered all the tricks and techniques yet, but you've seen the essential elements--interacting with the REPL trying things out, loading and testing new code, tweaking and debugging. Serious Lisp hackers often keep a Lisp image running for days on end, adding, redefining, and testing bits of their program incrementally.

Also, even when the Lisp app is deployed, there's often still a way to get to a REPL. You'll see in Chapter 26 how you can use the REPL and SLIME to interact with the Lisp that's running a Web server at the same time as it's serving up Web pages. It's even possible to use SLIME to connect to a Lisp running on a different machine, allowing you--for instance--to debug a remote server just like a local one.

An even more impressive instance of remote debugging occurred on NASA's 1998 Deep Space 1 mission. A half year after the space craft launched, a bit of Lisp code was going to control the spacecraft for two days while conducting a sequence of experiments. Unfortunately, a subtle race condition in the code had escaped detection during ground testing and was already in space. When the bug manifested in the wild--100 million miles away from Earth--the team was able to diagnose and fix the running code, allowing the experiments to complete.14 One of the programmers described it as follows:

Debugging a program running on a $100M piece of hardware that is 100 million miles away is an interesting experience. Having a read-eval-print loop running on the spacecraft proved invaluable in finding and fixing the problem.
You're not quite ready to send any Lisp code into deep space, but in the next chapter you'll take a crack at writing a program a bit more interesting than "hello, world."

@node    Chapter 3, Chapter 4, Chapter 2, Top
@section 3. Practical: A Simple Database

content 3-intro

@menu
* 3-1::              CDs and Records
* 3-2::              Filing CDs
* 3-3::              Looking at the Database Contents
* 3-4::              Improving the User Interaction
* 3-5::              Saving and Loading the Database
* 3-6::              Querying the Database
* 3-7::              Updating Existing Records--Another Use for WHERE
* 3-8::              Removing Duplication and Winning Big
* 3-9::              Wrapping Up
@end menu

@node	3-1, 3-2, Chapter 3, Chapter 3
@section CDs and Records

content 3-1

@node	3-2, 3-3, 3-1, Chapter 3
@section Filing CDs

content 3-2

@node	3-3, 3-4, 3-2, Chapter 3
@section Looking at the Database Contents

content 3-3

@node	3-4, 3-5, 3-3, Chapter 3
@section Improving the User Interaction

content 3-4

@node	3-5, 3-6, 3-4, Chapter 3
@section Saving and Loading the Database

content 3-5

@node	3-6, 3-7, 3-5, Chapter 3
@section Querying the Database

content 3-6

@node	3-7, 3-8, 3-6, Chapter 3
@section Updating Existing Records--Another Use for WHERE

content 3-7

@node	3-8, 3-9, 3-7, Chapter 3
@section Removing Duplication and Winning Big

content 3-8

@node	3-9, Chapter 4, 3-7, Chapter 3
@section Wrapping Up

content 3-9

@node    Chapter 4, Chapter 5, Chapter 3, Top
@section 4. Syntax and Semantics

content 4-intro

@menu
* 4-1::              What's with All the Parentheses?
* 4-2::              Breaking Open the Black Box
* 4-3::              S-expressions
* 4-4::              S-expressions As Lisp Forms
* 4-5::              Function Calls
* 4-6::              Special Operators
* 4-7::              Macros
* 4-8::              Truth, Falsehood, and Equality
* 4-9::             Formatting Lisp Code
@end menu

@node	4-1, 4-2, Chapter 4, Chapter 4
@section What's with All the Parentheses?

content 4-1

@node	4-2, 4-3, 4-1, Chapter 4
@section Breaking Open the Black Box

content 4-2

@node	4-3, 4-4, 4-2, Chapter 4
@section S-expressions

content 4-3

@node	4-4, 4-5, 4-3, Chapter 4
@section S-expressions As Lisp Forms

content 4-4

@node	4-5, 4-6, 4-4, Chapter 4
@section Function Calls

content 4-5

@node	4-6, 4-7, 4-5, Chapter 4
@section Special Operators

content 4-6

@node	4-7, 4-8, 4-6, Chapter 4
@section Macros

content 4-7

@node	4-8, 4-9, 4-7, Chapter 4
@section Truth, Falsehood, and Equality

content 4-8

@node	4-9, Chapter 5, 4-7, Chapter 4
@section Formatting Lisp Code

content 4-9

@node    Chapter 5, Chapter 6, Chapter 4, Top
@section 5. Functions

content 5-intro

@menu
* 5-1::              Defining New Functions
* 5-2::              Function Parameter Lists
* 5-3::              Optional Parameters
* 5-4::              Rest Parameters
* 5-5::              Keyword Parameters
* 5-6::              Mixing Different Parameter Types
* 5-7::              Function Return Values
* 5-8::              Functions As Data, a.k.a. Higher-Order Functions
* 5-9::              Anonymous Functions
@end menu

@node	5-1, 5-2, Chapter 5, Chapter 5
@section Defining New Functions

content 5-1

@node	5-2, 5-3, 5-1, Chapter 5
@section Function Parameter Lists

content 5-2

@node	5-3, 5-4, 5-2, Chapter 5
@section Optional Parameters

content 5-3

@node	5-4, 5-5, 5-3, Chapter 5
@section Rest Parameters

content 5-4

@node	5-5, 5-6, 5-4, Chapter 5
@section Keyword Parameters

content 5-5

@node	5-6, 5-7, 5-5, Chapter 5
@section Mixing Different Parameter Types

content 5-6

@node	5-7, 5-8, 5-6, Chapter 5
@section Function Return Values

content 5-7

@node	5-8, 5-9, 5-7, Chapter 5
@section Functions As Data, a.k.a. Higher-Order Functions

content 5-8

@node	5-9, Chapter 6, 5-7, Chapter 5
@section Anonymous Functions

content 5-9

@node    Chapter 6, Chapter 7, Chapter 5, Top
@section 6. Variables

content 6-intro

@menu
* 6-1::              Variable Basics
* 6-2::              Lexical Variables and Closures
* 6-3::              Dynamic, a.k.a. Special, Variables
* 6-4::              Constants
* 6-5::              Assignment
* 6-6::              Generalized Assignment
@end menu

@node	6-1, 6-2, Chapter 6, Chapter 6
@section Variable Basics

content 6-1

@node	6-2, 6-3, 6-1, Chapter 6
@section Lexical Variables and Closures

content 6-2

@node	6-3, 6-4, 6-2, Chapter 6
@section Dynamic, a.k.a. Special, Variables

content 6-3

@node	6-4, 6-5, 6-3, Chapter 6
@section Constants

content 6-4

@node	6-5, 6-6, 6-4, Chapter 6
@section Assignment

content 6-5

@node	6-6, Chapter 7, 6-5, Chapter 6
@section Generalized Assignment

content 6-6

@node    Chapter 7, Chapter 8, Chapter 6, Top
@section 7. Macros: Standard Control Constructs

content 7-intro

@menu
* 7-1::              WHEN and UNLESS
* 7-2::              COND
* 7-3::              AND, OR, and NOT
* 7-4::              Looping
* 7-5::              DOLIST and DOTIMES
* 7-6::              DO
* 7-7::              The Mighty LOOP
@end menu

@node	7-1, 7-2, Chapter 7, Chapter 7
@section WHEN and UNLESS

content 7-1

@node	7-2, 7-3, 7-1, Chapter 7
@section COND

content 7-2

@node	7-3, 7-4, 7-2, Chapter 7
@section AND, OR, and NOT

content 7-3

@node	7-4, 7-5, 7-3, Chapter 7
@section Looping

content 7-4

@node	7-5, 7-6, 7-4, Chapter 7
@section DOLIST and DOTIMES

content 7-5

@node	7-6, 7-7, 7-5, Chapter 7
@section DO

content 7-6

@node	7-7, Chapter 8, 7-6, Chapter 7
@section The Mighty LOOP

content 7-7

@node    Chapter 8, Chapter 9, Chapter 7, Top
@section 8. Macros: Defining Your Own

content 8-intro

@menu
* 8-1::                  The Story of Mac: A Just-So Story
* 8-2::                  Macro Expansion Time vs. Runtime
* 8-3::                  DEF MACRO
* 8-4::                  A Sample Macro: do-primes
* 8-5::                  Macro Parameters
* 8-6::                  Generating the Expansion
* 8-7::                  Plugging the Leaks
* 8-8::                  Macro-Writing Macros
* 8-9::                  Beyond Simple Macros
@end menu

@node	8-1, 8-2, Chapter 8, Chapter 8
@section The Story of Mac: A Just-So Story

content 8-1

@node	8-2, 8-3, 8-1, Chapter 8
@section Macro Expansion Time vs. Runtime

content 8-2

@node	8-3, 8-4, 8-2, Chapter 8
@section DEF MACRO

content 8-3

@node	8-4, 8-5, 8-3, Chapter 8
@section A Sample Macro: do-primes

content 8-4

@node	8-5, 8-6, 8-4, Chapter 8
@section Macro Parameters

content 8-5

@node	8-6, 8-7, 8-5, Chapter 8
@section Generating the Expansion

content 8-6

@node	8-7, 8-8, 8-6, Chapter 8
@section Plugging the Leaks

content 8-7

@node	8-8, 8-9, 8-7, Chapter 8
@section Macro-Writing Macros

content 8-8

@node	8-9, Chapter 9, 8-8, Chapter 8
@section Beyond Simple Macros

content 8-9

@node    Chapter 9, Chapter 10, Chapter 8, Top
@section 9. Practical: Building a Unit Test Framework

content 9-intro

@menu
* 9-1::                  Two First Tries
* 9-2::                  Refactoring
* 9-3::                  Fixing the Return Value
* 9-4::                  Better Result Reporting
* 9-5::                  An Abstraction Emerges
* 9-6::                  A Hierarchy of Tests
* 9-7::                  Wrapping Up
@end menu

@node	9-1, 9-2, Chapter 9, Chapter 9
@section Two First Tries

content 9-1

@node	9-2, 9-3, 9-1, Chapter 9
@section Refactoring

content 9-2

@node	9-3, 9-4, 9-2, Chapter 9
@section Fixing the Return Value

content 9-3

@node	9-4, 9-5, 9-3, Chapter 9
@section Better Result Reporting

content 9-4

@node	9-5, 9-6, 9-4, Chapter 9
@section An Abstraction Emerges

content 9-5

@node	9-6, 9-7, 9-5, Chapter 9
@section A Hierarchy of Tests

content 9-6

@node	9-7, Chapter 10, 9-6, Chapter 9
@section Wrapping Up

content 9-7

@node    Chapter 10, Chapter 11, Chapter 9, Top
@section 10. Numbers, Characters, and Strings

content 10-intro

@menu
* 10-1::                 Numbers
* 10-2::                 Numeric Literals
* 10-3::                 Basic Math
* 10-4::                 Numeric Comparisons
* 10-5::                 Higher Math
* 10-6::                 Characters
* 10-7::                 Character Comparisons
* 10-8::                 Strings
* 10-9::                 String Comparisons
@end menu

@node	10-1, 10-2, Chapter 10, Chapter 10
@section Numbers

content 10-1

@node	10-2, 10-3, 10-1, Chapter 10
@section Numeric Literals

content 10-2

@node	10-3, 10-4, 10-2, Chapter 10
@section Basic Math

content 10-3

@node	10-4, 10-5, 10-3, Chapter 10
@section Numeric Comparisons

content 10-4

@node	10-5, 10-6, 10-4, Chapter 10
@section Higher Math

content 10-5

@node	10-6, 10-7, 10-5, Chapter 10
@section Characters

content 10-6

@node	10-7, 10-8, 10-6, Chapter 10
@section Character Comparisons

content 10-7

@node	10-8, 10-9, 10-7, Chapter 10
@section Strings

content 10-8

@node	10-9, Chapter 11, 10-8, Chapter 10
@section String Comparisons

content 10-9

@node    Chapter 11, Chapter 12, Chapter 10, Top
@section 11. Collections

content 11-intro

@menu
* 11-1::                            Vectors
* 11-2::                            Subtypes of Vector
* 11-3::                            Vectors As Sequences
* 11-4::                            Sequence Iterating Functions
* 11-5::                            Higher-Order Function Variants
* 11-6::                            Whole Sequence Manipulations
* 11-7::                            Sorting and Merging
* 11-8::                            Subsequence Manipulations
* 11-9::                            Sequence Predicates
* 11-10::                           Sequence Mapping Functions
* 11-11::                           Hash Tables
* 11-12::                           Hash Table Iteration
@end menu

@node	11-1, 11-2, Chapter 11, Chapter 11
@section Vectors

content 11-1

@node	11-2, 11-3, 11-1, Chapter 11
@section Subtypes of Vector

content 11-2

@node	11-3, 11-4, 11-2, Chapter 11
@section Vectors As Sequences

content 11-3

@node	11-4, 11-5, 11-3, Chapter 11
@section Sequence Iterating Functions

content 11-4

@node	11-5, 11-6, 11-4, Chapter 11
@section Higher-Order Function Variants

content 11-5

@node	11-6, 11-7, 11-5, Chapter 11
@section Whole Sequence Manipulations

content 11-6

@node	11-7, 11-8, 11-6, Chapter 11
@section Sorting and Merging

content 11-7

@node	11-8, 11-9, 11-7, Chapter 11
@section Subsequence Manipulations

content 11-8

@node	11-9, 11-10, 11-8, Chapter 11
@section Sequence Predicates

content 11-9

@node	11-10, 11-11, 11-9, Chapter 11
@section Sequence Mapping Functions

content 11-10

@node	11-11, 11-12, 11-10, Chapter 11
@section Hash Tables

content 11-11

@node	11-12, Chapter 12, 11-11, Chapter 11
@section Hash Table Iteration

content 11-12

@node    Chapter 12, Chapter 13, Chapter 11, Top
@section 12. They Called It LISP for a Reason: List Processing

content 12-intro

@menu
* 12-1::             "There Is No List"
* 12-2::             Functional Programming and Lists
* 12-3::             "Destructive" Operations
* 12-4::             Combining Recycling with Shared Structure
* 12-5::             List-Manipulation Functions
* 12-6::             Mapping
* 12-7::             Other Structures
@end menu

@node	12-1, 12-2, Chapter 12, Chapter 12
@section "There Is No List"

content 12-1

@node	12-2, 12-3, 12-1, Chapter 12
@section Functional Programming and Lists

content 12-2

@node	12-3, 12-4, 12-2, Chapter 12
@section "Destructive" Operations

content 12-3

@node	12-4, 12-5, 12-3, Chapter 12
@section Combining Recycling with Shared Structure

content 12-4

@node	12-5, 12-6, 12-4, Chapter 12
@section List-Manipulation Functions

content 12-5

@node	12-6, 12-7, 12-5, Chapter 12
@section Mapping

content 12-6

@node	12-7, Chapter 13, 12-6, Chapter 12
@section Other Structures

content 12-7

@node    Chapter 13, Chapter 14, Chapter 12, Top
@section 13. Beyond Lists: Other Uses for Cons Cells

content 13-intro

@menu
* 13-1::                Trees
* 13-2::                Sets
* 13-3::                Lookup Tables: Alists and Plists
* 13-4::                DESTRUCTURING-BIND
@end menu

@node	13-1, 13-2, Chapter 13, Chapter 13
@section Trees

content 13-1

@node	13-2, 13-3, 13-1, Chapter 13
@section Sets

content 13-2

@node	13-3, 13-4, 13-2, Chapter 13
@section Lookup Tables: Alists and Plists

content 13-3

@node	13-4, Chapter 14, 13-3, Chapter 13
@section DESTRUCTURING-BIND

content 13-4

@node    Chapter 14, Chapter 15, Chapter 13, Top
@section 14. Files and File I/O

content 14-intro

@menu
* 14-1::      Reading File Data
* 14-2::      Reading Binary Data
* 14-3::      Bulk Reads
* 14-4::      File Output
* 14-5::      Closing Files
* 14-6::      Filenames
* 14-7::      How Pathnames Represent Filenames
* 14-8::      Constructing New Pathnames
* 14-9::      Two Representations of Directory Names
* 14-10::     Interacting with the File System
* 14-11::     Other Kinds of I/O
@end menu

@node	14-1, 14-2, Chapter 14, Chapter 14
@section Reading File Data

content 14-1

@node	14-2, 14-3, 14-1, Chapter 14
@section Reading Binary Data

content 14-2

@node	14-3, 14-4, 14-2, Chapter 14
@section Bulk Reads

content 14-3

@node	14-4, 14-5, 14-3, Chapter 14
@section File Output

content 14-4

@node	14-5, 14-6, 14-4, Chapter 14
@section Closing Files

content 14-5

@node	14-6, 14-7, 14-5, Chapter 14
@section Filenames

content 14-6

@node	14-7, 14-8, 14-6, Chapter 14
@section How Pathnames Represent Filenames

content 14-7

@node	14-8, 14-9, 14-7, Chapter 14
@section Constructing New Pathnames

content 14-8

@node	14-9, 14-10, 14-8, Chapter 14
@section Two Representations of Directory Names

content 14-9

@node	14-10, 14-11, 14-9, Chapter 14
@section Interacting with the File System

content 14-10

@node	14-11, Chapter 15, 14-10, Chapter 14
@section Other Kinds of I/O

content 14-11

@node    Chapter 15, Chapter 16, Chapter 14, Top
@section 15. Practical: A Portable Pathname Library

content 15-intro

@menu
* 15-1::       The API
* 15-2::       *FEATURES* and Read-Time Conditionalization
* 15-3::       Listing a Directory
* 15-4::       Testing a File's Existence
* 15-5::       Walking a Directory Tree
@end menu

@node	15-1, 15-2, Chapter 15, Chapter 15
@section The API

content 15-1

@node	15-2, 15-3, 15-1, Chapter 15
@section *FEATURES* and Read-Time Conditionalization

content 15-2

@node	15-3, 15-4, 15-2, Chapter 15
@section Listing a Directory

content 15-3

@node	15-4, 15-5, 15-3, Chapter 15
@section Testing a File's Existence

content 15-4

@node	15-5, Chapter 16, 15-4, Chapter 15
@section Walking a Directory Tree

content 15-5

@node    Chapter 16, Chapter 17, Chapter 15, Top
@section 16. Object Reorientation: Generic Functions

content 16-intro

@menu
* 16-1::   Generic Functions and Classes
* 16-2::   Generic Functions and Methods
* 16-3::   DEFGENERIC
* 16-4::   DEFMETHOD
* 16-5::   Method Combination
* 16-6::   The Standard Method Combination
* 16-7::   Other Method Combinations
* 16-8::   Multimethods
* 16-9::   To Be Continued . . .
@end menu

@node	16-1, 16-2, Chapter 16, Chapter 16
@section Generic Functions and Classes

content 16-1

@node	16-2, 16-3, 16-1, Chapter 16
@section Generic Functions and Methods

content 16-2

@node	16-3, 16-4, 16-2, Chapter 16
@section DEFGENERIC

content 16-3

@node	16-4, 16-5, 16-3, Chapter 16
@section DEFMETHOD

content 16-4

@node	16-5, 16-6, 16-4, Chapter 16
@section Method Combination

content 16-5

@node	16-6, 16-7, 16-5, Chapter 16
@section The Standard Method Combination

content 16-6

@node	16-7, 16-8, 16-6, Chapter 16
@section Other Method Combinations

content 16-7

@node	16-8, 16-9, 16-7, Chapter 16
@section Multimethods

content 16-8

@node	16-9, Chapter 17, 16-8, Chapter 16
@section To Be Continued . . .

content 16-9

@node    Chapter 17, Chapter 18, Chapter 16, Top
@section 17. Object Reorientation: Classes

content 17-intro

@menu
* 17-1::   DEFCLASS
* 17-2::   Slot Specifiers
* 17-3::   Object Initialization
* 17-4::   Accessor Functions
* 17-5::   WITH-SLOTS and WITH-ACCESSORS
* 17-6::   Class-Allocated Slots
* 17-7::   Slots and Inheritance
* 17-8::   Multiple Inheritance
* 17-9::   Good Object-Oriented Design
@end menu

@node	17-1, 17-2, Chapter 17, Chapter 17
@section DEFCLASS

content 17-1

@node	17-2, 17-3, 17-1, Chapter 17
@section Slot Specifiers

content 17-2

@node	17-3, 17-4, 17-2, Chapter 17
@section Object Initialization

content 17-3

@node	17-4, 17-5, 17-3, Chapter 17
@section Accessor Functions

content 17-4

@node	17-5, 17-6, 17-4, Chapter 17
@section WITH-SLOTS and WITH-ACCESSORS

content 17-5

@node	17-6, 17-7, 17-5, Chapter 17
@section Class-Allocated Slots

content 17-6

@node	17-7, 17-8, 17-6, Chapter 17
@section Slots and Inheritance

content 17-7

@node	17-8, 17-9, 17-7, Chapter 17
@section Multiple Inheritance

content 17-8

@node	17-9, Chapter 18, 17-8, Chapter 17
@section Good Object-Oriented Design

content 17-9

@node    Chapter 18, Chapter 19, Chapter 17, Top
@section 18. A Few FORMAT Recipes

content 18-intro

@menu
* 18-1::         The FORMAT Function
* 18-2::         FORMAT Directives
* 18-3::         Basic Formatting
* 18-4::         Character and Integer Directives
* 18-5::         Floating-Point Directives
* 18-6::         English-Language Directives
* 18-7::         Conditional Formatting
* 18-8::         Iteration
* 18-9::         Hop, Skip, Jump
* 18-10::        And More . . .
@end menu

@node	18-1, 18-2, Chapter 18, Chapter 18
@section The FORMAT Function

content 18-1

@node	18-2, 18-3, 18-1, Chapter 18
@section FORMAT Directives

content 18-2

@node	18-3, 18-4, 18-2, Chapter 18
@section Basic Formatting

content 18-3

@node	18-4, 18-5, 18-3, Chapter 18
@section Character and Integer Directives

content 18-4

@node	18-5, 18-6, 18-4, Chapter 18
@section Floating-Point Directives

content 18-5

@node	18-6, 18-7, 18-5, Chapter 18
@section English-Language Directives

content 18-6

@node	18-7, 18-8, 18-6, Chapter 18
@section Conditional Formatting

content 18-7

@node	18-8, 18-9, 18-7, Chapter 18
@section Iteration

content 18-8

@node	18-9, 18-10, 18-8, Chapter 18
@section Hop, Skip, Jump

content 18-9

@node	18-10, Chapter 19, 18-9, Chapter 18
@section And More . . .

content 18-10

@node    Chapter 19, Chapter 20, Chapter 18, Top
@section 19. Beyond Exception Handling: Conditions and Restarts

content 19-intro

@menu
* 19-1::             The Lisp Way
* 19-2::             Conditions
* 19-3::             Condition Handlers
* 19-4::             Restarts
* 19-5::             Providing Multiple Restarts
* 19-6::             Other Uses for Conditions
@end menu

@node	19-1, 19-2, Chapter 19, Chapter 19
@section The Lisp Way

content 19-1

@node	19-2, 19-3, 19-1, Chapter 19
@section Conditions

content 19-2

@node	19-3, 19-4, 19-2, Chapter 19
@section Condition Handlers

content 19-3

@node	19-4, 19-5, 19-3, Chapter 19
@section Restarts

content 19-4

@node	19-5, 19-6, 19-4, Chapter 19
@section Providing Multiple Restarts

content 19-5

@node	19-6, Chapter 20, 19-5, Chapter 19
@section Other Uses for Conditions

content 19-6

@node    Chapter 20, Chapter 21, Chapter 19, Top
@section 20. The Special Operators

content 20-intro

@menu
* 20-1::        Controlling Evaluation
* 20-2::        Manipulating the Lexical Environment
* 20-3::        Local Flow of Control
* 20-4::        Unwinding the Stack
* 20-5::        Multiple Values
* 20-6::        EVAL-WHEN
* 20-7::        Other Special Operators
@end menu

@node	20-1, 20-2, Chapter 20, Chapter 20
@section Controlling Evaluation

content 20-1

@node	20-2, 20-3, 20-1, Chapter 20
@section Manipulating the Lexical Environment

content 20-2

@node	20-3, 20-4, 20-2, Chapter 20
@section Local Flow of Control

content 20-3

@node	20-4, 20-5, 20-3, Chapter 20
@section Unwinding the Stack

content 20-4

@node	20-5, 20-6, 20-4, Chapter 20
@section Multiple Values

content 20-5

@node	20-6, 20-7, 20-5, Chapter 20
@section EVAL-WHEN

content 20-6

@node	20-7, Chapter 21, 20-6, Chapter 20
@section Other Special Operators

content 20-7

@node    Chapter 21, Chapter 22, Chapter 20, Top
@section 21. Programming in the Large: Packages and Symbols

content 21-intro

@menu
* 21-1::        How the Reader Uses Packages
* 21-2::        A Bit of Package and Symbol Vocabulary
* 21-3::        Three Standard Packages
* 21-4::        Defining Your Own Packages
* 21-5::        Packaging Reusable Libraries
* 21-6::        Importing Individual Names
* 21-7::        Packaging Mechanics
* 21-8::        Package Gotchas
@end menu

@node	21-1, 21-2, Chapter 21, Chapter 21
@section How the Reader Uses Packages

content 21-1

@node	21-2, 21-3, 21-1, Chapter 21
@section A Bit of Package and Symbol Vocabulary

content 21-2

@node	21-3, 21-4, 21-2, Chapter 21
@section Three Standard Packages

content 21-3

@node	21-4, 21-5, 21-3, Chapter 21
@section Defining Your Own Packages

content 21-4

@node	21-5, 21-6, 21-4, Chapter 21
@section Packaging Reusable Libraries

content 21-5

@node	21-6, 21-7, 21-5, Chapter 21
@section Importing Individual Names

content 21-6

@node	21-7, 21-8, 21-6, Chapter 21
@section Packaging Mechanics

content 21-7

@node	21-8, Chapter 22, 21-7, Chapter 21
@section Package Gotchas

content 21-8

@node    Chapter 22, Chapter 23, Chapter 21, Top
@section 22. LOOP for Black Belts

content 22-intro

@menu
* 22-1::     The Parts of a LOOP
* 22-2::     Iteration Control
* 22-3::     Counting Loops
* 22-4::     Looping Over Collections and Packages
* 22-5::     Equals-Then Iteration
* 22-6::     Local Variables
* 22-7::     Destructuring Variables
* 22-8::     Value Accumulation
* 22-9::     Unconditional Execution
* 22-10::    Conditional Execution
* 22-11::    Setting Up and Tearing Down
* 22-12::    Termination Tests
* 22-13::    Putting It All Together
@end menu

@node	22-1, 22-2, Chapter 22, Chapter 22
@section The Parts of a LOOP

content 22-1

@node	22-2, 22-3, 22-1, Chapter 22
@section Iteration Control

content 22-2

@node	22-3, 22-4, 22-2, Chapter 22
@section Counting Loops

content 22-3

@node	22-4, 22-5, 22-3, Chapter 22
@section Looping Over Collections and Packages

content 22-4

@node	22-5, 22-6, 22-4, Chapter 22
@section Equals-Then Iteration

content 22-5

@node	22-6, 22-7, 22-5, Chapter 22
@section Local Variables

content 22-6

@node	22-7, 22-8, 22-6, Chapter 22
@section Destructuring Variables

content 22-7

@node	22-8, 22-9, 22-7, Chapter 22
@section Value Accumulation

content 22-8

@node	22-9, 22-10, 22-8, Chapter 22
@section Unconditional Execution

content 22-9

@node	22-10, 22-11, 22-9, Chapter 22
@section Conditional Execution

content 22-10

@node	22-11, 22-12, 22-10, Chapter 22
@section Setting Up and Tearing Down

content 22-11

@node	22-12, 22-13, 22-11, Chapter 22
@section Termination Tests

content 22-12

@node	22-13, Chapter 23, 22-12, Chapter 22
@section Putting It All Together

content 22-13

@node    Chapter 23, Chapter 24, Chapter 22, Top
@section 23. Practical: A Spam Filter

content 23-intro

@menu
* 23-1::       The Heart of a Spam Filter
* 23-2::       Training the Filter
* 23-3::       Per-Word Statistics
* 23-4::       Combining Probabilities
* 23-5::       Inverse Chi Square
* 23-6::       Training the Filter
* 23-7::       Testing the Filter
* 23-8::       A Couple of Utility Functions
* 23-9::       Analyzing the Results
* 23-10::      What's Next
@end menu

@node	23-1, 23-2, Chapter 23, Chapter 23
@section The Heart of a Spam Filter

content 23-1

@node	23-2, 23-3, 23-1, Chapter 23
@section Training the Filter

content 23-2

@node	23-3, 23-4, 23-2, Chapter 23
@section Per-Word Statistics

content 23-3

@node	23-4, 23-5, 23-3, Chapter 23
@section Combining Probabilities

content 23-4

@node	23-5, 23-6, 23-4, Chapter 23
@section Inverse Chi Square

content 23-5

@node	23-6, 23-7, 23-5, Chapter 23
@section Training the Filter

content 23-6

@node	23-7, 23-8, 23-6, Chapter 23
@section Testing the Filter

content 23-7

@node	23-8, 23-9, 23-7, Chapter 23
@section A Couple of Utility Functions

content 23-8

@node	23-9, 23-10, 23-8, Chapter 23
@section Analyzing the Results

content 23-9

@node	23-10, Chapter 24, 23-9, Chapter 23
@section What's Next

content 23-10

@node    Chapter 24, Chapter 25, Chapter 23, Top
@section 24. Practical: Parsing Binary Files

content 24-intro

@menu
* 24-1::       Binary Files
* 24-2::       Binary Format Basics
* 24-3::       Strings in Binary Files
* 24-4::       Composite Structures
* 24-5::       Designing the Macros
* 24-6::       Making the Dream a Reality
* 24-7::       Reading Binary Objects
* 24-8::       Writing Binary Objects
* 24-9::       Adding Inheritance and Tagged Structures
* 24-10::      Keeping Track of Inherited Slots
* 24-11::      Tagged Structures
* 24-12::      Primitive Binary Types
* 24-13::      The Current Object Stack
@end menu

@node	24-1, 24-2, Chapter 24, Chapter 24
@section Binary Files

content 24-1

@node	24-2, 24-3, 24-1, Chapter 24
@section Binary Format Basics

content 24-2

@node	24-3, 24-4, 24-2, Chapter 24
@section Strings in Binary Files

content 24-3

@node	24-4, 24-5, 24-3, Chapter 24
@section Composite Structures

content 24-4

@node	24-5, 24-6, 24-4, Chapter 24
@section Designing the Macros

content 24-5

@node	24-6, 24-7, 24-5, Chapter 24
@section Making the Dream a Reality

content 24-6

@node	24-7, 24-8, 24-6, Chapter 24
@section Reading Binary Objects

content 24-7

@node	24-8, 24-9, 24-7, Chapter 24
@section Writing Binary Objects

content 24-8

@node	24-9, 24-10, 24-8, Chapter 24
@section Adding Inheritance and Tagged Structures

content 24-9

@node	24-10, 24-11, 24-9, Chapter 24
@section Keeping Track of Inherited Slots

content 24-10

@node	24-11, 24-12, 24-10, Chapter 24
@section Tagged Structures

content 24-11

@node	24-12, 24-13, 24-11, Chapter 24
@section Primitive Binary Types

content 24-12

@node	24-13, Chapter 25, 24-12, Chapter 24
@section The Current Object Stack

content 24-13

@node    Chapter 25, Chapter 26, Chapter 24, Top
@section 25. Practical: An ID3 Parser

content 25-intro

@menu
* 25-1::       Structure of an ID3v2 Tag
* 25-2::       Defining a Package
* 25-3::       Integer Types
* 25-4::       String Types
* 25-5::       ID3 Tag Header
* 25-6::       ID3 Frames
* 25-7::       Detecting Tag Padding
* 25-8::       Supporting Multiple Versions of ID3
* 25-9::       Versioned Frame Base Classes
* 25-10::      Versioned Concrete Frame Classes
* 25-11::      What Frames Do You Actually Need?
* 25-12::      Text Information Frames
* 25-13::      Comment Frames
* 25-14::      Extracting Information from an ID3 Tag
@end menu

@node	25-1, 25-2, Chapter 25, Chapter 25
@section Structure of an ID3v2 Tag

content 25-1

@node	25-2, 25-3, 25-1, Chapter 25
@section Defining a Package

content 25-2

@node	25-3, 25-4, 25-2, Chapter 25
@section Integer Types

content 25-3

@node	25-4, 25-5, 25-3, Chapter 25
@section String Types

content 25-4

@node	25-5, 25-6, 25-4, Chapter 25
@section ID3 Tag Header

content 25-5

@node	25-6, 25-7, 25-5, Chapter 25
@section ID3 Frames

content 25-6

@node	25-7, 25-8, 25-6, Chapter 25
@section Detecting Tag Padding

content 25-7

@node	25-8, 25-9, 25-7, Chapter 25
@section Supporting Multiple Versions of ID3

content 25-8

@node	25-9, 25-10, 25-8, Chapter 25
@section Versioned Frame Base Classes

content 25-9

@node	25-10, 25-11, 25-9, Chapter 25
@section Versioned Concrete Frame Classes

content 25-10

@node	25-11, 25-12, 25-10, Chapter 25
@section What Frames Do You Actually Need?

content 25-11

@node	25-12, 25-13, 25-11, Chapter 25
@section Text Information Frames

content 25-12

@node	25-13, 25-14, 25-12, Chapter 25
@section Comment Frames

content 25-13

@node	25-14, Chapter 26, 25-13, Chapter 25
@section Extracting Information from an ID3 Tag

content 25-14

@node    Chapter 26, Chapter 27, Chapter 25, Top
@section 26. Practical: Web Programming with AllegroServe

content 26-intro

@menu
* 26-1::       A 30-Second Intro to Server-Side Web Programming
* 26-2::       AllegroServe
* 26-3::       Generating Dynamic Content with AllegroServe
* 26-4::       Generating HTML
* 26-5::       HTML Macros
* 26-6::       Query Parameters
* 26-7::       Cookies
* 26-8::       A Small Application Framework
* 26-9::       The Implementation
@end menu

@node	26-1, 26-2, Chapter 26, Chapter 26
@section A 30-Second Intro to Server-Side Web Programming

content 26-1

@node	26-2, 26-3, 26-1, Chapter 26
@section AllegroServe

content 26-2

@node	26-3, 26-4, 26-2, Chapter 26
@section Generating Dynamic Content with AllegroServe

content 26-3

@node	26-4, 26-5, 26-3, Chapter 26
@section Generating HTML

content 26-4

@node	26-5, 26-6, 26-4, Chapter 26
@section HTML Macros

content 26-5

@node	26-6, 26-7, 26-5, Chapter 26
@section Query Parameters

content 26-6

@node	26-7, 26-8, 26-6, Chapter 26
@section Cookies

content 26-7

@node	26-8, 26-9, 26-7, Chapter 26
@section A Small Application Framework

content 26-8

@node	26-9, Chapter 27, 26-8, Chapter 26
@section The Implementation

content 26-9

@node    Chapter 27, Chapter 28, Chapter 26, Top
@section 27. Practical: An MP3 Database

content 27-intro

@menu
* 27-1::       The Database
* 27-2::       Defining a Schema
* 27-3::       Inserting Values
* 27-4::       Querying the Database
* 27-5::       Matching Functions
* 27-6::       Getting at the Results
* 27-7::       Other Database Operations
@end menu

@node	27-1, 27-2, Chapter 27, Chapter 27
@section The Database

content 27-1

@node	27-2, 27-3, 27-1, Chapter 27
@section Defining a Schema

content 27-2

@node	27-3, 27-4, 27-2, Chapter 27
@section Inserting Values

content 27-3

@node	27-4, 27-5, 27-3, Chapter 27
@section Querying the Database

content 27-4

@node	27-5, 27-6, 27-4, Chapter 27
@section Matching Functions

content 27-5

@node	27-6, 27-7, 27-5, Chapter 27
@section Getting at the Results

content 27-6

@node	27-7, Chapter 28, 27-6, Chapter 27
@section Other Database Operations

content 27-7

@node    Chapter 28, Chapter 29, Chapter 27, Top
@section 28. Practical: A Shoutcast Server

content 28-intro

@menu
* 28-1::       The Shoutcast Protocol
* 28-2::       Song Sources
* 28-3::       Implementing Shoutcast
@end menu

@node	28-1, 28-2, Chapter 28, Chapter 28
@section The Shoutcast Protocol

content 28-1

@node	28-2, 28-3, 28-1, Chapter 28
@section Song Sources

content 28-2

@node	28-3, Chapter 29, 28-2, Chapter 28
@section Implementing Shoutcast

content 28-3

@node    Chapter 29, Chapter 30, Chapter 28, Top
@section 29. Practical: An MP3 Browser

content 29-intro

@menu
* 29-1::       Playlists
* 29-2::       Playlists As Song Sources
* 29-3::       Manipulating the Playlist
* 29-4::       Query Parameter Types
* 29-5::       Boilerplate HTML
* 29-6::       The Browse Page
* 29-7::       The Playlist
* 29-8::       Finding a Playlist
* 29-9::       Running the App
@end menu

@node	29-1, 29-2, Chapter 29, Chapter 29
@section Playlists

content 29-1

@node	29-2, 29-3, 29-1, Chapter 29
@section Playlists As Song Sources

content 29-2

@node	29-3, 29-4, 29-2, Chapter 29
@section Manipulating the Playlist

content 29-3

@node	29-4, 29-5, 29-3, Chapter 29
@section Query Parameter Types

content 29-4

@node	29-5, 29-6, 29-4, Chapter 29
@section Boilerplate HTML

content 29-5

@node	29-6, 29-7, 29-5, Chapter 29
@section The Browse Page

content 29-6

@node	29-7, 29-8, 29-6, Chapter 29
@section The Playlist

content 29-7

@node	29-8, 29-9, 29-7, Chapter 29
@section Finding a Playlist

content 29-8

@node	29-9, Chapter 30, 29-8, Chapter 29
@section Running the App

content 29-9

@node    Chapter 30, Chapter 31, Chapter 29, Top
@section 30. Practical: An HTML Generation Library, the Interpreter

content 30-intro

@menu
* 30-1::       Designing a Domain-Specific Language
* 30-2::       The FOO Language
* 30-3::       Character Escaping
* 30-4::       Indenting Printer
* 30-5::       HTML Processor Interface
* 30-6::       The Pretty Printer Backend
* 30-7::       The Basic Evaluation Rule
* 30-8::       What's Next?
@end menu

@node	30-1, 30-2, Chapter 30, Chapter 30
@section Designing a Domain-Specific Language

content 30-1

@node	30-2, 30-3, 30-1, Chapter 30
@section The FOO Language

content 30-2

@node	30-3, 30-4, 30-2, Chapter 30
@section Character Escaping

content 30-3

@node	30-4, 30-5, 30-3, Chapter 30
@section Indenting Printer

content 30-4

@node	30-5, 30-6, 30-4, Chapter 30
@section HTML Processor Interface

content 30-5

@node	30-6, 30-7, 30-5, Chapter 30
@section The Pretty Printer Backend

content 30-6

@node	30-7, 30-8, 30-6, Chapter 30
@section The Basic Evaluation Rule

content 30-7

@node	30-8, Chapter 31, 30-7, Chapter 30
@section What's Next?

content 30-8

@node    Chapter 31, Chapter 32, Chapter 30, Top
@section 31. Practical: An HTML Generation Library, the Compiler

content 31-intro

@menu
* 31-1::       The Compiler
* 31-2::       FOO Special Operators
* 31-3::       FOO Macros
* 31-4::       The Public API
* 31-5::       The End of the Line
@end menu

@node	31-1, 31-2, Chapter 31, Chapter 31
@section The Compiler

content 31-1

@node	31-2, 31-3, 31-1, Chapter 31
@section FOO Special Operators

content 31-2

@node	31-3, 31-4, 31-2, Chapter 31
@section FOO Macros

content 31-3

@node	31-4, 31-5, 31-3, Chapter 31
@section The Public API

content 31-4

@node	31-5, Chapter 32, 31-4, Chapter 31
@section The End of the Line

content 31-5

@node    Chapter 32, , Chapter 31, Top
@section 32. Conclusion: What's Next?

content 32-intro

@menu
* 32-1::        Finding Lisp Libraries
* 32-2::        Interfacing with Other Languages
* 32-3::        Make It Work, Make It Right, Make It Fast
* 32-4::        Delivering Applications
* 32-5::        Where to Go Next
@end menu

@node	32-1, 32-2, Chapter 32, Chapter 32
@section Finding Lisp Libraries

content 32-1

@node	32-2, 32-3, 32-1, Chapter 32
@section Interfacing with Other Languages

content 32-2

@node	32-3, 32-4, 32-2, Chapter 32
@section Make It Work, Make It Right, Make It Fast

content 32-3

@node	32-4, 32-5, 32-3, Chapter 32
@section Delivering Applications

content 32-4

@node	32-5, Chapter 32, 32-4, Chapter 32
@section Where to Go Next

content 32-5
